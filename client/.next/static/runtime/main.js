(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["static/runtime/main.js"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var Bus = __importStar(__webpack_require__(/*! ./internal/bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js");
var isRegistered = false;
var stackTraceLimit = undefined;
function onUnhandledError(ev) {
    var error = ev === null || ev === void 0 ? void 0 : ev.error;
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = error;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_ERROR,
        reason: error,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function onUnhandledRejection(ev) {
    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;
    if (!reason ||
        !(reason instanceof Error) ||
        typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = reason;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_REJECTION,
        reason: reason,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 50;
        stackTraceLimit = limit;
    }
    catch (_a) { }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
}
exports.register = register;
function unregister() {
    if (!isRegistered) {
        return;
    }
    isRegistered = false;
    if (stackTraceLimit !== undefined) {
        try {
            Error.stackTraceLimit = stackTraceLimit;
        }
        catch (_a) { }
        stackTraceLimit = undefined;
    }
    window.removeEventListener('error', onUnhandledError);
    window.removeEventListener('unhandledrejection', onUnhandledRejection);
}
exports.unregister = unregister;
function onBuildOk() {
    Bus.emit({ type: Bus.TYPE_BUILD_OK });
}
exports.onBuildOk = onBuildOk;
function onBuildError(message) {
    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });
}
exports.onBuildError = onBuildError;
function onRefresh() {
    Bus.emit({ type: Bus.TYPE_REFFRESH });
}
exports.onRefresh = onRefresh;
var nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
exports.getNodeError = nodeStackFrames_1.getNodeError;
var ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js");
exports.ReactDevOverlay = ReactDevOverlay_1["default"];


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { error: null };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, 
    // Loosely typed because it depends on the React version and was
    // accidentally excluded in some versions.
    errorInfo) {
        this.props.onError(error, (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || null);
        this.setState({ error: error });
    };
    ErrorBoundary.prototype.render = function () {
        return this.state.error
            ? // The component has to be unmounted or else it would continue to error
                null
            : this.props.children;
    };
    return ErrorBoundary;
}(react_1["default"].PureComponent));
exports.ErrorBoundary = ErrorBoundary;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Bus = __importStar(__webpack_require__(/*! ./bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js");
var Errors_1 = __webpack_require__(/*! ./container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var BuildError_1 = __webpack_require__(/*! ./container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js");
var Base_1 = __webpack_require__(/*! ./styles/Base */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js");
var ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js");
var CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js");
function reducer(state, ev) {
    switch (ev.type) {
        case Bus.TYPE_BUILD_OK: {
            return __assign(__assign({}, state), { buildError: null });
        }
        case Bus.TYPE_BUILD_ERROR: {
            return __assign(__assign({}, state), { buildError: ev.message });
        }
        case Bus.TYPE_REFFRESH: {
            return __assign(__assign({}, state), { buildError: null, errors: [] });
        }
        case Bus.TYPE_UNHANDLED_ERROR:
        case Bus.TYPE_UNHANDLED_REJECTION: {
            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spread(state.errors, [{ id: state.nextId, event: ev }]) });
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _1 = ev;
            return state;
        }
    }
}
function ReactDevOverlay(_a) {
    var children = _a.children;
    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];
    React.useEffect(function () {
        Bus.on(dispatch);
        return function () {
            Bus.off(dispatch);
        };
    }, [dispatch]);
    var onComponentError = React.useCallback(function (error, componentStack) {
        // TODO: special handling
    }, []);
    var hasBuildError = state.buildError != null;
    var hasRuntimeErrors = Boolean(state.errors.length);
    var isMounted = hasBuildError || hasRuntimeErrors;
    return (React.createElement(React.Fragment, null,
        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),
        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,
            React.createElement(CssReset_1.CssReset, null),
            React.createElement(Base_1.Base, null),
            React.createElement(ComponentStyles_1.ComponentStyles, null),
            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : undefined)) : undefined));
}
exports["default"] = ReactDevOverlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.TYPE_BUILD_OK = 'build-ok';
exports.TYPE_BUILD_ERROR = 'build-error';
exports.TYPE_REFFRESH = 'fast-refresh';
exports.TYPE_UNHANDLED_ERROR = 'unhandled-error';
exports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';
var handlers = new Set();
var queue = [];
function drain() {
    // Draining should never happen synchronously in case multiple handlers are
    // registered.
    setTimeout(function () {
        var _loop_1 = function () {
            var ev = queue.shift();
            handlers.forEach(function (handler) { return handler(ev); });
        };
        while (
        // Until we are out of events:
        Boolean(queue.length) &&
            // Or, if all handlers removed themselves as a result of handling the
            // event(s)
            Boolean(handlers.size)) {
            _loop_1();
        }
    }, 1);
}
function emit(ev) {
    queue.push(Object.freeze(__assign({}, ev)));
    drain();
}
exports.emit = emit;
function on(fn) {
    if (handlers.has(fn)) {
        return false;
    }
    handlers.add(fn);
    drain();
    return true;
}
exports.on = on;
function off(fn) {
    if (handlers.has(fn)) {
        handlers["delete"](fn);
        return true;
    }
    return false;
}
exports.off = off;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js"));
var stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
exports.CodeFrame = function CodeFrame(_a) {
    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;
    // Strip leading spaces out of the code frame:
    var formattedFrame = React.useMemo(function () {
        var lines = codeFrame.split(/\r?\n/g);
        var prefixLength = lines
            .map(function (line) { return /^>? +\d+ +\| ( *)/.exec(strip_ansi_1["default"](line)); })
            .filter(Boolean)
            .map(function (v) { return v.pop(); })
            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);
        if (prefixLength > 1) {
            var p_1 = ' '.repeat(prefixLength);
            return lines
                .map(function (line, a) {
                return ~(a = line.indexOf('|'))
                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')
                    : line;
            })
                .join('\n');
        }
        return lines.join('\n');
    }, [codeFrame]);
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(formattedFrame, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [formattedFrame]);
    var open = React.useCallback(function () {
        var _a;
        var params = new URLSearchParams();
        for (var key in stackFrame) {
            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [stackFrame]);
    // TODO: make the caret absolute
    return (React.createElement("div", { "data-nextjs-codeframe": true },
        React.createElement("p", { role: "link", onClick: open, tabIndex: 1, title: "Click to open in your editor" },
            React.createElement("span", null,
                stack_frame_1.getFrameSource(stackFrame),
                " @ ",
                stackFrame.methodName),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }))),
        React.createElement("hr", null),
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "frame-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var CodeFrame_1 = __webpack_require__(/*! ./CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js");
exports.CodeFrame = CodeFrame_1.CodeFrame;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"], ["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var use_on_click_outside_1 = __webpack_require__(/*! ../../hooks/use-on-click-outside */ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js");
var Dialog = function Dialog(_a) {
    var children = _a.children, type = _a.type, onClose = _a.onClose, props = __rest(_a, ["children", "type", "onClose"]);
    var _b = __read(React.useState(null), 2), dialog = _b[0], setDialog = _b[1];
    var onDialog = React.useCallback(function (node) {
        setDialog(node);
    }, []);
    use_on_click_outside_1.useOnClickOutside(dialog, onClose);
    // Make HTMLElements with `role=link` accessible to be triggered by the
    // keyboard, i.e. [Enter].
    React.useEffect(function () {
        if (dialog == null) {
            return;
        }
        var root = dialog.getRootNode();
        // Always true, but we do this for TypeScript:
        if (!(root instanceof ShadowRoot)) {
            return;
        }
        var shadowRoot = root;
        function handler(e) {
            var el = shadowRoot.activeElement;
            if (e.key === 'Enter' &&
                el instanceof HTMLElement &&
                el.getAttribute('role') === 'link') {
                e.preventDefault();
                e.stopPropagation();
                el.click();
            }
        }
        shadowRoot.addEventListener('keydown', handler);
        return function () { return shadowRoot.removeEventListener('keydown', handler); };
    }, [dialog]);
    return (React.createElement("div", { ref: onDialog, "data-nextjs-dialog": true, tabIndex: -1, role: "dialog", "aria-labelledby": props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-modal": "true" },
        React.createElement("div", { "data-nextjs-dialog-banner": true, className: "banner-" + type }),
        children));
};
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogBody = function DialogBody(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-body": true, className: className }, children));
};
exports.DialogBody = DialogBody;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogContent = function DialogContent(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-content": true, className: className }, children));
};
exports.DialogContent = DialogContent;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogHeader = function DialogHeader(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-header": true, className: className }, children));
};
exports.DialogHeader = DialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Dialog_1 = __webpack_require__(/*! ./Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js");
exports.Dialog = Dialog_1.Dialog;
var DialogBody_1 = __webpack_require__(/*! ./DialogBody */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js");
exports.DialogBody = DialogBody_1.DialogBody;
var DialogContent_1 = __webpack_require__(/*! ./DialogContent */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js");
exports.DialogContent = DialogContent_1.DialogContent;
var DialogHeader_1 = __webpack_require__(/*! ./DialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js");
exports.DialogHeader = DialogHeader_1.DialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"], ["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var LeftRightDialogHeader = function LeftRightDialogHeader(_a) {
    var children = _a.children, className = _a.className, previous = _a.previous, next = _a.next, close = _a.close;
    var buttonLeft = React.useRef();
    var buttonRight = React.useRef();
    var buttonClose = React.useRef();
    var _b = __read(React.useState(null), 2), nav = _b[0], setNav = _b[1];
    var onNav = React.useCallback(function (el) {
        setNav(el);
    }, []);
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        var d = self.document;
        function handler(e) {
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                if (buttonLeft.current) {
                    buttonLeft.current.focus();
                }
                previous && previous();
            }
            else if (e.key === 'ArrowRight') {
                e.stopPropagation();
                if (buttonRight.current) {
                    buttonRight.current.focus();
                }
                next && next();
            }
            else if (e.key === 'Escape') {
                e.stopPropagation();
                if (root instanceof ShadowRoot) {
                    var a = root.activeElement;
                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {
                        a.blur();
                        return;
                    }
                }
                close();
            }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
            d.addEventListener('keydown', handler);
        }
        return function () {
            root.removeEventListener('keydown', handler);
            if (root !== d) {
                d.removeEventListener('keydown', handler);
            }
        };
    }, [close, nav, next, previous]);
    // Unlock focus for browsers like Firefox, that break all user focus if the
    // currently focused item becomes disabled.
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
            var a = root.activeElement;
            if (previous == null) {
                if (a === buttonLeft.current) {
                    buttonLeft.current.blur();
                }
            }
            else if (next == null) {
                if (a === buttonRight.current) {
                    buttonRight.current.blur();
                }
            }
        }
    }, [nav, next, previous]);
    return (React.createElement("div", { "data-nextjs-dialog-left-right": true, className: className },
        React.createElement("nav", { ref: onNav },
            React.createElement("button", { ref: buttonLeft, type: "button", disabled: previous == null ? true : undefined, "aria-disabled": previous == null ? true : undefined, onClick: previous !== null && previous !== void 0 ? previous : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            React.createElement("button", { ref: buttonRight, type: "button", disabled: next == null ? true : undefined, "aria-disabled": next == null ? true : undefined, onClick: next !== null && next !== void 0 ? next : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            "\u00A0",
            children),
        React.createElement("button", { ref: buttonClose, type: "button", onClick: close, "aria-label": "Close" },
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M18 6L6 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
                    React.createElement("path", { d: "M6 6L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))))));
};
exports.LeftRightDialogHeader = LeftRightDialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var LeftRightDialogHeader_1 = __webpack_require__(/*! ./LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js");
exports.LeftRightDialogHeader = LeftRightDialogHeader_1.LeftRightDialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"], ["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var disabled_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/disabled */ "./node_modules/ally.js/maintain/disabled.js"));
var tab_focus_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/tab-focus */ "./node_modules/ally.js/maintain/tab-focus.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var body_locker_1 = __webpack_require__(/*! ./body-locker */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js");
var Overlay = function Overlay(_a) {
    var className = _a.className, children = _a.children, fixed = _a.fixed;
    React.useEffect(function () {
        body_locker_1.lock();
        return function () {
            body_locker_1.unlock();
        };
    }, []);
    var _b = __read(React.useState(null), 2), overlay = _b[0], setOverlay = _b[1];
    var onOverlay = React.useCallback(function (el) {
        setOverlay(el);
    }, []);
    React.useEffect(function () {
        if (overlay == null) {
            return;
        }
        var handle1 = disabled_1["default"]({ filter: overlay });
        var handle2 = tab_focus_1["default"]({ context: overlay });
        return function () {
            handle1.disengage();
            handle2.disengage();
        };
    }, [overlay]);
    return (React.createElement("div", { "data-nextjs-dialog-overlay": true, className: className, ref: onOverlay },
        React.createElement("div", { "data-nextjs-dialog-backdrop": true, "data-nextjs-dialog-backdrop-fixed": fixed ? true : undefined }),
        children));
};
exports.Overlay = Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var previousBodyPaddingRight;
var previousBodyOverflowSetting;
var activeLocks = 0;
function lock() {
    setTimeout(function () {
        if (activeLocks++ > 0) {
            return;
        }
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
            previousBodyPaddingRight = document.body.style.paddingRight;
            document.body.style.paddingRight = scrollBarGap + "px";
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    });
}
exports.lock = lock;
function unlock() {
    setTimeout(function () {
        if (activeLocks === 0 || --activeLocks !== 0) {
            return;
        }
        if (previousBodyPaddingRight !== undefined) {
            document.body.style.paddingRight = previousBodyPaddingRight;
            previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
            document.body.style.overflow = previousBodyOverflowSetting;
            previousBodyOverflowSetting = undefined;
        }
    });
}
exports.unlock = unlock;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Overlay_1 = __webpack_require__(/*! ./Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js");
exports.Overlay = Overlay_1.Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"], ["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_dom_1 = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
exports.ShadowPortal = function Portal(_a) {
    var children = _a.children;
    var mountNode = React.useRef(null);
    var portalNode = React.useRef(null);
    var shadowNode = React.useRef(null);
    var _b = __read(React.useState(), 2), forceUpdate = _b[1];
    React.useLayoutEffect(function () {
        var ownerDocument = mountNode.current.ownerDocument;
        portalNode.current = ownerDocument.createElement('nextjs-portal');
        shadowNode.current = portalNode.current.attachShadow({ mode: 'open' });
        ownerDocument.body.appendChild(portalNode.current);
        forceUpdate({});
        return function () {
            if (portalNode.current && portalNode.current.ownerDocument) {
                portalNode.current.ownerDocument.body.removeChild(portalNode.current);
            }
        };
    }, []);
    return shadowNode.current ? (react_dom_1.createPortal(children, shadowNode.current)) : (React.createElement("span", { ref: mountNode }));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Terminal = function Terminal(_a) {
    var content = _a.content;
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(content, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [content]);
    return (React.createElement("div", { "data-nextjs-terminal": true },
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "terminal-entry-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Terminal_1 = __webpack_require__(/*! ./Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js");
exports.Terminal = Terminal_1.Terminal;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"], ["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Toast = function Toast(_a) {
    var onClick = _a.onClick, children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-toast": true, onClick: onClick, className: className },
        React.createElement("div", { "data-nextjs-toast-wrapper": true }, children)));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js");
exports.styles = styles_1.styles;
var Toast_1 = __webpack_require__(/*! ./Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js");
exports.Toast = Toast_1.Toast;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"], ["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Terminal_1 = __webpack_require__(/*! ../components/Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
exports.BuildError = function BuildError(_a) {
    var message = _a.message;
    var noop = React.useCallback(function () { }, []);
    return (React.createElement(Overlay_1.Overlay, { fixed: true },
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_build_error_label", "aria-describedby": "nextjs__container_build_error_desc", onClose: noop },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-build-error-header" },
                    React.createElement("h4", { id: "nextjs__container_build_error_label" }, "Failed to compile")),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-build-error-body" },
                    React.createElement(Terminal_1.Terminal, { content: message }),
                    React.createElement("footer", null,
                        React.createElement("p", { id: "nextjs__container_build_error_desc" },
                            React.createElement("small", null, "This error occured during the build process and can only be dismissed by fixing the error."))))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"], ["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var bus_1 = __webpack_require__(/*! ../bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var LeftRightDialogHeader_1 = __webpack_require__(/*! ../components/LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var nodeStackFrames_1 = __webpack_require__(/*! ../helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var RuntimeError_1 = __webpack_require__(/*! ./RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
function getErrorSignature(ev) {
    var event = ev.event;
    switch (event.type) {
        case bus_1.TYPE_UNHANDLED_ERROR:
        case bus_1.TYPE_UNHANDLED_REJECTION: {
            return event.reason.name + "::" + event.reason.message + "::" + event.reason.stack;
        }
        default: {
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _ = event;
    return '';
}
function getErrorByType(ev) {
    return __awaiter(this, void 0, void 0, function () {
        var id, event, _a, _b, _;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    id = ev.id, event = ev.event;
                    _a = event.type;
                    switch (_a) {
                        case bus_1.TYPE_UNHANDLED_ERROR: return [3 /*break*/, 1];
                        case bus_1.TYPE_UNHANDLED_REJECTION: return [3 /*break*/, 1];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    _b = {
                        id: id,
                        runtime: true,
                        error: event.reason
                    };
                    return [4 /*yield*/, stack_frame_1.getOriginalStackFrames(nodeStackFrames_1.isNodeError(event.reason), event.frames)];
                case 2: return [2 /*return*/, (_b.frames = _c.sent(),
                        _b)];
                case 3:
                    {
                        return [3 /*break*/, 4];
                    }
                    _c.label = 4;
                case 4:
                    _ = event;
                    throw new Error('type system invariant violation');
            }
        });
    });
}
exports.Errors = function Errors(_a) {
    var errors = _a.errors;
    var _b = __read(React.useState({}), 2), lookups = _b[0], setLookups = _b[1];
    var _c = __read(React.useMemo(function () {
        var ready = [];
        var next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (var idx = 0; idx < errors.length; ++idx) {
            var e = errors[idx];
            var id = e.id;
            if (id in lookups) {
                ready.push(lookups[id]);
                continue;
            }
            // Check for duplicate errors
            if (idx > 0) {
                var prev = errors[idx - 1];
                if (getErrorSignature(prev) === getErrorSignature(e)) {
                    continue;
                }
            }
            next = e;
            break;
        }
        return [ready, next];
    }, [errors, lookups]), 2), readyErrors = _c[0], nextError = _c[1];
    var isLoading = React.useMemo(function () {
        return readyErrors.length < 1 && Boolean(errors.length);
    }, [errors.length, readyErrors.length]);
    React.useEffect(function () {
        if (nextError == null) {
            return;
        }
        getErrorByType(nextError).then(function (resolved) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            setLookups(function (m) {
                var _a;
                return (__assign(__assign({}, m), (_a = {}, _a[resolved.id] = resolved, _a)));
            });
        }, function () {
            // TODO: handle this, though an edge case
        });
    }, [nextError]);
    var _d = __read(React.useState(false), 2), isMinimized = _d[0], setMinimized = _d[1];
    var _e = __read(React.useState(0), 2), activeIdx = _e[0], setActiveIndex = _e[1];
    var previous = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, v - 1); });
    }, []);
    var next = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) {
            return Math.max(0, Math.min(readyErrors.length - 1, v + 1));
        });
    }, [readyErrors.length]);
    var activeError = React.useMemo(function () { var _a; return (_a = readyErrors[activeIdx]) !== null && _a !== void 0 ? _a : null; }, [activeIdx, readyErrors]);
    // Reset component state when there are no errors to be displayed.
    // This should never happen, but lets handle it.
    React.useEffect(function () {
        if (errors.length < 1) {
            setLookups({});
            setMinimized(false);
            setActiveIndex(0);
        }
    }, [errors.length]);
    var minimize = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(true);
    }, []);
    var reopen = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(false);
    }, []);
    // This component shouldn't be rendered with no errors, but if it is, let's
    // handle it gracefully by rendering nothing.
    if (errors.length < 1) {
        return null;
    }
    if (isLoading) {
        // TODO: better loading state
        return React.createElement(Overlay_1.Overlay, null);
    }
    if (isMinimized) {
        return (React.createElement(Toast_1.Toast, { className: "nextjs-toast-errors-parent", onClick: reopen },
            React.createElement("div", { className: "nextjs-toast-errors" },
                React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                    React.createElement("circle", { cx: "12", cy: "12", r: "10" }),
                    React.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                    React.createElement("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })),
                React.createElement("span", null,
                    readyErrors.length,
                    " error",
                    readyErrors.length > 1 ? 's' : ''))));
    }
    var isServerError = nodeStackFrames_1.isNodeError(activeError.error);
    return (React.createElement(Overlay_1.Overlay, null,
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_errors_label", "aria-describedby": "nextjs__container_errors_desc", onClose: minimize },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-errors-header" },
                    React.createElement(LeftRightDialogHeader_1.LeftRightDialogHeader, { previous: activeIdx > 0 ? previous : null, next: activeIdx < readyErrors.length - 1 ? next : null, close: minimize },
                        React.createElement("small", null,
                            React.createElement("span", null, activeIdx + 1),
                            " of",
                            ' ',
                            React.createElement("span", null, readyErrors.length),
                            " unhandled error",
                            readyErrors.length < 2 ? '' : 's')),
                    React.createElement("h1", { id: "nextjs__container_errors_label" }, isServerError ? 'Server Error' : 'Unhandled Runtime Error'),
                    React.createElement("p", { id: "nextjs__container_errors_desc" },
                        activeError.error.name,
                        ": ",
                        activeError.error.message),
                    isServerError ? (React.createElement("div", null,
                        React.createElement("small", null, "This error happened while generating the page. Any console logs will be displayed in the terminal window."))) : undefined),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-errors-body" },
                    React.createElement(RuntimeError_1.RuntimeError, { key: activeError.id.toString(), error: activeError }))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"], ["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var CallStackFrame = function CallStackFrame(_a) {
    // TODO: ability to expand resolved frames
    // TODO: render error or external indicator
    var frame = _a.frame;
    var _b;
    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;
    var hasSource = Boolean(frame.originalCodeFrame);
    var open = React.useCallback(function () {
        var _a;
        if (!hasSource)
            return;
        var params = new URLSearchParams();
        for (var key in f) {
            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [hasSource, f]);
    return (React.createElement("div", { "data-nextjs-call-stack-frame": true },
        React.createElement("h6", { "data-nextjs-frame-expanded": Boolean(frame.expanded) }, f.methodName),
        React.createElement("div", { "data-has-source": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },
            React.createElement("span", null, stack_frame_1.getFrameSource(f)),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" })))));
};
var RuntimeError = function RuntimeError(_a) {
    var error = _a.error;
    var firstFirstPartyFrameIndex = React.useMemo(function () {
        return error.frames.findIndex(function (entry) {
            return entry.expanded &&
                Boolean(entry.originalCodeFrame) &&
                Boolean(entry.originalStackFrame);
        });
    }, [error.frames]);
    var firstFrame = React.useMemo(function () {
        var _a;
        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;
    }, [error.frames, firstFirstPartyFrameIndex]);
    var allLeadingFrames = React.useMemo(function () {
        return firstFirstPartyFrameIndex < 0
            ? []
            : error.frames.slice(0, firstFirstPartyFrameIndex);
    }, [error.frames, firstFirstPartyFrameIndex]);
    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];
    var toggleAll = React.useCallback(function () {
        setAll(function (v) { return !v; });
    }, []);
    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);
    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);
    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);
    var canShowMore = React.useMemo(function () {
        return (allCallStackFrames.length !== visibleCallStackFrames.length ||
            (all && firstFrame != null));
    }, [
        all,
        allCallStackFrames.length,
        firstFrame,
        visibleCallStackFrames.length,
    ]);
    return (React.createElement(React.Fragment, null,
        firstFrame ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Source"),
            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "leading-frame-" + index + "-" + all, frame: frame })); }),
            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : undefined,
        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Call Stack"),
            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "call-stack-" + index + "-" + all, frame: frame })); }))) : undefined,
        canShowMore ? (React.createElement(React.Fragment, null,
            React.createElement("button", { tabIndex: 10, "data-nextjs-data-runtime-error-collapsed-action": true, type: "button", onClick: toggleAll },
                all ? 'Hide' : 'Show',
                " collapsed frames"))) : undefined));
};
exports.RuntimeError = RuntimeError;
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"], ["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
function getFilesystemFrame(frame) {
    var f = __assign({}, frame);
    if (typeof f.file === 'string') {
        if (
        // Posix:
        f.file.startsWith('/') ||
            // Win32:
            /^[a-z]:\\/i.test(f.file) ||
            // Win32 UNC:
            f.file.startsWith('\\\\')) {
            f.file = "file://" + f.file;
        }
    }
    return f;
}
exports.getFilesystemFrame = getFilesystemFrame;
var symbolNodeError = Symbol('NextjsNodeError');
function isNodeError(error) {
    return symbolNodeError in error;
}
exports.isNodeError = isNodeError;
function getNodeError(error) {
    var n;
    try {
        throw new Error(error.message);
    }
    catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = stacktrace_parser_1.parse(error.stack)
            .map(getFilesystemFrame)
            .map(function (f) {
            var str = "    at " + f.methodName;
            if (f.file) {
                var loc = f.file;
                if (f.lineNumber) {
                    loc += ":" + f.lineNumber;
                    if (f.column) {
                        loc += ":" + f.column;
                    }
                }
                str += " (" + loc + ")";
            }
            return str;
        })
            .join('\n');
    }
    catch (_a) {
        n.stack = error.stack;
    }
    Object.defineProperty(n, symbolNodeError, {
        writable: false,
        enumerable: false,
        configurable: false
    });
    return n;
}
exports.getNodeError = getNodeError;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
function noop(strings) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var lastIndex = strings.length - 1;
    return (strings.slice(0, lastIndex).reduce(function (p, s, i) { return p + s + keys[i]; }, '') +
        strings[lastIndex]);
}
exports.noop = noop;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
var regexNextStatic = /\/_next(\/static\/.+)/g;
function parseStack(stack) {
    var frames = stacktrace_parser_1.parse(stack);
    return frames.map(function (frame) {
        var _a, _b;
        try {
            var url = new URL(frame.file);
            var res = regexNextStatic.exec(url.pathname);
            if (res) {
                var distDir = (_b = (_a = "F:\\StackoverflowClone\\client\\.next") === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/')) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '');
                if (distDir) {
                    frame.file = 'file://' + distDir.concat(res.pop());
                }
            }
        }
        catch (_c) { }
        return frame;
    });
}
exports.parseStack = parseStack;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
function getOriginalStackFrames(isServerSide, frames) {
    return Promise.all(frames.map(function (frame) { return getOriginalStackFrame(isServerSide, frame); }));
}
exports.getOriginalStackFrames = getOriginalStackFrames;
function getOriginalStackFrame(isServerSide, source) {
    var _a, _b;
    function _getOriginalStackFrame() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var params, key, controller, tm, res, _c, _d, _e, body;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        params = new URLSearchParams();
                        params.append('isServerSide', String(isServerSide));
                        for (key in source) {
                            params.append(key, ((_a = source[key]) !== null && _a !== void 0 ? _a : '').toString());
                        }
                        controller = new AbortController();
                        tm = setTimeout(function () { return controller.abort(); }, 3000);
                        return [4 /*yield*/, self
                                .fetch("/__nextjs_original-stack-frame?" + params.toString(), {
                                signal: controller.signal
                            })["finally"](function () {
                                clearTimeout(tm);
                            })];
                    case 1:
                        res = _f.sent();
                        if (!(!res.ok || res.status === 204)) return [3 /*break*/, 3];
                        _d = (_c = Promise).reject;
                        _e = Error.bind;
                        return [4 /*yield*/, res.text()];
                    case 2: return [2 /*return*/, _d.apply(_c, [new (_e.apply(Error, [void 0, _f.sent()]))()])];
                    case 3: return [4 /*yield*/, res.json()];
                    case 4:
                        body = _f.sent();
                        return [2 /*return*/, {
                                error: false,
                                reason: null,
                                external: false,
                                expanded: ((_b = body.originalStackFrame) === null || _b === void 0 ? void 0 : _b.file) &&
                                    !body.originalStackFrame.file.includes('node_modules'),
                                sourceStackFrame: source,
                                originalStackFrame: body.originalStackFrame,
                                originalCodeFrame: body.originalCodeFrame || null
                            }];
                }
            });
        });
    }
    if (!(((_a = source.file) === null || _a === void 0 ? void 0 : _a.startsWith('webpack-internal:')) || ((_b = source.file) === null || _b === void 0 ? void 0 : _b.startsWith('file:')))) {
        return Promise.resolve({
            error: false,
            reason: null,
            external: true,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    }
    return _getOriginalStackFrame()["catch"](function (err) {
        var _a, _b;
        return ({
            error: true,
            reason: (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : 'Unknown Error',
            external: false,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    });
}
exports.getOriginalStackFrame = getOriginalStackFrame;
function getFrameSource(frame) {
    var _a;
    var str = '';
    try {
        var u = new URL(frame.file);
        // Strip the origin for same-origin scripts.
        if (typeof globalThis !== 'undefined' &&
            ((_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== u.origin) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
                str += u.protocol;
            }
            else {
                str += u.origin;
            }
        }
        // Strip query string information as it's typically too verbose to be
        // meaningful.
        str += u.pathname;
        str += ' ';
    }
    catch (_b) {
        str += (frame.file || '(unknown)') + ' ';
    }
    if (frame.lineNumber != null) {
        if (frame.column != null) {
            str += "(" + frame.lineNumber + ":" + frame.column + ") ";
        }
        else {
            str += "(" + frame.lineNumber + ") ";
        }
    }
    return str.slice(0, -1);
}
exports.getFrameSource = getFrameSource;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
function useOnClickOutside(el, handler) {
    React.useEffect(function () {
        if (el == null) {
            return;
        }
        var listener = function (e) {
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(e.target)) {
                return;
            }
            handler(e);
        };
        var root = el.getRootNode();
        root.addEventListener('mousedown', listener);
        root.addEventListener('touchstart', listener);
        return function () {
            root.removeEventListener('mousedown', listener);
            root.removeEventListener('touchstart', listener);
        };
    }, [handler, el]);
}
exports.useOnClickOutside = useOnClickOutside;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function Base() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "], ["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "])))
        } }));
}
exports.Base = Base;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var styles_1 = __webpack_require__(/*! ../components/CodeFrame/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var styles_2 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
var styles_3 = __webpack_require__(/*! ../components/Overlay/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js");
var styles_4 = __webpack_require__(/*! ../components/Terminal/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var BuildError_1 = __webpack_require__(/*! ../container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var Errors_1 = __webpack_require__(/*! ../container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var RuntimeError_1 = __webpack_require__(/*! ../container/RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function ComponentStyles() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "], ["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "])), styles_3.styles, Toast_1.styles, Dialog_1.styles, styles_2.styles, styles_1.styles, styles_4.styles, BuildError_1.styles, Errors_1.styles, RuntimeError_1.styles)
        } }));
}
exports.ComponentStyles = ComponentStyles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function CssReset() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "], ["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "])))
        } }));
}
exports.CssReset = CssReset;
var templateObject_1;


/***/ }),

/***/ "./node_modules/ally.js/element/disabled.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/element/disabled.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context, disabledState) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'element/disabled',
    context: context
  });

  // accept truthy/falsy values
  disabledState = Boolean(disabledState);
  var currentState = element.hasAttribute('data-ally-disabled');
  // if there's no value to set, we're running as a getter
  var runningAsGetter = arguments.length === 1;

  if ((0, _nativeDisabledSupported2.default)(element)) {
    if (runningAsGetter) {
      return element.disabled;
    }

    // form elements know the disabled attribute, which we shall use instead of our poor man's copy of it
    element.disabled = disabledState;
    return element;
  }

  if (runningAsGetter) {
    return currentState;
  }

  if (currentState === disabledState) {
    // no update necessary
    return element;
  }

  setElementDisabled(element, disabledState);
  return element;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _nativeDisabledSupported = __webpack_require__(/*! ../is/native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _toggleAttribute = __webpack_require__(/*! ../util/toggle-attribute */ "./node_modules/ally.js/util/toggle-attribute.js");

var _toggleAttribute2 = _interopRequireDefault(_toggleAttribute);

var _toggleAttributeValue = __webpack_require__(/*! ../util/toggle-attribute-value */ "./node_modules/ally.js/util/toggle-attribute-value.js");

var _toggleAttributeValue2 = _interopRequireDefault(_toggleAttributeValue);

var _logger = __webpack_require__(/*! ../util/logger */ "./node_modules/ally.js/util/logger.js");

var _logger2 = _interopRequireDefault(_logger);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
/*
  Utility to make any element inert (disabled). Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard - and thus not receive focus.

  Elements made inert (disabled) by this utility are given the attribute [data-ally-disabled="true"].

  ---------------

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

function disabledFocus() {
  _logger2.default.warn('trying to focus inert element', this);
}

function disableTabindex(element, disabledState) {
  if (disabledState) {
    var tabIndex = (0, _tabindexValue2.default)(element);
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex',
      temporaryValue: '-1',
      saveValue: tabIndex !== null ? tabIndex : ''
    });
  } else {
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex'
    });
  }
}

function disableVideoControls(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'controls',
    remove: disabledState
  });
}

function disableSvgFocusable(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'focusable',
    temporaryValue: disabledState ? 'false' : undefined
  });
}

function disableSvgLink(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'xlink:href',
    remove: disabledState
  });
}

function setAriaDisabled(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'aria-disabled',
    temporaryValue: disabledState ? 'true' : undefined
  });
}

function disableScriptFocus(element, disabledState) {
  if (disabledState) {
    // make sure no script can focus the element
    element.focus = disabledFocus;
  } else {
    // restore original focus function from prototype
    delete element.focus;
  }
}

function disablePointerEvents(element, disabledState) {
  if (disabledState) {
    // remember previous pointer events status so we can restore it
    var pointerEvents = element.style.pointerEvents || '';
    element.setAttribute('data-inert-pointer-events', pointerEvents);
    // make sure no pointer interaction can access the element
    element.style.pointerEvents = 'none';
  } else {
    // restore to previous pointer interaction status
    var _pointerEvents = element.getAttribute('data-inert-pointer-events');
    element.removeAttribute('data-inert-pointer-events');
    element.style.pointerEvents = _pointerEvents;
  }
}

function setElementDisabled(element, disabledState) {
  setAriaDisabled(element, disabledState);
  disableTabindex(element, disabledState);
  disableScriptFocus(element, disabledState);
  disablePointerEvents(element, disabledState);

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'video' || nodeName === 'audio') {
    // Blink and Gecko leave <video controls tabindex="-1"> in document focus navigation sequence
    // Blink leaves <audio controls tabindex="-1"> in document focus navigation sequence
    disableVideoControls(element, disabledState);
  }

  if (nodeName === 'svg' || element.ownerSVGElement) {
    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer knows focusable="false" instead of tabindex="-1"
      disableSvgFocusable(element, disabledState);
    } else if (!supports.focusSvgTabindexAttribute && nodeName === 'a') {
      // Firefox neither knows focusable="false" nor tabindex="-1"
      disableSvgLink(element, disabledState);
    }
  }

  if (disabledState) {
    element.setAttribute('data-ally-disabled', 'true');
  } else {
    element.removeAttribute('data-ally-disabled');
  }
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/element/focus.svg-foreign-object-hack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  // Edge13, Edge14: foreignObject focus hack
  // https://jsbin.com/kunehinugi/edit?html,js,output
  // https://jsbin.com/fajagi/3/edit?html,js,output
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (!isSvgElement) {
    return false;
  }

  // inject and focus an <input> element into the SVG element to receive focus
  var foreignObject = makeFocusableForeignObject();
  element.appendChild(foreignObject);
  var input = foreignObject.querySelector('input');
  input.focus();

  // upon disabling the activeElement, IE and Edge
  // will not shift focus to <body> like all the other
  // browsers, but instead find the first focusable
  // ancestor and shift focus to that
  input.disabled = true;

  // clean up
  element.removeChild(foreignObject);
  return true;
};

function makeFocusableForeignObject() {
  var fragment = document.createElement('div');
  fragment.innerHTML = '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';

  return fragment.firstChild.firstChild;
}

module.exports = exports['default'];
//# sourceMappingURL=focus.svg-foreign-object-hack.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/parents.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/get/parents.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var list = [];
  var element = (0, _contextToElement2.default)({
    label: 'get/parents',
    context: context
  });

  while (element) {
    list.push(element);
    // IE does know support parentElement on SVGElement
    element = element.parentNode;
    if (element && element.nodeType !== Node.ELEMENT_NODE) {
      element = null;
    }
  }

  return list;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// [elem, elem.parent, elem.parent.parent, …, html]
// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost
//# sourceMappingURL=parents.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/shadow-host.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/get/shadow-host.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'get/shadow-host',
    context: context
  });

  // walk up to the root
  var container = null;

  while (element) {
    container = element;
    element = element.parentNode;
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
  // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)
  if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {
    // the root is attached to a fragment node that has a host
    return container.host;
  }

  return null;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=shadow-host.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/active-element.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/active-element.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  var element = (0, _contextToElement2.default)({
    label: 'is/active-element',
    resolveDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(element);
  if (_document.activeElement === element) {
    return true;
  }

  var shadowHost = (0, _shadowHost2.default)({ context: element });
  if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determines if an element is the activeElement within its context, i.e. its document iFrame or ShadowHost

module.exports = exports['default'];
//# sourceMappingURL=active-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/disabled.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/disabled.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/disabled',
    context: context
  });

  if (element.hasAttribute('data-ally-disabled')) {
    // treat ally's element/disabled like the DOM native element.disabled
    return true;
  }

  if (!(0, _nativeDisabledSupported2.default)(element)) {
    // non-form elements do not support the disabled attribute
    return false;
  }

  if (element.disabled) {
    // the element itself is disabled
    return true;
  }

  var parents = (0, _parents2.default)({ context: element });
  if (parents.some(isDisabledFieldset)) {
    // a parental <fieldset> is disabld and inherits the state onto this element
    return true;
  }

  if (!supports.focusFormDisabled && parents.some(isDisabledForm)) {
    // a parental <form> is disabld and inherits the state onto this element
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _nativeDisabledSupported = __webpack_require__(/*! ./native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element is disabled (i.e. not editable)

var supports = void 0;

function isDisabledFieldset(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'fieldset' && element.disabled;
}

function isDisabledForm(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'form' && element.disabled;
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focus-relevant.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/focus-relevant.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _validTabindex = __webpack_require__(/*! ./valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element supports.can be focused by script regardless
// of the element actually being focusable at the time of execution
// i.e. <input disabled> is conisdered focus-relevant, but not focusable

function isFocusRelevantRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/focus-relevant',
    resolveDocument: true,
    context: context
  });

  if (!except.shadow && element.shadowRoot) {
    // a ShadowDOM host receives focus when the focus moves to its content
    return true;
  }

  var nodeName = element.nodeName.toLowerCase();

  if (nodeName === 'input' && element.type === 'hidden') {
    // input[type="hidden"] supports.cannot be focused
    return false;
  }

  if (nodeName === 'input' || nodeName === 'select' || nodeName === 'button' || nodeName === 'textarea') {
    return true;
  }

  if (nodeName === 'legend' && supports.focusRedirectLegend) {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'label') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'area') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'a' && element.hasAttribute('href')) {
    return true;
  }

  if (nodeName === 'object' && element.hasAttribute('usemap')) {
    // object[usemap] is not focusable in any browser
    return false;
  }

  if (nodeName === 'object') {
    var svgType = element.getAttribute('type');
    if (!supports.focusObjectSvg && svgType === 'image/svg+xml') {
      // object[type="image/svg+xml"] is not focusable in Internet Explorer
      return false;
    } else if (!supports.focusObjectSwf && svgType === 'application/x-shockwave-flash') {
      // object[type="application/x-shockwave-flash"] is not focusable in Internet Explorer 9
      return false;
    }
  }

  if (nodeName === 'iframe' || nodeName === 'object') {
    // browsing context containers
    return true;
  }

  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  if (element.hasAttribute('contenteditable')) {
    // also see CSS property user-modify below
    return true;
  }

  if (nodeName === 'audio' && (supports.focusAudioWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (nodeName === 'video' && (supports.focusVideoWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (supports.focusSummary && nodeName === 'summary') {
    return true;
  }

  var validTabindex = (0, _validTabindex2.default)(element);

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return validTabindex && supports.focusImgUsemapTabindex || supports.focusRedirectImgUsemap;
  }

  if (supports.focusTable && (nodeName === 'table' || nodeName === 'td')) {
    // IE10-11 supports.can focus <table> and <td>
    return true;
  }

  if (supports.focusFieldset && nodeName === 'fieldset') {
    // IE10-11 supports.can focus <fieldset>
    return true;
  }

  var isSvgElement = nodeName === 'svg';
  var isSvgContent = element.ownerSVGElement;
  var focusableAttribute = element.getAttribute('focusable');
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'use' && tabindex !== null && !supports.focusSvgUseTabindex) {
    // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit
    return false;
  }

  if (nodeName === 'foreignobject') {
    // <use> can only be made focusable in Blink and WebKit
    return tabindex !== null && supports.focusSvgForeignobjectTabindex;
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    return true;
  }

  if ((isSvgElement || isSvgContent) && element.focus && !supports.focusSvgNegativeTabindexAttribute && tabindex < 0) {
    // Firefox 51 and 52 treat any natively tabbable SVG element with
    // tabindex="-1" as tabbable and everything else as inert
    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
    return false;
  }

  if (isSvgElement) {
    return validTabindex || supports.focusSvg || supports.focusSvgInIframe
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    || Boolean(supports.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === 'true');
  }

  if (isSvgContent) {
    if (supports.focusSvgTabindexAttribute && validTabindex) {
      return true;
    }

    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
      return focusableAttribute === 'true';
    }
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  if (validTabindex) {
    return true;
  }

  var style = window.getComputedStyle(element, null);
  if ((0, _is.isUserModifyWritable)(style)) {
    return true;
  }

  if (supports.focusImgIsmap && nodeName === 'img' && element.hasAttribute('ismap')) {
    // IE10-11 considers the <img> in <a href><img ismap> focusable
    // https://github.com/medialize/ally.js/issues/20
    var hasLinkParent = (0, _parents2.default)({ context: element }).some(function (parent) {
      return parent.nodeName.toLowerCase() === 'a' && parent.hasAttribute('href');
    });

    if (hasLinkParent) {
      return true;
    }
  }

  // https://github.com/medialize/ally.js/issues/21
  if (!except.scrollable && supports.focusScrollContainer) {
    if (supports.focusScrollContainerWithoutOverflow) {
      // Internet Explorer does will consider the scrollable area focusable
      // if the element is a <div> or a <span> and it is in fact scrollable,
      // regardless of the CSS overflow property
      if ((0, _is.isScrollableContainer)(element, nodeName)) {
        return true;
      }
    } else if ((0, _is.hasCssOverflowScroll)(style)) {
      // Firefox requires proper overflow setting, IE does not necessarily
      // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
      return true;
    }
  }

  if (!except.flexbox && supports.focusFlexboxContainer && (0, _is.hasCssDisplayFlex)(style)) {
    // elements with display:flex are focusable in IE10-11
    return true;
  }

  var parent = element.parentElement;
  if (!except.scrollable && parent) {
    var parentNodeName = parent.nodeName.toLowerCase();
    var parentStyle = window.getComputedStyle(parent, null);
    if (supports.focusScrollBody && (0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
      // scrollable bodies are focusable Internet Explorer
      // https://github.com/medialize/ally.js/issues/21
      return true;
    }

    // Children of focusable elements with display:flex are focusable in IE10-11
    if (supports.focusChildrenOfFocusableFlexbox) {
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        return true;
      }
    }
  }

  // NOTE: elements marked as inert are not focusable,
  // but that property is not exposed to the DOM
  // https://www.w3.org/TR/html5/editing.html#inert

  return false;
}

// bind exceptions to an iterator callback
isFocusRelevantRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusRelevant = function isFocusRelevant(context) {
    return isFocusRelevantRules({
      context: context,
      except: except
    });
  };

  isFocusRelevant.rules = isFocusRelevantRules;
  return isFocusRelevant;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusRelevant = isFocusRelevantRules.except({});
exports.default = isFocusRelevant;
module.exports = exports['default'];
//# sourceMappingURL=focus-relevant.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focusable.js":
/*!**********************************************!*\
  !*** ./node_modules/ally.js/is/focusable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _validArea = __webpack_require__(/*! ./valid-area */ "./node_modules/ally.js/is/valid-area.js");

var _validArea2 = _interopRequireDefault(_validArea);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _disabled = __webpack_require__(/*! ./disabled */ "./node_modules/ally.js/is/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _onlyTabbable = __webpack_require__(/*! ./only-tabbable */ "./node_modules/ally.js/is/only-tabbable.js");

var _onlyTabbable2 = _interopRequireDefault(_onlyTabbable);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element can be focused

// https://www.w3.org/TR/html5/editing.html#focus-management

// NOTE: The following known issues exist:
//   Gecko: `svg a[xlink|href]` is not identified as focusable (because SVGElement.prototype.focus is missing)
//   Blink, WebKit: SVGElements that have been made focusable by adding a focus event listener are not identified as focusable

function isOnlyFocusRelevant(element) {
  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  var _tabindex = (0, _tabindexValue2.default)(element);
  if (element.shadowRoot && _tabindex === null) {
    // ShadowDOM host elements *may* receive focus
    // even though they are not considered focuable
    return true;
  }

  if (nodeName === 'label') {
    // <label tabindex="0"> is only tabbable in Firefox, not script-focusable
    // there's no way to make an element focusable other than by adding a tabindex,
    // and focus behavior of the label element seems hard-wired to ignore tabindex
    // in some browsers (like Gecko, Blink and WebKit)
    return !supports.focusLabelTabindex || _tabindex === null;
  }

  if (nodeName === 'legend') {
    return _tabindex === null;
  }

  if (supports.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === 'svg')) {
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    var focusableAttribute = element.getAttribute('focusable');
    return focusableAttribute && focusableAttribute === 'false';
  }

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return _tabindex === null || !supports.focusImgUsemapTabindex;
  }

  if (nodeName === 'area') {
    // all <area>s are considered relevant,
    // but only the valid <area>s are focusable
    return !(0, _validArea2.default)(element);
  }

  return false;
}

function isFocusableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    disabled: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _isOnlyTabbable = _onlyTabbable2.default.rules.except({
    onlyFocusableBrowsingContext: true,
    visible: except.visible
  });

  var element = (0, _contextToElement2.default)({
    label: 'is/focusable',
    resolveDocument: true,
    context: context
  });

  var focusRelevant = _focusRelevant2.default.rules({
    context: element,
    except: except
  });

  if (!focusRelevant || isOnlyFocusRelevant(element)) {
    return false;
  }

  if (!except.disabled && (0, _disabled2.default)(element)) {
    return false;
  }

  if (!except.onlyTabbable && _isOnlyTabbable(element)) {
    // some elements may be keyboard focusable, but not script focusable
    return false;
  }

  // elements that are not rendered, cannot be focused
  if (!except.visible) {
    var visibilityOptions = {
      context: element,
      except: {}
    };

    if (supports.focusInHiddenIframe) {
      // WebKit and Blink can focus content in hidden <iframe> and <object>
      visibilityOptions.except.browsingContext = true;
    }

    if (supports.focusObjectSvgHidden) {
      // Blink allows focusing the object element, even if it has visibility: hidden;
      // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191
      var _nodeName2 = element.nodeName.toLowerCase();
      if (_nodeName2 === 'object') {
        visibilityOptions.except.cssVisibility = true;
      }
    }

    if (!_visible2.default.rules(visibilityOptions)) {
      return false;
    }
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    var _nodeName = frameElement.nodeName.toLowerCase();
    if (_nodeName === 'object' && !supports.focusInZeroDimensionObject) {
      if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
        // WebKit can not focus content in <object> if it doesn't have dimensions
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'svg' && supports.focusSvgInIframe && !frameElement && element.getAttribute('tabindex') === null) {
    return false;
  }

  return true;
}

// bind exceptions to an iterator callback
isFocusableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusable = function isFocusable(context) {
    return isFocusableRules({
      context: context,
      except: except
    });
  };

  isFocusable.rules = isFocusableRules;
  return isFocusable;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusable = isFocusableRules.except({});
exports.default = isFocusable;
module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/is.util.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/is.util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUserModifyWritable = isUserModifyWritable;
exports.hasCssOverflowScroll = hasCssOverflowScroll;
exports.hasCssDisplayFlex = hasCssDisplayFlex;
exports.isScrollableContainer = isScrollableContainer;

// this is a shared utility file for focus-relevant.js and tabbable.js
// separate testing of this file's functions is not necessary,
// as they're implicitly tested by way of the consumers

function isUserModifyWritable(style) {
  // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify
  // https://github.com/medialize/ally.js/issues/17
  var userModify = style.webkitUserModify || '';
  return Boolean(userModify && userModify.indexOf('write') !== -1);
}

function hasCssOverflowScroll(style) {
  return [style.getPropertyValue('overflow'), style.getPropertyValue('overflow-x'), style.getPropertyValue('overflow-y')].some(function (overflow) {
    return overflow === 'auto' || overflow === 'scroll';
  });
}

function hasCssDisplayFlex(style) {
  return style.display.indexOf('flex') > -1;
}

function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
  if (nodeName !== 'div' && nodeName !== 'span') {
    // Internet Explorer advances scrollable containers and bodies to focusable
    // only if the scrollable container is <div> or <span> - this does *not*
    // happen for <section>, <article>, …
    return false;
  }

  if (parentNodeName && parentNodeName !== 'div' && parentNodeName !== 'span' && !hasCssOverflowScroll(parentStyle)) {
    return false;
  }

  return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;
}
//# sourceMappingURL=is.util.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/native-disabled-supported.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/is/native-disabled-supported.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();

    if (supports.focusFieldsetDisabled) {
      delete disabledElements.fieldset;
    }

    if (supports.focusFormDisabled) {
      delete disabledElements.form;
    }

    disabledElementsPattern = new RegExp('^(' + Object.keys(disabledElements).join('|') + ')$');
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/native-disabled-supported',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  return Boolean(disabledElementsPattern.test(nodeName));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element supports the disabled attribute

var supports = void 0;

// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
var disabledElementsPattern = void 0;
var disabledElements = {
  input: true,
  select: true,
  textarea: true,
  button: true,
  fieldset: true,
  form: true
};

module.exports = exports['default'];
//# sourceMappingURL=native-disabled-supported.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/only-tabbable.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/is/only-tabbable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isOnlyTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    onlyFocusableBrowsingContext: false,
    visible: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/only-tabbable',
    resolveDocument: true,
    context: context
  });

  if (!except.visible && !(0, _visible2.default)(element)) {
    return false;
  }

  if (!except.onlyFocusableBrowsingContext && (_platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE)) {
    var frameElement = (0, _getFrameElement2.default)(element);
    if (frameElement) {
      if ((0, _tabindexValue2.default)(frameElement) < 0) {
        // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
        // tabbable demotion onto elements of their browsing contexts
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'label' && _platform2.default.is.GECKO) {
    // Firefox cannot focus, but tab to: label[tabindex=0]
    return tabindex !== null && tabindex >= 0;
  }

  // SVG Elements were keyboard focusable but not script focusable before Firefox 51.
  // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654
  if (_platform2.default.is.GECKO && element.ownerSVGElement && !element.focus) {
    if (nodeName === 'a' && element.hasAttribute('xlink:href')) {
      // any focusable child of <svg> cannot be focused, but tabbed to
      if (_platform2.default.is.GECKO) {
        return true;
      }
    }
  }

  return false;
}

// bind exceptions to an iterator callback
isOnlyTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isOnlyTabbable = function isOnlyTabbable(context) {
    return isOnlyTabbableRules({
      context: context,
      except: except
    });
  };

  isOnlyTabbable.rules = isOnlyTabbableRules;
  return isOnlyTabbable;
};

// provide isOnlyTabbable(context) as default iterator callback
var isOnlyTabbable = isOnlyTabbableRules.except({});
exports.default = isOnlyTabbable;
module.exports = exports['default'];
//# sourceMappingURL=only-tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/tabbable.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/tabbable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element can be focused by keyboard (i.e. is part of the document's sequential focus navigation order)

var supports = void 0;

// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable
// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it
var focusableElementsPattern = /^(fieldset|table|td|body)$/;

function isTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/tabbable',
    resolveDocument: true,
    context: context
  });

  if (_platform2.default.is.BLINK && _platform2.default.is.ANDROID && _platform2.default.majorVersion > 42) {
    // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.
    // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).
    // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).
    return false;
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
      // iOS only does not consider anything from another browsing context keyboard focusable
      return false;
    }

    // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
    // tabbable demotion onto elements of their browsing contexts
    if ((0, _tabindexValue2.default)(frameElement) < 0) {
      return false;
    }

    if (!except.visible && (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) && !(0, _visible2.default)(frameElement)) {
      // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable
      return false;
    }

    // Webkit and Blink don't consider anything in <object> tabbable
    // Blink fixed that fixed in Chrome 54, Opera 41
    var frameNodeName = frameElement.nodeName.toLowerCase();
    if (frameNodeName === 'object') {
      var isFixedBlink = _platform2.default.name === 'Chrome' && _platform2.default.majorVersion >= 54 || _platform2.default.name === 'Opera' && _platform2.default.majorVersion >= 41;

      if (_platform2.default.is.WEBKIT || _platform2.default.is.BLINK && !isFixedBlink) {
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var _tabindex = (0, _tabindexValue2.default)(element);
  var tabindex = _tabindex === null ? null : _tabindex >= 0;

  if (_platform2.default.is.EDGE && _platform2.default.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {
    // Edge 14+ considers <a xlink:href="…" tabindex="-1"> keyboard focusable
    // if the element is in a nested browsing context
    return true;
  }

  var hasTabbableTabindexOrNone = tabindex !== false;
  var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;

  // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it
  // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657
  if (element.hasAttribute('contenteditable')) {
    // tabbing can still be disabled by explicitly providing [tabindex="-1"]
    return hasTabbableTabindexOrNone;
  }

  if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
    return false;
  }

  if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
    // iOS only considers a hand full of elements tabbable (keyboard focusable)
    // this holds true even with external keyboards
    var potentiallyTabbable = nodeName === 'input' && element.type === 'text' || element.type === 'password' || nodeName === 'select' || nodeName === 'textarea' || element.hasAttribute('contenteditable');

    if (!potentiallyTabbable) {
      var style = window.getComputedStyle(element, null);
      potentiallyTabbable = (0, _is.isUserModifyWritable)(style);
    }

    if (!potentiallyTabbable) {
      return false;
    }
  }

  if (nodeName === 'use' && _tabindex !== null) {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT && _platform2.default.majorVersion === 9) {
      // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex="-1"
      return true;
    }
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    if (hasTabbableTabindexOrNone) {
      // in Trident and Gecko SVGElement does not handle the tabIndex property properly
      return true;
    }

    if (element.focus && !supports.focusSvgNegativeTabindexAttribute) {
      // Firefox 51 and 52 treat any natively tabbable SVG element with
      // tabindex="-1" as tabbable and everything else as inert
      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
      return true;
    }
  }

  if (nodeName === 'svg' && supports.focusSvgInIframe && hasTabbableTabindexOrNone) {
    return true;
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    if (nodeName === 'svg') {
      if (supports.focusSvg) {
        // older Internet Explorers consider <svg> keyboard focusable
        // unless they have focsable="false", but then they wouldn't
        // be focusable and thus not even reach this filter
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable') || hasTabbableTabindex;
    }

    if (element.ownerSVGElement) {
      if (supports.focusSvgTabindexAttribute && hasTabbableTabindex) {
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable');
    }
  }
  if (element.tabIndex === undefined) {
    return Boolean(except.onlyTabbable);
  }

  if (nodeName === 'audio') {
    if (!element.hasAttribute('controls')) {
      // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong
      return false;
    } else if (_platform2.default.is.BLINK) {
      // In Chrome <audio controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'video') {
    if (!element.hasAttribute('controls')) {
      if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
        // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong
        return false;
      }
    } else if (_platform2.default.is.BLINK || _platform2.default.is.GECKO) {
      // In Chrome and Firefox <video controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'object') {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) {
      // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex="0" set
      return false;
    }
  }

  if (nodeName === 'iframe') {
    // In Internet Explorer all iframes are only focusable
    // In WebKit, Blink and Gecko iframes may be tabbable depending on content.
    // Since we can't reliably investigate iframe documents because of the
    // SameOriginPolicy, we're declaring everything only focusable.
    return false;
  }

  if (!except.scrollable && _platform2.default.is.GECKO) {
    // Firefox considers scrollable containers keyboard focusable,
    // even though their tabIndex property is -1
    var _style = window.getComputedStyle(element, null);
    if ((0, _is.hasCssOverflowScroll)(_style)) {
      return hasTabbableTabindexOrNone;
    }
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    // IE and Edge degrade <area> to script focusable, if the image
    // using the <map> has been given tabindex="-1"
    if (nodeName === 'area') {
      var img = (0, _imageMap.getImageOfArea)(element);
      if (img && (0, _tabindexValue2.default)(img) < 0) {
        return false;
      }
    }

    var _style2 = window.getComputedStyle(element, null);
    if ((0, _is.isUserModifyWritable)(_style2)) {
      // prevent being swallowed by the overzealous isScrollableContainer() below
      return element.tabIndex >= 0;
    }

    if (!except.flexbox && (0, _is.hasCssDisplayFlex)(_style2)) {
      if (_tabindex !== null) {
        return hasTabbableTabindex;
      }

      return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);
    }

    // IE considers scrollable containers script focusable only,
    // even though their tabIndex property is 0
    if ((0, _is.isScrollableContainer)(element, nodeName)) {
      return false;
    }

    var parent = element.parentElement;
    if (parent) {
      var parentNodeName = parent.nodeName.toLowerCase();
      var parentStyle = window.getComputedStyle(parent, null);
      // IE considers scrollable bodies script focusable only,
      if ((0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
        return false;
      }

      // Children of focusable elements with display:flex are focusable in IE10-11,
      // even though their tabIndex property suggests otherwise
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        // value of tabindex takes precedence
        return hasTabbableTabindex;
      }
    }
  }

  // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex
  return element.tabIndex >= 0;
}

// bind exceptions to an iterator callback
isTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isTabbable = function isTabbable(context) {
    return isTabbableRules({
      context: context,
      except: except
    });
  };

  isTabbable.rules = isTabbableRules;
  return isTabbable;
};

var isFocusRelevantWithoutFlexbox = _focusRelevant2.default.rules.except({ flexbox: true });
var isTabbableWithoutFlexbox = isTabbableRules.except({ flexbox: true });

// provide isTabbable(context) as default iterator callback
var isTabbable = isTabbableRules.except({});
exports.default = isTabbable;
module.exports = exports['default'];
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-area.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/is/valid-area.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-area',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName !== 'area') {
    return false;
  }

  var hasTabindex = element.hasAttribute('tabindex');
  if (!supports.focusAreaTabindex && hasTabindex) {
    // Blink and WebKit do not consider <area tabindex="-1" href="#void"> focusable
    return false;
  }

  var img = (0, _imageMap.getImageOfArea)(element);
  if (!img || !(0, _visible2.default)(img)) {
    return false;
  }

  // Firefox only allows fully loaded images to reference image maps
  // https://stereochro.me/ideas/detecting-broken-images-js
  if (!supports.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {
    return false;
  }

  // Firefox supports.can focus area elements even if they don't have an href attribute
  if (!supports.focusAreaWithoutHref && !element.href) {
    // Internet explorer supports.can focus area elements without href if either
    // the area element or the image element has a tabindex attribute
    return supports.focusAreaTabindex && hasTabindex || supports.focusAreaImgTabindex && img.hasAttribute('tabindex');
  }

  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
  var childOfInteractive = (0, _parents2.default)({ context: img }).slice(1).some(function (_element) {
    var name = _element.nodeName.toLowerCase();
    return name === 'button' || name === 'a';
  });

  if (childOfInteractive) {
    return false;
  }

  return true;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107

// determine if an <area> element is being properly used by and <img> via a <map>

module.exports = exports['default'];
//# sourceMappingURL=valid-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-tabindex.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/valid-tabindex.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-tabindex',
    resolveDocument: true,
    context: context
  });

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var hasTabIndex = element.hasAttribute('tabIndex');

  if (!hasTabindex && !hasTabIndex) {
    return false;
  }

  // older Firefox and Internet Explorer don't support tabindex on SVG elements
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (isSvgElement && !supports.focusSvgTabindexAttribute) {
    return false;
  }

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  if (supports.focusInvalidTabindex) {
    return true;
  }

  // an element matches the tabindex selector even if its value is invalid
  var tabindex = element.getAttribute(hasTabindex ? 'tabindex' : 'tabIndex');
  // IE11 parses tabindex="" as the value "-32768"
  // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965
  if (tabindex === '-32768') {
    return false;
  }

  return Boolean(tabindex && validIntegerPattern.test(tabindex));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element's tabindex attribute has a valid value

var supports = void 0;

// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers
// NOTE: all browsers agree to allow trailing spaces as well
var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;

module.exports = exports['default'];
//# sourceMappingURL=valid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/visible.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/visible.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/rendering.html#being-rendered
// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage

// determine if an element is rendered
// NOTE: that does not mean an element is visible in the viewport, see util/visible-area

var notRenderedElementsPattern = /^(area)$/;

function computedStyle(element, property) {
  return window.getComputedStyle(element, null).getPropertyValue(property);
}

function notDisplayed(_path) {
  return _path.some(function (element) {
    // display:none is not visible (optimized away at layout)
    return computedStyle(element, 'display') === 'none';
  });
}

function notVisible(_path) {
  // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114
  // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible
  // NOTE: visibility can be ["", "visible", "hidden", "collapse"]
  var hidden = (0, _arrayFindIndex2.default)(_path, function (element) {
    var visibility = computedStyle(element, 'visibility');
    return visibility === 'hidden' || visibility === 'collapse';
  });

  if (hidden === -1) {
    // there is no hidden element
    return false;
  }

  var visible = (0, _arrayFindIndex2.default)(_path, function (element) {
    return computedStyle(element, 'visibility') === 'visible';
  });

  if (visible === -1) {
    // there is no visible element (but a hidden element)
    return true;
  }

  if (hidden < visible) {
    // there is a hidden element and it's closer than the first visible element
    return true;
  }

  // there may be a hidden element, but the closest element is visible
  return false;
}

function collapsedParent(_path) {
  var offset = 1;
  if (_path[0].nodeName.toLowerCase() === 'summary') {
    offset = 2;
  }

  return _path.slice(offset).some(function (element) {
    // "content children" of a closed details element are not visible
    return element.nodeName.toLowerCase() === 'details' && element.open === false;
  });
}

function isVisibleRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    notRendered: false,
    cssDisplay: false,
    cssVisibility: false,
    detailsElement: false,
    browsingContext: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/visible',
    resolveDocument: true,
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
    return true;
  }

  var _path = (0, _parents2.default)({ context: element });

  // in Internet Explorer <audio> has a default display: none, where others have display: inline
  // but IE allows focusing <audio style="display:none">, but not <div display:none><audio>
  // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable
  var isAudioWithoutControls = nodeName === 'audio' && !element.hasAttribute('controls');
  if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
    return false;
  }

  if (!except.cssVisibility && notVisible(_path)) {
    return false;
  }

  if (!except.detailsElement && collapsedParent(_path)) {
    return false;
  }

  if (!except.browsingContext) {
    // elements within a browsing context are affected by the
    // browsing context host element's visibility and tabindex
    var frameElement = (0, _getFrameElement2.default)(element);
    var _isVisible = isVisibleRules.except(except);
    if (frameElement && !_isVisible(frameElement)) {
      return false;
    }
  }

  return true;
}

// bind exceptions to an iterator callback
isVisibleRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isVisible = function isVisible(context) {
    return isVisibleRules({
      context: context,
      except: except
    });
  };

  isVisible.rules = isVisibleRules;
  return isVisible;
};

// provide isVisible(context) as default iterator callback
var isVisible = isVisibleRules.except({});
exports.default = isVisible;
module.exports = exports['default'];
//# sourceMappingURL=visible.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/disabled.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/maintain/disabled.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/*
  Utility to make a sub-tree of the DOM inert. Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard.

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      filter = _ref2.filter;

  var service = new InertSubtree({ context: context, filter: filter });
  return { disengage: service.disengage };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _focusable = __webpack_require__(/*! ../query/focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _disabled = __webpack_require__(/*! ../element/disabled */ "./node_modules/ally.js/element/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _shadowMutations = __webpack_require__(/*! ../observe/shadow-mutations */ "./node_modules/ally.js/observe/shadow-mutations.js");

var _shadowMutations2 = _interopRequireDefault(_shadowMutations);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function makeElementInert(element) {
  return (0, _disabled2.default)(element, true);
}

function undoElementInert(element) {
  return (0, _disabled2.default)(element, false);
}

var observerConfig = {
  attributes: true,
  childList: true,
  subtree: true,
  attributeFilter: ['tabindex', 'disabled', 'data-ally-disabled']
};

var InertSubtree = function () {
  function InertSubtree() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        filter = _ref.filter;

    _classCallCheck(this, InertSubtree);

    this._context = (0, _nodeArray2.default)(context || document.documentElement)[0];
    this._filter = (0, _nodeArray2.default)(filter);
    this._inertElementCache = [];

    this.disengage = this.disengage.bind(this);
    this.handleMutation = this.handleMutation.bind(this);
    this.renderInert = this.renderInert.bind(this);
    this.filterElements = this.filterElements.bind(this);
    this.filterParentElements = this.filterParentElements.bind(this);

    var focusable = (0, _focusable2.default)({
      context: this._context,
      includeContext: true,
      strategy: 'all'
    });

    this.renderInert(focusable);

    this.shadowObserver = (0, _shadowMutations2.default)({
      context: this._context,
      config: observerConfig,
      callback: function callback(mutations) {
        return mutations.forEach(_this.handleMutation);
      }
    });
  }

  _createClass(InertSubtree, [{
    key: 'disengage',
    value: function disengage() {
      if (!this._context) {
        return;
      }

      undoElementInert(this._context);
      this._inertElementCache.forEach(function (element) {
        return undoElementInert(element);
      });

      this._inertElementCache = null;
      this._filter = null;
      this._context = null;
      this.shadowObserver && this.shadowObserver.disengage();
      this.shadowObserver = null;
    }
  }, {
    key: 'listQueryFocusable',
    value: function listQueryFocusable(list) {
      return list
      // find all focusable elements within the given contexts
      .map(function (element) {
        return (0, _focusable2.default)({ context: element, includeContext: true, strategy: 'all' });
      })
      // flatten nested arrays
      .reduce(function (previous, current) {
        return previous.concat(current);
      }, []);
    }
  }, {
    key: 'renderInert',
    value: function renderInert(elements) {
      var _this2 = this;

      var makeInert = function makeInert(element) {
        _this2._inertElementCache.push(element);
        makeElementInert(element);
      };

      elements.filter(this.filterElements).filter(this.filterParentElements)
      // ignore elements that already are disabled
      // so we don't enable them on disengage()
      .filter(function (element) {
        return !(0, _disabled2.default)(element);
      }).forEach(makeInert);
    }
  }, {
    key: 'filterElements',
    value: function filterElements(element) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: element, includeSelf: true });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'filterParentElements',
    value: function filterParentElements(element) {
      // ignore ancestors of the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ parent: element });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'handleMutation',
    value: function handleMutation(mutation) {
      if (mutation.type === 'childList') {
        var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
          return element.nodeType === Node.ELEMENT_NODE;
        });
        if (!addedElements.length) {
          return;
        }

        var addedFocusableElements = this.listQueryFocusable(addedElements);
        this.renderInert(addedFocusableElements);
      } else if (mutation.type === 'attributes') {
        this.renderInert([mutation.target]);
      }
    }
  }]);

  return InertSubtree;
}();

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/tab-focus.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/maintain/tab-focus.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  if (!context) {
    context = document.documentElement;
  }

  // Make sure the supports tests are run before intercepting the Tab key,
  // or IE10 and IE11 will fail to process the first Tab key event. Not
  // limiting this warm-up to IE because it may be a problem elsewhere, too.
  (0, _tabsequence2.default)();

  return (0, _key2.default)({
    // Safari on OSX may require ALT+TAB to reach links,
    // see https://github.com/medialize/ally.js/issues/146
    '?alt+?shift+tab': function altShiftTab(event) {
      // we're completely taking over the Tab key handling
      event.preventDefault();

      var sequence = (0, _tabsequence2.default)({
        context: context
      });

      var backward = event.shiftKey;
      var first = sequence[0];
      var last = sequence[sequence.length - 1];

      // wrap around first to last, last to first
      var source = backward ? first : last;
      var target = backward ? last : first;
      if ((0, _activeElement2.default)(source)) {
        target.focus();
        return;
      }

      // find current position in tabsequence
      var currentIndex = void 0;
      var found = sequence.some(function (element, index) {
        if (!(0, _activeElement2.default)(element)) {
          return false;
        }

        currentIndex = index;
        return true;
      });

      if (!found) {
        // redirect to first as we're not in our tabsequence
        first.focus();
        return;
      }

      // shift focus to previous/next element in the sequence
      var offset = backward ? -1 : 1;
      sequence[currentIndex + offset].focus();
    }
  });
};

var _activeElement = __webpack_require__(/*! ../is/active-element */ "./node_modules/ally.js/is/active-element.js");

var _activeElement2 = _interopRequireDefault(_activeElement);

var _tabsequence = __webpack_require__(/*! ../query/tabsequence */ "./node_modules/ally.js/query/tabsequence.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _key = __webpack_require__(/*! ../when/key */ "./node_modules/ally.js/when/key.js");

var _key2 = _interopRequireDefault(_key);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tab-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/map/keycode.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/map/keycode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js
// deliberately not exposing characters like <,.-#* because they vary *wildly*
// across keyboard layouts and may cause various problems
// (e.g. "*" is "Shift +" on a German Mac keyboard)
// (e.g. "@" is "Alt L" on a German Mac keyboard)

var keycode = {
  // Element Focus
  tab: 9,

  // Navigation
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  pageUp: 33,
  'page-up': 33,
  pageDown: 34,
  'page-down': 34,
  end: 35,
  home: 36,

  // Action
  enter: 13,
  escape: 27,
  space: 32,

  // Modifier
  shift: 16,
  capsLock: 20,
  'caps-lock': 20,
  ctrl: 17,
  alt: 18,
  meta: 91,
  // in firefox: 224
  // on mac (chrome): meta-left=91, meta-right=93
  // on win (IE11): meta-left=91, meta-right=92
  pause: 19,

  // Content Manipulation
  insert: 45,
  'delete': 46,
  backspace: 8,

  // the same logical key may be identified through different keyCodes
  _alias: {
    91: [92, 93, 224]
  }
};

// Function keys (112 - 137)
// NOTE: not every keyboard knows F13+
for (var n = 1; n < 26; n++) {
  keycode['f' + n] = n + 111;
}

// Number keys (48-57, numpad 96-105)
// NOTE: not every keyboard knows num-0+
for (var _n = 0; _n < 10; _n++) {
  var code = _n + 48;
  var numCode = _n + 96;
  keycode[_n] = code;
  keycode['num-' + _n] = numCode;
  keycode._alias[code] = [numCode];
}

// Latin characters (65 - 90)
for (var _n2 = 0; _n2 < 26; _n2++) {
  var _code = _n2 + 65;
  var name = String.fromCharCode(_code).toLowerCase();
  keycode[name] = _code;
}

exports.default = keycode;
module.exports = exports['default'];
//# sourceMappingURL=keycode.js.map

/***/ }),

/***/ "./node_modules/ally.js/observe/shadow-mutations.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/observe/shadow-mutations.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      callback = _ref2.callback,
      config = _ref2.config;

  if (typeof callback !== 'function') {
    throw new TypeError('observe/shadow-mutations requires options.callback to be a function');
  }

  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new TypeError('observe/shadow-mutations requires options.config to be an object');
  }

  if (!window.MutationObserver) {
    // not supporting IE10 via Mutation Events, because they're too expensive
    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events
    return {
      disengage: function disengage() {}
    };
  }

  var element = (0, _contextToElement2.default)({
    label: 'observe/shadow-mutations',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var service = new ShadowMutationObserver({
    context: element,
    callback: callback,
    config: config
  });

  return {
    disengage: service.disengage
  };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _shadowHosts = __webpack_require__(/*! ../query/shadow-hosts */ "./node_modules/ally.js/query/shadow-hosts.js");

var _shadowHosts2 = _interopRequireDefault(_shadowHosts);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shadowObserverConfig = {
  childList: true,
  subtree: true
};

var ShadowMutationObserver = function () {
  function ShadowMutationObserver() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        callback = _ref.callback,
        config = _ref.config;

    _classCallCheck(this, ShadowMutationObserver);

    this.config = config;

    this.disengage = this.disengage.bind(this);

    this.clientObserver = new MutationObserver(callback);
    this.hostObserver = new MutationObserver(function (mutations) {
      return mutations.forEach(_this.handleHostMutation, _this);
    });

    this.observeContext(context);
    this.observeShadowHosts(context);
  }

  _createClass(ShadowMutationObserver, [{
    key: 'disengage',
    value: function disengage() {
      this.clientObserver && this.clientObserver.disconnect();
      this.clientObserver = null;
      this.hostObserver && this.hostObserver.disconnect();
      this.hostObserver = null;
    }
  }, {
    key: 'observeShadowHosts',
    value: function observeShadowHosts(context) {
      var _this2 = this;

      var hosts = (0, _shadowHosts2.default)({
        context: context
      });

      hosts.forEach(function (element) {
        return _this2.observeContext(element.shadowRoot);
      });
    }
  }, {
    key: 'observeContext',
    value: function observeContext(context) {
      this.clientObserver.observe(context, this.config);
      this.hostObserver.observe(context, shadowObserverConfig);
    }
  }, {
    key: 'handleHostMutation',
    value: function handleHostMutation(mutation) {
      if (mutation.type !== 'childList') {
        return;
      }

      var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
        return element.nodeType === Node.ELEMENT_NODE;
      });
      addedElements.forEach(this.observeShadowHosts, this);
    }
  }]);

  return ShadowMutationObserver;
}();

module.exports = exports['default'];
//# sourceMappingURL=shadow-mutations.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === undefined ? 'quick' : _ref$strategy;

  var element = (0, _contextToElement2.default)({
    label: 'query/focusable',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var options = {
    context: element,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  };

  if (strategy === 'quick') {
    return (0, _focusable4.default)(options);
  } else if (strategy === 'strict' || strategy === 'all') {
    return (0, _focusable2.default)(options);
  }

  throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _focusable = __webpack_require__(/*! ./focusable.strict */ "./node_modules/ally.js/query/focusable.strict.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ./focusable.quick */ "./node_modules/ally.js/query/focusable.quick.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.quick.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.quick.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableQuick;

var _focusable = __webpack_require__(/*! ../selector/focusable */ "./node_modules/ally.js/selector/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function queryFocusableQuick() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable;

  var _selector = (0, _focusable2.default)();
  var elements = context.querySelectorAll(_selector);
  // the selector potentially matches more than really is focusable

  var _isFocusable = _focusable4.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var result = [].filter.call(elements, _isFocusable);

  // add context if requested and focusable
  if (includeContext && _isFocusable(context)) {
    result.unshift(context);
  }

  return result;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.quick.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.strict.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.strict.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableStrict;

var _focusable = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusRelevant = __webpack_require__(/*! ../is/focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFilter(condition) {
  // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
  var filter = function filter(node) {
    if (node.shadowRoot) {
      // return ShadowRoot elements regardless of them being focusable,
      // so they can be walked recursively later
      return NodeFilter.FILTER_ACCEPT;
    }

    if (condition(node)) {
      // finds elements that could have been found by document.querySelectorAll()
      return NodeFilter.FILTER_ACCEPT;
    }

    return NodeFilter.FILTER_SKIP;
  };
  // IE requires a function, Browsers require {acceptNode: function}
  // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
  filter.acceptNode = filter;
  return filter;
}
// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

var PossiblyFocusableFilter = createFilter(_focusRelevant2.default);

function queryFocusableStrict() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!context) {
    context = document.documentElement;
  }

  var _isFocusable = _focusable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  context,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  strategy === 'all' ? PossiblyFocusableFilter : createFilter(_isFocusable),
  // deprecated, but IE requires it
  false);

  var list = [];

  while (walker.nextNode()) {
    if (walker.currentNode.shadowRoot) {
      if (_isFocusable(walker.currentNode)) {
        list.push(walker.currentNode);
      }

      list = list.concat(queryFocusableStrict({
        context: walker.currentNode.shadowRoot,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
      }));
    } else {
      list.push(walker.currentNode);
    }
  }

  // add context if requested and focusable
  if (includeContext) {
    if (strategy === 'all') {
      if ((0, _focusRelevant2.default)(context)) {
        list.unshift(context);
      }
    } else if (_isFocusable(context)) {
      list.unshift(context);
    }
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.strict.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/shadow-hosts.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/query/shadow-hosts.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryShadowHosts;

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
var filter = function filter(node) {
  if (node.shadowRoot) {
    return NodeFilter.FILTER_ACCEPT;
  }

  return NodeFilter.FILTER_SKIP;
};
// IE requires a function, Browsers require {acceptNode: function}
// see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
filter.acceptNode = filter;

function queryShadowHosts() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'query/shadow-hosts',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  element,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  filter,
  // deprecated, but IE requires it
  false);

  var list = [];

  if (element.shadowRoot) {
    // TreeWalker does not run the filter on the context element
    list.push(element);
    list = list.concat(queryShadowHosts({
      context: element.shadowRoot
    }));
  }

  while (walker.nextNode()) {
    list.push(walker.currentNode);
    list = list.concat(queryShadowHosts({
      context: walker.currentNode.shadowRoot
    }));
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=shadow-hosts.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabbable.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/query/tabbable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  var _isTabbable = _tabbable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  return (0, _focusable2.default)({
    context: context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  }).filter(_isTabbable);
};

var _focusable = __webpack_require__(/*! ./focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _tabbable = __webpack_require__(/*! ../is/tabbable */ "./node_modules/ally.js/is/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _context = (0, _nodeArray2.default)(context)[0] || document.documentElement;
  var elements = (0, _tabbable2.default)({
    context: _context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  });

  if (document.body.createShadowRoot && _platform2.default.is.BLINK) {
    // sort tabindex localized to shadow dom
    // see https://github.com/medialize/ally.js/issues/6
    elements = (0, _tabsequence4.default)(elements, _context, sortElements);
  } else {
    elements = sortElements(elements, _context);
  }

  if (includeContext) {
    // if we include the context itself, it has to be the first
    // element of the sequence
    elements = moveContextToBeginning(elements, _context);
  }

  return elements;
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _tabsequence = __webpack_require__(/*! ./tabsequence.sort-area */ "./node_modules/ally.js/query/tabsequence.sort-area.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _tabsequence3 = __webpack_require__(/*! ./tabsequence.sort-shadowed */ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js");

var _tabsequence4 = _interopRequireDefault(_tabsequence3);

var _tabsequence5 = __webpack_require__(/*! ./tabsequence.sort-tabindex */ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js");

var _tabsequence6 = _interopRequireDefault(_tabsequence5);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function moveContextToBeginning(elements, context) {
  var pos = elements.indexOf(context);
  if (pos > 0) {
    var tmp = elements.splice(pos, 1);
    return tmp.concat(elements);
  }

  return elements;
}

function sortElements(elements, _context) {
  if (supports.tabsequenceAreaAtImgPosition) {
    // Some browsers sort <area> in DOM order, some place the <area>s
    // where the <img> referecing them would've been in DOM order.
    // https://github.com/medialize/ally.js/issues/5
    elements = (0, _tabsequence2.default)(elements, _context);
  }

  elements = (0, _tabsequence6.default)(elements);
  return elements;
}

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-area.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// move <area> elements to the location of the <img> elements that reference them

exports.default = function (elements, context) {
  // images - unless they are focusable themselves, likely not
  // part of the elements list, so we'll have to find them and
  // sort them into the elements list manually
  var usemaps = context.querySelectorAll('img[usemap]');
  var maps = new Maps(context);

  // remove all <area> elements from the elements list,
  // but put them the map for later retrieval
  var _elements = maps.extractAreasFromList(elements);

  if (!usemaps.length) {
    // the context does not contain any <area>s so no need
    // to replace anything, just remove any maps
    return _elements;
  }

  return (0, _mergeDomOrder2.default)({
    list: _elements,
    elements: usemaps,
    resolveElement: function resolveElement(image) {
      var name = image.getAttribute('usemap').slice(1);
      return maps.getAreasFor(name);
    }
  });
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Maps = function () {
  function Maps(context) {
    _classCallCheck(this, Maps);

    this._document = (0, _getDocument2.default)(context);
    this.maps = {};
  }

  _createClass(Maps, [{
    key: 'getAreasFor',
    value: function getAreasFor(name) {
      if (!this.maps[name]) {
        // the map is not defined within the context, so we
        // have to go find it elsewhere in the document
        this.addMapByName(name);
      }

      return this.maps[name];
    }
  }, {
    key: 'addMapByName',
    value: function addMapByName(name) {
      var map = (0, _imageMap.getMapByName)(name, this._document);
      if (!map) {
        // if there is no map, the img[usemap] wasn't doing anything anyway
        return;
      }

      this.maps[map.name] = (0, _tabbable2.default)({ context: map });
    }
  }, {
    key: 'extractAreasFromList',
    value: function extractAreasFromList(elements) {
      // remove all <area> elements from the elements list,
      // but put them the map for later retrieval
      return elements.filter(function (element) {
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName !== 'area') {
          return true;
        }

        var map = element.parentNode;
        if (!this.maps[map.name]) {
          this.maps[map.name] = [];
        }

        this.maps[map.name].push(element);
        return false;
      }, this);
    }
  }]);

  return Maps;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-shadowed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (elements, context, sortElements) {
  var shadows = new Shadows(context, sortElements);
  var _elements = shadows.extractElements(elements);

  if (_elements.length === elements.length) {
    // no shadowed content found, no need to continue
    return sortElements(elements);
  }

  return shadows.sort(_elements);
};

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Shadows = function () {
  function Shadows(context, sortElements) {
    _classCallCheck(this, Shadows);

    // document context we're working with
    this.context = context;
    // callback that sorts an array of elements
    this.sortElements = sortElements;
    // reference to create unique IDs for each ShadowHost
    this.hostCounter = 1;
    // reference map for child-ShadowHosts of a ShadowHost
    this.inHost = {};
    // reference map for child-ShadowHost of the document
    this.inDocument = [];
    // reference map for ShadowHosts
    this.hosts = {};
    // reference map for tabbable elements of a ShadowHost
    this.elements = {};
  }

  // remember which hosts we have to sort within later


  _createClass(Shadows, [{
    key: '_registerHost',
    value: function _registerHost(host) {
      if (host._sortingId) {
        return;
      }

      // make the ShadowHost identifiable (see cleanup() for undo)
      host._sortingId = 'shadow-' + this.hostCounter++;
      this.hosts[host._sortingId] = host;

      // hosts may contain other hosts
      var parentHost = (0, _shadowHost2.default)({ context: host });
      if (parentHost) {
        this._registerHost(parentHost);
        this._registerHostParent(host, parentHost);
      } else {
        this.inDocument.push(host);
      }
    }

    // remember which host is the child of which other host

  }, {
    key: '_registerHostParent',
    value: function _registerHostParent(host, parent) {
      if (!this.inHost[parent._sortingId]) {
        this.inHost[parent._sortingId] = [];
      }

      this.inHost[parent._sortingId].push(host);
    }

    // remember which elements a host contains

  }, {
    key: '_registerElement',
    value: function _registerElement(element, host) {
      if (!this.elements[host._sortingId]) {
        this.elements[host._sortingId] = [];
      }

      this.elements[host._sortingId].push(element);
    }

    // remove shadowed elements from the sequence and register
    // the ShadowHosts they belong to so we know what to sort
    // later on

  }, {
    key: 'extractElements',
    value: function extractElements(elements) {
      return elements.filter(function (element) {
        var host = (0, _shadowHost2.default)({ context: element });
        if (!host) {
          return true;
        }

        this._registerHost(host);
        this._registerElement(element, host);
        return false;
      }, this);
    }

    // inject hosts into the sequence, sort everything,
    // and recoursively replace hosts by its descendants

  }, {
    key: 'sort',
    value: function sort(elements) {
      var _elements = this._injectHosts(elements);
      _elements = this._replaceHosts(_elements);
      this._cleanup();
      return _elements;
    }

    // merge ShadowHosts into the element lists of other ShadowHosts
    // or the document, then sort the individual lists

  }, {
    key: '_injectHosts',
    value: function _injectHosts(elements) {
      Object.keys(this.hosts).forEach(function (_sortingId) {
        var _list = this.elements[_sortingId];
        var _elements = this.inHost[_sortingId];
        var _context = this.hosts[_sortingId].shadowRoot;
        this.elements[_sortingId] = this._merge(_list, _elements, _context);
      }, this);

      return this._merge(elements, this.inDocument, this.context);
    }
  }, {
    key: '_merge',
    value: function _merge(list, elements, context) {
      var merged = (0, _mergeDomOrder2.default)({
        list: list,
        elements: elements
      });

      return this.sortElements(merged, context);
    }
  }, {
    key: '_replaceHosts',
    value: function _replaceHosts(elements) {
      return (0, _mergeDomOrder2.default)({
        list: elements,
        elements: this.inDocument,
        resolveElement: this._resolveHostElement.bind(this)
      });
    }
  }, {
    key: '_resolveHostElement',
    value: function _resolveHostElement(host) {
      var merged = (0, _mergeDomOrder2.default)({
        list: this.elements[host._sortingId],
        elements: this.inHost[host._sortingId],
        resolveElement: this._resolveHostElement.bind(this)
      });

      var _tabindex = (0, _tabindexValue2.default)(host);
      if (_tabindex !== null && _tabindex > -1) {
        return [host].concat(merged);
      }

      return merged;
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      // remove those identifers we put on the ShadowHost to avoid using Map()
      Object.keys(this.hosts).forEach(function (key) {
        delete this.hosts[key]._sortingId;
      }, this);
    }
  }]);

  return Shadows;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-shadowed.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex
  // elements with tabIndex "0" (including tabbableElements without tabIndex) should be navigated in the order they appear.
  // elements with a positive tabIndex:
  //   Elements that have identical tabIndexes should be navigated in the order they appear.
  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.

  // NOTE: sort implementation may be unstable and thus mess up DOM order,
  // that's why we build a map that's being sorted instead. If we were able to rely
  // on a stable sorting algorithm, sortTabindex() could be as simple as
  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });
  // at this time Chrome does not use a stable sorting algorithm
  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability

  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets
  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

  var map = {};
  var indexes = [];
  var normal = elements.filter(function (element) {
    // in Trident and Gecko SVGElement does not know about the tabIndex property
    var tabIndex = element.tabIndex;
    if (tabIndex === undefined) {
      tabIndex = (0, _tabindexValue2.default)(element);
    }

    // extract elements that don't need sorting
    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
      return true;
    }

    if (!map[tabIndex]) {
      // create sortable bucket for dom-order-preservation of elements with the same tabIndex
      map[tabIndex] = [];
      // maintain a list of unique tabIndexes
      indexes.push(tabIndex);
    }

    // sort element into the proper bucket
    map[tabIndex].push(element);
    // element moved to sorting map, so not "normal" anymore
    return false;
  });

  // sort the tabindex ascending,
  // then resolve them to their appropriate buckets,
  // then flatten the array of arrays to an array
  var _elements = indexes.sort().map(function (tabIndex) {
    return map[tabIndex];
  }).reduceRight(function (previous, current) {
    return current.concat(previous);
  }, normal);

  return _elements;
};

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/selector/focusable.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/selector/focusable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  if (typeof selector === 'string') {
    return selector;
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  selector = ''
  // IE11 supports.can focus <table> and <td>
  + (supports.focusTable ? 'table, td,' : '')
  // IE11 supports.can focus <fieldset>
  + (supports.focusFieldset ? 'fieldset,' : '')
  // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124
  // svg a[*|href] does not match in IE9, but since we're filtering
  // through is/focusable we can include all <a> from SVG
  + 'svg a,'
  // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable
  // navigational elements
  + 'a[href],'
  // validity determined by is/valid-area.js
  + 'area[href],'
  // validity determined by is/disabled.js
  + 'input, select, textarea, button,'
  // browsing context containers
  + 'iframe, object, embed,'
  // interactive content
  + 'keygen,' + (supports.focusAudioWithoutControls ? 'audio,' : 'audio[controls],') + (supports.focusVideoWithoutControls ? 'video,' : 'video[controls],') + (supports.focusSummary ? 'summary,' : '')
  // validity determined by is/valid-tabindex.js
  + '[tabindex],'
  // editing hosts
  + '[contenteditable]';

  // where ShadowDOM is supported, we also want the shadowed focusable elements (via ">>>" or "/deep/")
  selector = (0, _selectInShadows2.default)(selector);

  return selector;
};

var _selectInShadows = __webpack_require__(/*! ../util/select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: this selector MUST *never* be used directly,
// always go through query/focusable or is/focusable.js
// there are too many edge cases that they could be covered in
// a simple CSS selector…

var supports = void 0;

var selector = void 0;

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var combinator = void 0;

  // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572
  // https://code.google.com/p/chromium/issues/detail?id=446051
  try {
    document.querySelector('html >>> :first-child');
    combinator = '>>>';
  } catch (noArrowArrowArrow) {
    try {
      // old syntax supported at least up to Chrome 41
      // https://code.google.com/p/chromium/issues/detail?id=446051
      document.querySelector('html /deep/ :first-child');
      combinator = '/deep/';
    } catch (noDeep) {
      combinator = '';
    }
  }

  return combinator;
};

module.exports = exports['default'];
//# sourceMappingURL=css-shadow-piercing-deep-combinator.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/detect-focus.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/supports/detect-focus.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (tests) {
  var data = before();

  var results = {};
  Object.keys(tests).map(function (key) {
    results[key] = test(data, tests[key]);
  });

  after(data);
  return results;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function before() {
  var data = {
    // remember what had focus to restore after test
    activeElement: document.activeElement,
    // remember scroll positions to restore after test
    windowScrollTop: window.scrollTop,
    windowScrollLeft: window.scrollLeft,
    bodyScrollTop: document.body.scrollTop,
    bodyScrollLeft: document.body.scrollLeft
  };

  // wrap tests in an element hidden from screen readers to prevent them
  // from announcing focus, which can be quite irritating to the user
  var iframe = document.createElement('iframe');
  iframe.setAttribute('style', 'position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;');
  iframe.setAttribute('aria-live', 'off');
  iframe.setAttribute('aria-busy', 'true');
  iframe.setAttribute('aria-hidden', 'true');
  document.body.appendChild(iframe);

  var _window = iframe.contentWindow;
  var _document = _window.document;

  _document.open();
  _document.close();
  var wrapper = _document.createElement('div');
  _document.body.appendChild(wrapper);

  data.iframe = iframe;
  data.wrapper = wrapper;
  data.window = _window;
  data.document = _document;

  return data;
}

// options.element:
//  {string} element name
//  {function} callback(wrapper, document) to generate an element
// options.mutate: (optional)
//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.
//             Can return DOMElement to define focus target (default: element)
// options.validate: (optional)
//  {function} callback(element, focusTarget, document) to manipulate test-result
function test(data, options) {
  // make sure we operate on a clean slate
  data.wrapper.innerHTML = '';
  // create dummy element to test focusability of
  var element = typeof options.element === 'string' ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);
  // allow callback to further specify dummy element
  // and optionally define element to focus
  var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
  if (!focus && focus !== false) {
    focus = element;
  }
  // element needs to be part of the DOM to be focusable
  !element.parentNode && data.wrapper.appendChild(element);
  // test if the element with invalid tabindex can be focused
  focus && focus.focus && focus.focus();
  // validate test's result
  return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;
}

function after(data) {
  // restore focus to what it was before test and cleanup
  if (data.activeElement === document.body) {
    document.activeElement && document.activeElement.blur && document.activeElement.blur();
    if (_platform2.default.is.IE10) {
      // IE10 does not redirect focus to <body> when the activeElement is removed
      document.body.focus();
    }
  } else {
    data.activeElement && data.activeElement.focus && data.activeElement.focus();
  }

  document.body.removeChild(data.iframe);

  // restore scroll position
  window.scrollTop = data.windowScrollTop;
  window.scrollLeft = data.windowScrollLeft;
  document.body.scrollTop = data.bodyScrollTop;
  document.body.scrollLeft = data.bodyScrollLeft;
}

module.exports = exports['default'];
//# sourceMappingURL=detect-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-img-tabindex.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-img-tabindex.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-img-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-tabindex.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-tabindex.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" alt="" src="' + _gif2.default + '">';

    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    var focus = element.querySelector('area');
    focus.focus();
    return _document.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-without-href.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-without-href.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-area-href-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-area-href-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    return _document.activeElement === focusTarget;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-without-href.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-audio-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-audio-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp3 */ "./node_modules/ally.js/supports/media/mp3.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'can-focus-audio-without-controls',
  element: 'audio',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-audio-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-broken-image-map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-broken-image-map.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif.invalid */ "./node_modules/ally.js/supports/media/gif.invalid.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#broken-image-map-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-broken-image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Children of focusable elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
    return element.querySelector('span');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-children-of-focusable-flexbox.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset-disabled.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset-disabled.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree
// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
// @browser-issue Chromium https://crbug.com/453847
// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><p>content</p>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-flexbox-container.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-flexbox-container.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'span',
  mutate: function mutate(element) {
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-flexbox-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-form-disabled.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-form-disabled.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// form[tabindex=0][disabled] should be focusable as the
// specification doesn't know the disabled attribute on the form element
// @specification https://www.w3.org/TR/html5/forms.html#the-form-element
exports.default = {
  element: 'form',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-form-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-ismap.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-ismap.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// fixes https://github.com/medialize/ally.js/issues/20
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap
exports.default = {
  element: 'a',
  mutate: function mutate(element) {
    element.href = '#void';
    element.innerHTML = '<img ismap src="' + _gif2.default + '" alt="">';
    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-ismap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-usemap-tabindex.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' + 'src="' + _gif2.default + '">';

    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-usemap-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-hidden-iframe.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: function element(wrapper, _document) {
    var iframe = _document.createElement('iframe');

    // iframe must be part of the DOM before accessing the contentWindow is possible
    wrapper.appendChild(iframe);

    // create the iframe's default document (<html><head></head><body></body></html>)
    var iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.close();
    return iframe;
  },
  mutate: function mutate(iframe) {
    iframe.style.visibility = 'hidden';

    var iframeDocument = iframe.contentWindow.document;
    var input = iframeDocument.createElement('input');
    iframeDocument.body.appendChild(input);
    return input;
  },
  validate: function validate(iframe) {
    var iframeDocument = iframe.contentWindow.document;
    var focus = iframeDocument.querySelector('input');
    return iframeDocument.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-in-hidden-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-zero-dimension-object.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var result = !_platform2.default.is.WEBKIT;

module.exports = exports['default'];
//# sourceMappingURL=focus-in-zero-dimension-object.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-invalid-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-invalid-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 'invalid-value');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-invalid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-label-tabindex.js":
/*!***************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-label-tabindex.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'label',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
  },
  validate: function validate(element, focusTarget, _document) {
    // force layout in Chrome 49, otherwise the element won't be focusable
    /* eslint-disable no-unused-vars */
    var variableToPreventDeadCodeElimination = element.offsetHeight;
    /* eslint-enable no-unused-vars */
    element.focus();
    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-label-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg-hidden.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg-hidden.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
    element.style.visibility = 'hidden';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg-hidden.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  name: 'can-focus-object-svg',
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.
      // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string
      return true;
    }

    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-swf.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-swf.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Every Environment except IE9 considers SWF objects focusable
var result = !_platform2.default.is.IE9;

module.exports = exports['default'];
//# sourceMappingURL=focus-object-swf.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-img-usemap.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#focus-redirect-img-usemap" alt="" ' + 'src="' + _gif2.default + '">';

    // focus the <img>, not the <div>
    return element.querySelector('img');
  },
  validate: function validate(element, focusTarget, _document) {
    var target = element.querySelector('area');
    return _document.activeElement === target;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-img-usemap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-legend.js":
/*!****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-legend.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// see https://jsbin.com/nenirisage/edit?html,js,console,output

exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
    // take care of focus in validate();
    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    var focusable = element.querySelector('input[tabindex="-1"]');
    var tabbable = element.querySelector('input[tabindex="0"]');

    // Firefox requires this test to focus the <fieldset> first, while this is not necessary in
    // https://jsbin.com/nenirisage/edit?html,js,console,output
    element.focus();

    element.querySelector('legend').focus();
    return _document.activeElement === focusable && 'focusable' || _document.activeElement === tabbable && 'tabbable' || '';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-legend.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-body.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-body.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
    return element.querySelector('div');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-body.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container-without-overflow.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-summary.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-summary.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'details',
  mutate: function mutate(element) {
    element.innerHTML = '<summary>foo</summary><p>content</p>';
    return element.firstElementChild;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-summary.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js":
/*!************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-focusable-attribute.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text focusable="true">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-focusable-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
    // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can
    return element.querySelector('foreignObject') || element.getElementsByTagName('foreignObject')[0];
  },
  validate: _svg.validate

};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-foreignobject-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-in-iframe.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-in-iframe.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously
// and thereby produces a false negative test result. Thus the test is pointless
// and we resort to UA sniffing once again.
// see http://jsbin.com/vunadohoko/1/edit?js,console,output

var result = Boolean(_platform2.default.is.GECKO && typeof SVGElement !== 'undefined' && SVGElement.prototype.focus);

module.exports = exports['default'];
//# sourceMappingURL=focus-svg-in-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="-1">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-negative-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="0">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-use-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)(['<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>', '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />'].join(''));

    return element.querySelector('use');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-use-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('');
    return element.firstChild;
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '3x');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-tabindex-trailing-characters.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-table.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-table.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'table',
  mutate: function mutate(element, wrapper, _document) {
    // IE9 has a problem replacing TBODY contents with innerHTML.
    // https://stackoverflow.com/a/8097055/515124
    // element.innerHTML = '<tr><td>cell</td></tr>';
    var fragment = _document.createDocumentFragment();
    fragment.innerHTML = '<tr><td>cell</td></tr>';
    element.appendChild(fragment);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-table.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-video-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-video-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp4 */ "./node_modules/ally.js/supports/media/mp4.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'video',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-video-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/helper/svg.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/supports/helper/svg.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.focus = focus;
exports.validate = validate;

var _focus = __webpack_require__(/*! ../../element/focus.svg-foreign-object-hack */ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js");

var _focus2 = _interopRequireDefault(_focus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generate(element) {
  return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element + '</svg>';
}

function focus(element) {
  if (element.focus) {
    return;
  }

  try {
    HTMLElement.prototype.focus.call(element);
  } catch (e) {
    (0, _focus2.default)(element);
  }
}

function validate(element, focusTarget, _document) {
  focus(focusTarget);
  return _document.activeElement === focusTarget;
}
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.invalid.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.invalid.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ';
module.exports = exports['default'];
//# sourceMappingURL=gif.invalid.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
module.exports = exports['default'];
//# sourceMappingURL=gif.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp3.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:audio/mp3;base64,audio-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp3.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp4.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp4.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:video/mp4;base64,video-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp4.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb' + 'G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ' + 'zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==';
module.exports = exports['default'];
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports-cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/supports-cache.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _version = __webpack_require__(/*! ../version */ "./node_modules/ally.js/version.js");

var _version2 = _interopRequireDefault(_version);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readLocalStorage(key) {
  // allow reading from storage to retrieve previous support results
  // even while the document does not have focus
  var data = void 0;

  try {
    data = window.localStorage && window.localStorage.getItem(key);
    data = data ? JSON.parse(data) : {};
  } catch (e) {
    data = {};
  }

  return data;
} /*
      Facility to cache test results in localStorage.
  
      USAGE:
        cache.get('key');
        cache.set('key', 'value');
   */

function writeLocalStorage(key, value) {
  if (!document.hasFocus()) {
    // if the document does not have focus when tests are executed, focus() may
    // not be handled properly and events may not be dispatched immediately.
    // This can happen when a document is reloaded while Developer Tools have focus.
    try {
      window.localStorage && window.localStorage.removeItem(key);
    } catch (e) {
      // ignore
    }

    return;
  }

  try {
    window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));
  } catch (e) {
    // ignore
  }
}

var userAgent = typeof window !== 'undefined' && window.navigator.userAgent || '';
var cacheKey = 'ally-supports-cache';
var cache = readLocalStorage(cacheKey);

// update the cache if ally or the user agent changed (newer version, etc)
if (cache.userAgent !== userAgent || cache.version !== _version2.default) {
  cache = {};
}

cache.userAgent = userAgent;
cache.version = _version2.default;

exports.default = {
  get: function get() {
    return cache;
  },
  set: function set(values) {
    Object.keys(values).forEach(function (key) {
      cache[key] = values[key];
    });

    cache.time = new Date().toISOString();
    writeLocalStorage(cacheKey, cache);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=supports-cache.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/supports/supports.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (supportsCache) {
    return supportsCache;
  }

  supportsCache = _supportsCache2.default.get();
  if (!supportsCache.time) {
    _supportsCache2.default.set(executeTests());
    supportsCache = _supportsCache2.default.get();
  }

  return supportsCache;
};

var _detectFocus = __webpack_require__(/*! ./detect-focus */ "./node_modules/ally.js/supports/detect-focus.js");

var _detectFocus2 = _interopRequireDefault(_detectFocus);

var _supportsCache = __webpack_require__(/*! ./supports-cache */ "./node_modules/ally.js/supports/supports-cache.js");

var _supportsCache2 = _interopRequireDefault(_supportsCache);

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ./css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

var _focusAreaImgTabindex = __webpack_require__(/*! ./focus-area-img-tabindex */ "./node_modules/ally.js/supports/focus-area-img-tabindex.js");

var _focusAreaImgTabindex2 = _interopRequireDefault(_focusAreaImgTabindex);

var _focusAreaTabindex = __webpack_require__(/*! ./focus-area-tabindex */ "./node_modules/ally.js/supports/focus-area-tabindex.js");

var _focusAreaTabindex2 = _interopRequireDefault(_focusAreaTabindex);

var _focusAreaWithoutHref = __webpack_require__(/*! ./focus-area-without-href */ "./node_modules/ally.js/supports/focus-area-without-href.js");

var _focusAreaWithoutHref2 = _interopRequireDefault(_focusAreaWithoutHref);

var _focusAudioWithoutControls = __webpack_require__(/*! ./focus-audio-without-controls */ "./node_modules/ally.js/supports/focus-audio-without-controls.js");

var _focusAudioWithoutControls2 = _interopRequireDefault(_focusAudioWithoutControls);

var _focusBrokenImageMap = __webpack_require__(/*! ./focus-broken-image-map */ "./node_modules/ally.js/supports/focus-broken-image-map.js");

var _focusBrokenImageMap2 = _interopRequireDefault(_focusBrokenImageMap);

var _focusChildrenOfFocusableFlexbox = __webpack_require__(/*! ./focus-children-of-focusable-flexbox */ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js");

var _focusChildrenOfFocusableFlexbox2 = _interopRequireDefault(_focusChildrenOfFocusableFlexbox);

var _focusFieldsetDisabled = __webpack_require__(/*! ./focus-fieldset-disabled */ "./node_modules/ally.js/supports/focus-fieldset-disabled.js");

var _focusFieldsetDisabled2 = _interopRequireDefault(_focusFieldsetDisabled);

var _focusFieldset = __webpack_require__(/*! ./focus-fieldset */ "./node_modules/ally.js/supports/focus-fieldset.js");

var _focusFieldset2 = _interopRequireDefault(_focusFieldset);

var _focusFlexboxContainer = __webpack_require__(/*! ./focus-flexbox-container */ "./node_modules/ally.js/supports/focus-flexbox-container.js");

var _focusFlexboxContainer2 = _interopRequireDefault(_focusFlexboxContainer);

var _focusFormDisabled = __webpack_require__(/*! ./focus-form-disabled */ "./node_modules/ally.js/supports/focus-form-disabled.js");

var _focusFormDisabled2 = _interopRequireDefault(_focusFormDisabled);

var _focusImgIsmap = __webpack_require__(/*! ./focus-img-ismap */ "./node_modules/ally.js/supports/focus-img-ismap.js");

var _focusImgIsmap2 = _interopRequireDefault(_focusImgIsmap);

var _focusImgUsemapTabindex = __webpack_require__(/*! ./focus-img-usemap-tabindex */ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js");

var _focusImgUsemapTabindex2 = _interopRequireDefault(_focusImgUsemapTabindex);

var _focusInHiddenIframe = __webpack_require__(/*! ./focus-in-hidden-iframe */ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js");

var _focusInHiddenIframe2 = _interopRequireDefault(_focusInHiddenIframe);

var _focusInZeroDimensionObject = __webpack_require__(/*! ./focus-in-zero-dimension-object */ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js");

var _focusInZeroDimensionObject2 = _interopRequireDefault(_focusInZeroDimensionObject);

var _focusInvalidTabindex = __webpack_require__(/*! ./focus-invalid-tabindex */ "./node_modules/ally.js/supports/focus-invalid-tabindex.js");

var _focusInvalidTabindex2 = _interopRequireDefault(_focusInvalidTabindex);

var _focusLabelTabindex = __webpack_require__(/*! ./focus-label-tabindex */ "./node_modules/ally.js/supports/focus-label-tabindex.js");

var _focusLabelTabindex2 = _interopRequireDefault(_focusLabelTabindex);

var _focusObjectSvgHidden = __webpack_require__(/*! ./focus-object-svg-hidden */ "./node_modules/ally.js/supports/focus-object-svg-hidden.js");

var _focusObjectSvgHidden2 = _interopRequireDefault(_focusObjectSvgHidden);

var _focusObjectSvg = __webpack_require__(/*! ./focus-object-svg */ "./node_modules/ally.js/supports/focus-object-svg.js");

var _focusObjectSvg2 = _interopRequireDefault(_focusObjectSvg);

var _focusObjectSwf = __webpack_require__(/*! ./focus-object-swf */ "./node_modules/ally.js/supports/focus-object-swf.js");

var _focusObjectSwf2 = _interopRequireDefault(_focusObjectSwf);

var _focusRedirectImgUsemap = __webpack_require__(/*! ./focus-redirect-img-usemap */ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js");

var _focusRedirectImgUsemap2 = _interopRequireDefault(_focusRedirectImgUsemap);

var _focusRedirectLegend = __webpack_require__(/*! ./focus-redirect-legend */ "./node_modules/ally.js/supports/focus-redirect-legend.js");

var _focusRedirectLegend2 = _interopRequireDefault(_focusRedirectLegend);

var _focusScrollBody = __webpack_require__(/*! ./focus-scroll-body */ "./node_modules/ally.js/supports/focus-scroll-body.js");

var _focusScrollBody2 = _interopRequireDefault(_focusScrollBody);

var _focusScrollContainerWithoutOverflow = __webpack_require__(/*! ./focus-scroll-container-without-overflow */ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js");

var _focusScrollContainerWithoutOverflow2 = _interopRequireDefault(_focusScrollContainerWithoutOverflow);

var _focusScrollContainer = __webpack_require__(/*! ./focus-scroll-container */ "./node_modules/ally.js/supports/focus-scroll-container.js");

var _focusScrollContainer2 = _interopRequireDefault(_focusScrollContainer);

var _focusSummary = __webpack_require__(/*! ./focus-summary */ "./node_modules/ally.js/supports/focus-summary.js");

var _focusSummary2 = _interopRequireDefault(_focusSummary);

var _focusSvgFocusableAttribute = __webpack_require__(/*! ./focus-svg-focusable-attribute */ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js");

var _focusSvgFocusableAttribute2 = _interopRequireDefault(_focusSvgFocusableAttribute);

var _focusSvgTabindexAttribute = __webpack_require__(/*! ./focus-svg-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js");

var _focusSvgTabindexAttribute2 = _interopRequireDefault(_focusSvgTabindexAttribute);

var _focusSvgNegativeTabindexAttribute = __webpack_require__(/*! ./focus-svg-negative-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js");

var _focusSvgNegativeTabindexAttribute2 = _interopRequireDefault(_focusSvgNegativeTabindexAttribute);

var _focusSvgUseTabindex = __webpack_require__(/*! ./focus-svg-use-tabindex */ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js");

var _focusSvgUseTabindex2 = _interopRequireDefault(_focusSvgUseTabindex);

var _focusSvgForeignobjectTabindex = __webpack_require__(/*! ./focus-svg-foreignobject-tabindex */ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js");

var _focusSvgForeignobjectTabindex2 = _interopRequireDefault(_focusSvgForeignobjectTabindex);

var _focusSvgInIframe = __webpack_require__(/*! ./focus-svg-in-iframe */ "./node_modules/ally.js/supports/focus-svg-in-iframe.js");

var _focusSvgInIframe2 = _interopRequireDefault(_focusSvgInIframe);

var _focusSvg = __webpack_require__(/*! ./focus-svg */ "./node_modules/ally.js/supports/focus-svg.js");

var _focusSvg2 = _interopRequireDefault(_focusSvg);

var _focusTabindexTrailingCharacters = __webpack_require__(/*! ./focus-tabindex-trailing-characters */ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js");

var _focusTabindexTrailingCharacters2 = _interopRequireDefault(_focusTabindexTrailingCharacters);

var _focusTable = __webpack_require__(/*! ./focus-table */ "./node_modules/ally.js/supports/focus-table.js");

var _focusTable2 = _interopRequireDefault(_focusTable);

var _focusVideoWithoutControls = __webpack_require__(/*! ./focus-video-without-controls */ "./node_modules/ally.js/supports/focus-video-without-controls.js");

var _focusVideoWithoutControls2 = _interopRequireDefault(_focusVideoWithoutControls);

var _tabsequenceAreaAtImgPosition = __webpack_require__(/*! ./tabsequence-area-at-img-position */ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js");

var _tabsequenceAreaAtImgPosition2 = _interopRequireDefault(_tabsequenceAreaAtImgPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testCallbacks = {
  cssShadowPiercingDeepCombinator: _cssShadowPiercingDeepCombinator2.default,
  focusInZeroDimensionObject: _focusInZeroDimensionObject2.default,
  focusObjectSwf: _focusObjectSwf2.default,
  focusSvgInIframe: _focusSvgInIframe2.default,
  tabsequenceAreaAtImgPosition: _tabsequenceAreaAtImgPosition2.default
};

var testDescriptions = {
  focusAreaImgTabindex: _focusAreaImgTabindex2.default,
  focusAreaTabindex: _focusAreaTabindex2.default,
  focusAreaWithoutHref: _focusAreaWithoutHref2.default,
  focusAudioWithoutControls: _focusAudioWithoutControls2.default,
  focusBrokenImageMap: _focusBrokenImageMap2.default,
  focusChildrenOfFocusableFlexbox: _focusChildrenOfFocusableFlexbox2.default,
  focusFieldsetDisabled: _focusFieldsetDisabled2.default,
  focusFieldset: _focusFieldset2.default,
  focusFlexboxContainer: _focusFlexboxContainer2.default,
  focusFormDisabled: _focusFormDisabled2.default,
  focusImgIsmap: _focusImgIsmap2.default,
  focusImgUsemapTabindex: _focusImgUsemapTabindex2.default,
  focusInHiddenIframe: _focusInHiddenIframe2.default,
  focusInvalidTabindex: _focusInvalidTabindex2.default,
  focusLabelTabindex: _focusLabelTabindex2.default,
  focusObjectSvg: _focusObjectSvg2.default,
  focusObjectSvgHidden: _focusObjectSvgHidden2.default,
  focusRedirectImgUsemap: _focusRedirectImgUsemap2.default,
  focusRedirectLegend: _focusRedirectLegend2.default,
  focusScrollBody: _focusScrollBody2.default,
  focusScrollContainerWithoutOverflow: _focusScrollContainerWithoutOverflow2.default,
  focusScrollContainer: _focusScrollContainer2.default,
  focusSummary: _focusSummary2.default,
  focusSvgFocusableAttribute: _focusSvgFocusableAttribute2.default,
  focusSvgTabindexAttribute: _focusSvgTabindexAttribute2.default,
  focusSvgNegativeTabindexAttribute: _focusSvgNegativeTabindexAttribute2.default,
  focusSvgUseTabindex: _focusSvgUseTabindex2.default,
  focusSvgForeignobjectTabindex: _focusSvgForeignobjectTabindex2.default,
  focusSvg: _focusSvg2.default,
  focusTabindexTrailingCharacters: _focusTabindexTrailingCharacters2.default,
  focusTable: _focusTable2.default,
  focusVideoWithoutControls: _focusVideoWithoutControls2.default
};

function executeTests() {
  var results = (0, _detectFocus2.default)(testDescriptions);
  Object.keys(testCallbacks).forEach(function (key) {
    results[key] = testCallbacks[key]();
  });

  return results;
}

var supportsCache = null;

module.exports = exports['default'];
//# sourceMappingURL=supports.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/tabsequence-area-at-img-position.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://jsbin.com/vafaba/3/edit?html,js,console,output
var result = _platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE;

module.exports = exports['default'];
//# sourceMappingURL=tabsequence-area-at-img-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/array-find-index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/array-find-index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findIndex;
function findIndex(array, callback) {
  // attempt to use native or polyfilled Array#findIndex first
  if (array.findIndex) {
    return array.findIndex(callback);
  }

  var length = array.length;

  // shortcut if the array is empty
  if (length === 0) {
    return -1;
  }

  // otherwise loop over array
  for (var i = 0; i < length; i++) {
    if (callback(array[i], i, array)) {
      return i;
    }
  }

  return -1;
}
module.exports = exports["default"];
//# sourceMappingURL=array-find-index.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/compare-position.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/compare-position.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentComparator = getParentComparator;

// Node.compareDocumentPosition is available since IE9
// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

// callback returns true when element is contained by parent or is the parent suited for use with Array.some()
/*
  USAGE:
    var isChildOf = getParentComparator({parent: someNode});
    listOfElements.some(isChildOf)
*/

function getParentComparator() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      parent = _ref.parent,
      element = _ref.element,
      includeSelf = _ref.includeSelf;

  if (parent) {
    return function isChildOf(node) {
      return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  } else if (element) {
    return function isParentOf(node) {
      return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  }

  throw new TypeError('util/compare-position#getParentComparator required either options.parent or options.element');
}
//# sourceMappingURL=compare-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/context-to-element.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/util/context-to-element.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var context = _ref.context,
      _ref$label = _ref.label,
      label = _ref$label === undefined ? 'context-to-element' : _ref$label,
      resolveDocument = _ref.resolveDocument,
      defaultToDocument = _ref.defaultToDocument;

  var element = (0, _nodeArray2.default)(context)[0];

  if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
    element = element.documentElement;
  }

  if (!element && defaultToDocument) {
    return document.documentElement;
  }

  if (!element) {
    throw new TypeError(label + ' requires valid options.context');
  }

  if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
    throw new TypeError(label + ' requires options.context to be an Element');
  }

  return element;
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=context-to-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/element-matches.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/element-matches.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementMatches;

// Element.prototype.matches may be available at a different name
// https://developer.mozilla.org/en/docs/Web/API/Element/matches

var names = ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'];
var name = null;

function findMethodName(element) {
  names.some(function (_name) {
    if (!element[_name]) {
      return false;
    }

    name = _name;
    return true;
  });
}

function elementMatches(element, selector) {
  if (!name) {
    findMethodName(element);
  }

  return element[name](selector);
}
module.exports = exports['default'];
//# sourceMappingURL=element-matches.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-content-document.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/util/get-content-document.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  try {
    // works on <object> and <iframe>
    return node.contentDocument
    // works on <object> and <iframe>
    || node.contentWindow && node.contentWindow.document
    // works on <object> and <iframe> that contain SVG
    || node.getSVGDocument && node.getSVGDocument() || null;
  } catch (e) {
    // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'
    // also IE may throw member not found exception e.g. on <object type="image/png">
    return null;
  }
};

module.exports = exports["default"];
//# sourceMappingURL=get-content-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-document.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/util/get-document.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  if (!node) {
    return document;
  }

  if (node.nodeType === Node.DOCUMENT_NODE) {
    return node;
  }

  return node.ownerDocument || document;
};

module.exports = exports["default"];
//# sourceMappingURL=get-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-frame-element.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/get-frame-element.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFrameElement;

var _getContentDocument = __webpack_require__(/*! ./get-content-document */ "./node_modules/ally.js/util/get-content-document.js");

var _getContentDocument2 = _interopRequireDefault(_getContentDocument);

var _getWindow = __webpack_require__(/*! ./get-window */ "./node_modules/ally.js/util/get-window.js");

var _getWindow2 = _interopRequireDefault(_getWindow);

var _selectInShadows = __webpack_require__(/*! ./select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selector = void 0;

function findDocumentHostElement(_window) {
  if (!selector) {
    selector = (0, _selectInShadows2.default)('object, iframe');
  }

  if (_window._frameElement !== undefined) {
    return _window._frameElement;
  }

  _window._frameElement = null;

  var potentialHosts = _window.parent.document.querySelectorAll(selector);
  [].some.call(potentialHosts, function (element) {
    var _document = (0, _getContentDocument2.default)(element);
    if (_document !== _window.document) {
      return false;
    }

    _window._frameElement = element;
    return true;
  });

  return _window._frameElement;
}

function getFrameElement(element) {
  var _window = (0, _getWindow2.default)(element);
  if (!_window.parent || _window.parent === _window) {
    // if there is no parent browsing context,
    // we're not going to get a frameElement either way
    return null;
  }

  try {
    // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement
    // does not work within <embed> anywhere, and not within in <object> in IE
    return _window.frameElement || findDocumentHostElement(_window);
  } catch (e) {
    return null;
  }
}
module.exports = exports['default'];
//# sourceMappingURL=get-frame-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-window.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/get-window.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  var _document = (0, _getDocument2.default)(node);
  return _document.defaultView || window;
};

var _getDocument = __webpack_require__(/*! ./get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=get-window.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/image-map.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/util/image-map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapByName = getMapByName;
exports.getMapOfImage = getMapOfImage;
exports.getImageOfArea = getImageOfArea;

var _css = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");

var _css2 = _interopRequireDefault(_css);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMapByName(name, _document) {
  // apparently getElementsByName() also considers id attribute in IE & opera
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
  var map = _document.querySelector('map[name="' + (0, _css2.default)(name) + '"]');
  return map || null;
}

function getMapOfImage(element) {
  var usemap = element.getAttribute('usemap');
  if (!usemap) {
    return null;
  }

  var _document = (0, _getDocument2.default)(element);
  return getMapByName(usemap.slice(1), _document);
}

function getImageOfArea(element) {
  var map = element.parentElement;

  if (!map.name || map.nodeName.toLowerCase() !== 'map') {
    return null;
  }

  // NOTE: image maps can also be applied to <object> with image content,
  // but no browser supports this at the moment

  // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all
  // <img> and <object> referencing the <map> element, but no browser implements this
  //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element
  //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement
  // the image must be valid and loaded for the map to take effect
  var _document = (0, _getDocument2.default)(element);
  return _document.querySelector('img[usemap="#' + (0, _css2.default)(map.name) + '"]') || null;
}
//# sourceMappingURL=image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/logger.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/util/logger.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var noop = function noop() {};
var _console = {
  log: noop,
  debug: noop,
  info: noop,
  warn: noop,
  error: noop
};

exports.default = typeof console !== 'undefined' ? console : _console;
module.exports = exports['default'];
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/merge-dom-order.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/merge-dom-order.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      list = _ref.list,
      elements = _ref.elements,
      resolveElement = _ref.resolveElement;

  // operate on a copy so we don't mutate the original array
  var _list = list.slice(0);
  // make sure the elements we're injecting are provided in DOM order
  var _elements = (0, _nodeArray2.default)(elements).slice(0);
  (0, _sortDomOrder2.default)(_elements);
  // find the offsets within the target array (list) at which to inject
  // each individual element (from elements)
  var insertions = findInsertionOffsets(_list, _elements, resolveElement);
  // actually inject the elements into the target array at the identified positions
  insertElementsAtOffsets(_list, insertions);
  return _list;
};

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _nodeArray = __webpack_require__(/*! ./node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _sortDomOrder = __webpack_require__(/*! ./sort-dom-order */ "./node_modules/ally.js/util/sort-dom-order.js");

var _sortDomOrder2 = _interopRequireDefault(_sortDomOrder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFirstSuccessorOffset(list, target) {
  // find the first element that comes AFTER the target element
  return (0, _arrayFindIndex2.default)(list, function (element) {
    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;
  });
}
// sort a list of elements into another list of elements in DOM order

/*
  USAGE:
    mergeDomOrder({
      // DOM ordered array of elements to use as base of merge
      list: [],
      // unordered array of elements to merge into base list
      elements: [],
      // callback function to resolve an element
      resolveElement: function(element) {
        // return null to skip
        // return element to replace insertion
        // return [element1, element2, …] to replace insertion with multiple elements
        return element;
      },
    })
*/

function findInsertionOffsets(list, elements, resolveElement) {
  // instead of mutating the elements list directly, remember position and map
  // to inject later, when we can do this more efficiently
  var insertions = [];
  elements.forEach(function (element) {
    var replace = true;
    var offset = list.indexOf(element);

    if (offset === -1) {
      // element is not in target list
      offset = getFirstSuccessorOffset(list, element);
      replace = false;
    }

    if (offset === -1) {
      // there is no successor in the tabsequence,
      // meaning the image must be the last element
      offset = list.length;
    }

    // allow the consumer to replace the injected element
    var injections = (0, _nodeArray2.default)(resolveElement ? resolveElement(element) : element);
    if (!injections.length) {
      // we can't inject zero elements
      return;
    }

    insertions.push({
      offset: offset,
      replace: replace,
      elements: injections
    });
  });

  return insertions;
}

function insertElementsAtOffsets(list, insertions) {
  // remember the number of elements we have already injected
  // so we account for the caused index offset
  var inserted = 0;
  // make sure that we insert the elements in sequence,
  // otherwise the offset compensation won't work
  insertions.sort(function (a, b) {
    return a.offset - b.offset;
  });
  insertions.forEach(function (insertion) {
    // array.splice has an annoying function signature :(
    var remove = insertion.replace ? 1 : 0;
    var args = [insertion.offset + inserted, remove].concat(insertion.elements);
    list.splice.apply(list, args);
    inserted += insertion.elements.length - remove;
  });
}

module.exports = exports['default'];
//# sourceMappingURL=merge-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/node-array.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/node-array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (input) {
  if (!input) {
    return [];
  }

  if (Array.isArray(input)) {
    return input;
  }

  // instanceof Node - does not work with iframes
  if (input.nodeType !== undefined) {
    return [input];
  }

  if (typeof input === 'string') {
    input = document.querySelectorAll(input);
  }

  if (input.length !== undefined) {
    return [].slice.call(input, 0);
  }

  throw new TypeError('unexpected input ' + String(input));
};

module.exports = exports['default'];
// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes
// yes, to some extent this is a bad replica of jQuery's constructor function
//# sourceMappingURL=node-array.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/platform.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/util/platform.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _platform2 = __webpack_require__(/*! platform */ "./node_modules/platform/platform.js");

var _platform3 = _interopRequireDefault(_platform2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// deep clone of original platform
var platform = JSON.parse(JSON.stringify(_platform3.default));

// operating system

// sugar for https://github.com/bestiejs/platform.js
// make sure to ALWAYS reference the layout engine,
// even if it is not necessary for the condition,
// as this makes grepping for this stuff simpler

var os = platform.os.family || '';
var ANDROID = os === 'Android';
var WINDOWS = os.slice(0, 7) === 'Windows';
var OSX = os === 'OS X';
var IOS = os === 'iOS';

// layout
var BLINK = platform.layout === 'Blink';
var GECKO = platform.layout === 'Gecko';
var TRIDENT = platform.layout === 'Trident';
var EDGE = platform.layout === 'EdgeHTML';
var WEBKIT = platform.layout === 'WebKit';

// browser version (not layout engine version!)
var version = parseFloat(platform.version);
var majorVersion = Math.floor(version);
platform.majorVersion = majorVersion;

platform.is = {
  // operating system
  ANDROID: ANDROID,
  WINDOWS: WINDOWS,
  OSX: OSX,
  IOS: IOS,
  // layout
  BLINK: BLINK, // "Chrome", "Chrome Mobile", "Opera"
  GECKO: GECKO, // "Firefox"
  TRIDENT: TRIDENT, // "Internet Explorer"
  EDGE: EDGE, // "Microsoft Edge"
  WEBKIT: WEBKIT, // "Safari"
  // INTERNET EXPLORERS
  IE9: TRIDENT && majorVersion === 9,
  IE10: TRIDENT && majorVersion === 10,
  IE11: TRIDENT && majorVersion === 11
};

exports.default = platform;
module.exports = exports['default'];
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/select-in-shadows.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/select-in-shadows.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (selector) {
  if (typeof shadowPrefix !== 'string') {
    var operator = (0, _cssShadowPiercingDeepCombinator2.default)();
    if (operator) {
      shadowPrefix = ', html ' + operator + ' ';
    }
  }

  if (!shadowPrefix) {
    return selector;
  }

  return selector + shadowPrefix + selector.replace(/\s*,\s*/g, ',').split(',').join(shadowPrefix);
};

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ../supports/css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shadowPrefix = void 0;
// convert a CSS selector so that it also pierces ShadowDOM
// takes ".a, #b" and turns it into ".a, #b, html >>> .a, html >>> #b"

module.exports = exports['default'];
//# sourceMappingURL=select-in-shadows.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/sort-dom-order.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/sort-dom-order.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  return elements.sort(compareDomPosition);
};

// sorts a list of elements according to their order in the DOM

function compareDomPosition(a, b) {
  return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
}

module.exports = exports["default"];
//# sourceMappingURL=sort-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/tabindex-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/tabindex-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  if (!(0, _validTabindex2.default)(element)) {
    return null;
  }

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var attributeName = hasTabindex ? 'tabindex' : 'tabIndex';

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  var tabindex = parseInt(element.getAttribute(attributeName), 10);
  return isNaN(tabindex) ? -1 : tabindex;
};

var _validTabindex = __webpack_require__(/*! ../is/valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabindex-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute,
      temporaryValue = _ref.temporaryValue,
      saveValue = _ref.saveValue;

  var temporaryAttribute = 'data-cached-' + attribute;

  if (temporaryValue !== undefined) {
    var _value = saveValue || element.getAttribute(attribute);
    element.setAttribute(temporaryAttribute, _value || '');
    element.setAttribute(attribute, temporaryValue);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    if (_value2 === '') {
      element.removeAttribute(attribute);
    } else {
      element.setAttribute(attribute, _value2);
    }
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div some-attribute="new" data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute;

  var temporaryAttribute = 'data-cached-' + attribute;
  var temporaryAttributeValue = element.getAttribute(temporaryAttribute);

  if (temporaryAttributeValue === null) {
    var _value = element.getAttribute(attribute);
    if (_value === null) {
      // can't remove what's not there
      return;
    }

    element.setAttribute(temporaryAttribute, _value || '');
    element.removeAttribute(attribute);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    element.setAttribute(attribute, _value2);
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/version.js":
/*!*****************************************!*\
  !*** ./node_modules/ally.js/version.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// this file is overwritten by `npm run build:pre`
var version = '1.4.1';
exports.default = version;
module.exports = exports['default'];
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.binding.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/when/key.binding.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (text) {
  return text.split(/\s+/).map(function (_text) {
    var tokens = _text.split('+');
    var _modifiers = resolveModifiers(tokens.slice(0, -1));
    var _keyCodes = resolveKey(tokens.slice(-1));
    return {
      keyCodes: _keyCodes,
      modifiers: _modifiers,
      matchModifiers: matchModifiers.bind(null, _modifiers)
    };
  });
};

var _keycode = __webpack_require__(/*! ../map/keycode */ "./node_modules/ally.js/map/keycode.js");

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modifier = {
  alt: 'altKey',
  ctrl: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};
/*
  decodes a key binding token to a JavaScript structure

  returns an array of objects:
    {
      // key name translated to keyCode (possibly more than one)
      keyCodes: [<number>],
      // translated modifiers
      modifiers: {
        altKey: null,   // ignore
        ctrKey: false,  // expect not pressed
        metaKey: true,  // expect pressed
        shiftKey: true, // expect pressed
      },
      // callback that returns true if event's
      // modifier keys match the expected state
      matchModifiers: function(event){},
    }
*/

var modifierSequence = Object.keys(modifier).map(function (name) {
  return modifier[name];
});

function createExpectedModifiers(ignoreModifiers) {
  var value = ignoreModifiers ? null : false;
  return {
    altKey: value,
    ctrlKey: value,
    metaKey: value,
    shiftKey: value
  };
}

function resolveModifiers(modifiers) {
  var ignoreModifiers = modifiers.indexOf('*') !== -1;
  var expected = createExpectedModifiers(ignoreModifiers);

  modifiers.forEach(function (token) {
    if (token === '*') {
      // we've already covered the all-in operator
      return;
    }

    // we want the modifier pressed
    var value = true;
    var operator = token.slice(0, 1);
    if (operator === '?') {
      // we don't care if the modifier is pressed
      value = null;
    } else if (operator === '!') {
      // we do not want the modifier pressed
      value = false;
    }

    if (value !== true) {
      // compensate for the modifier's operator
      token = token.slice(1);
    }

    var propertyName = modifier[token];
    if (!propertyName) {
      throw new TypeError('Unknown modifier "' + token + '"');
    }

    expected[propertyName] = value;
  });

  return expected;
}

function resolveKey(key) {
  var code = _keycode2.default[key] || parseInt(key, 10);
  if (!code || typeof code !== 'number' || isNaN(code)) {
    throw new TypeError('Unknown key "' + key + '"');
  }

  return [code].concat(_keycode2.default._alias[code] || []);
}

function matchModifiers(expected, event) {
  // returns true on match
  return !modifierSequence.some(function (prop) {
    // returns true on mismatch
    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];
  });
}

module.exports = exports['default'];
//# sourceMappingURL=key.binding.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.js":
/*!******************************************!*\
  !*** ./node_modules/ally.js/when/key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var bindings = {};

  var context = (0, _nodeArray2.default)(map.context)[0] || document.documentElement;
  delete map.context;
  var filter = (0, _nodeArray2.default)(map.filter);
  delete map.filter;

  var mapKeys = Object.keys(map);
  if (!mapKeys.length) {
    throw new TypeError('when/key requires at least one option key');
  }

  var registerBinding = function registerBinding(event) {
    event.keyCodes.forEach(function (code) {
      if (!bindings[code]) {
        bindings[code] = [];
      }

      bindings[code].push(event);
    });
  };

  mapKeys.forEach(function (text) {
    if (typeof map[text] !== 'function') {
      throw new TypeError('when/key requires option["' + text + '"] to be a function');
    }

    var addCallback = function addCallback(event) {
      event.callback = map[text];
      return event;
    };

    (0, _key2.default)(text).map(addCallback).forEach(registerBinding);
  });

  var handleKeyDown = function handleKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }

    if (filter.length) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: event.target, includeSelf: true });
      if (filter.some(isParentOfElement)) {
        return;
      }
    }

    var key = event.keyCode || event.which;
    if (!bindings[key]) {
      return;
    }

    bindings[key].forEach(function (_event) {
      if (!_event.matchModifiers(event)) {
        return;
      }

      _event.callback.call(context, event, disengage);
    });
  };

  context.addEventListener('keydown', handleKeyDown, false);

  var disengage = function disengage() {
    context.removeEventListener('keydown', handleKeyDown, false);
  };

  return { disengage: disengage };
};

var _key = __webpack_require__(/*! ./key.binding */ "./node_modules/ally.js/when/key.binding.js");

var _key2 = _interopRequireDefault(_key);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933
//# sourceMappingURL=key.js.map

/***/ }),

/***/ "./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>]/gm, function (str) {
                return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                clearLine: options.clearLine,
                decoration: null,
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            self.decoration = null;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = self.decoration = null;
                } else if (num === 1) {
                    self.decoration = "bold";
                } else if (num === 2) {
                    self.decoration = "dim";
                    // Enable code 2 to get string
                } else if (num == 3) {
                    self.decoration = "italic";
                } else if (num == 4) {
                    self.decoration = "underline";
                } else if (num == 5) {
                    self.decoration = "blink";
                } else if (num === 7) {
                    self.decoration = "reverse";
                } else if (num === 8) {
                    self.decoration = "hidden";
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decoration = "strikethrough";
                } else if (num == 39) {
                    self.fg = null;
                } else if (num == 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decoration === null) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decoration = self.decoration;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            var self = this;
            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var use_classes = options.use_classes;

            var styles = [];
            var classes = [];
            var data = {};
            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.fg) {
                if (use_classes) {
                    classes.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    styles.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    classes.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    styles.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            if (jsonChunk.decoration) {
                if (use_classes) {
                    classes.push("ansi-" + jsonChunk.decoration);
                } else if (jsonChunk.decoration === "bold") {
                    styles.push("font-weight:bold");
                } else if (jsonChunk.decoration === "dim") {
                    styles.push("opacity:0.5");
                } else if (jsonChunk.decoration === "italic") {
                    styles.push("font-style:italic");
                    // underline and blink are treated bellow
                } else if (jsonChunk.decoration === "reverse") {
                    styles.push("filter:invert(100%)");
                } else if (jsonChunk.decoration === "hidden") {
                    styles.push("visibility:hidden");
                } else if (jsonChunk.decoration === "strikethrough") {
                    styles.push("text-decoration:line-through");
                } else {
                    styles.push("text-decoration:" + jsonChunk.decoration);
                }
            }

            if (use_classes) {
                return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }]);

    return Anser;
}();

;

module.exports = Anser;

/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/native-url/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/native-url/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e,t=(e=__webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js"))&&"object"==typeof e&&"default"in e?e.default:e,r=/https?|ftp|gopher|file/;function o(e){"string"==typeof e&&(e=g(e));var o=function(e,t,r){var o=e.auth,a=e.hostname,s=e.protocol||"",c=e.pathname||"",h=e.hash||"",p=e.query||"",n=!1;o=o?encodeURIComponent(o).replace(/%3A/i,":")+"@":"",e.host?n=o+e.host:a&&(n=o+(~a.indexOf(":")?"["+a+"]":a),e.port&&(n+=":"+e.port)),p&&"object"==typeof p&&(p=t.encode(p));var l=e.search||p&&"?"+p||"";return s&&":"!==s.substr(-1)&&(s+=":"),e.slashes||(!s||r.test(s))&&!1!==n?(n="//"+(n||""),c&&"/"!==c[0]&&(c="/"+c)):n||(n=""),h&&"#"!==h[0]&&(h="#"+h),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:n,pathname:c=c.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:h}}(e,t,r);return""+o.protocol+o.host+o.pathname+o.search+o.hash}var a="http://",s="w.w",c=a+s,h=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,p=/https?|ftp|gopher|file/;function n(e,t){var r="string"==typeof e?g(e):e;e="object"==typeof e?o(e):e;var s=g(t),n="";r.protocol&&!r.slashes&&(n=r.protocol,e=e.replace(r.protocol,""),n+="/"===t[0]||"/"===e[0]?"/":""),n&&s.protocol&&(n="",s.slashes||(n=s.protocol,t=t.replace(s.protocol,"")));var l=e.match(h);l&&!s.protocol&&(e=e.substr((n=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(t)&&(n=n.slice(0,-1)));var i=new URL(e,c+"/"),f=new URL(t,i).toString().replace(c,""),u=s.protocol||r.protocol;return u+=r.slashes||s.slashes?"//":"",!n&&u?f=f.replace(a,u):n&&(f=f.replace(a,"")),p.test(f)||~t.indexOf(".")||"/"===e.slice(-1)||"/"===t.slice(-1)||"/"!==f.slice(-1)||(f=f.slice(0,-1)),n&&(f=n+("/"===f[0]?f.substr(1):f)),f}function l(){}l.parse=g,l.format=o,l.resolve=n,l.resolveObject=n;var i=/^https?|ftp|gopher|file/,f=/^(.*?)([#?].*)/,u=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function d(e){try{return decodeURI(e)}catch(t){return e}}function g(e,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),e&&"object"==typeof e&&e instanceof l)return e;var h=(e=e.trim()).match(f);e=h?d(h[1]).replace(/\\/g,"/")+h[2]:d(e).replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var p=!/(^javascript)/.test(e)&&e.match(u),n=m.test(e),g="";p&&(i.test(p[1])||(g=p[1].toLowerCase(),e=""+p[2]+p[3]),p[2]||(n=!1,i.test(p[1])?(g=p[1],e=""+p[3]):e="//"+p[3]),3!==p[2].length&&1!==p[2].length||(g=p[1],e="/"+p[3]));var b,y=(h?h[1]:e).match(/(:[0-9]+)/),j="";y&&y[1]&&3===y[1].length&&(e=e.replace(j=y[1],j+"00"));var w=new l,x="",U="";try{b=new URL(e)}catch(t){x=t,g||a||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(U="/",e=e.substr(1));try{b=new URL(e,c)}catch(e){return w.protocol=g,w.href=g,w}}w.slashes=n&&!U,w.host=b.host===s?"":b.host,w.hostname=b.hostname===s?"":b.hostname.replace(/(\[|\])/g,""),w.protocol=x?g||null:b.protocol,w.search=b.search.replace(/\\/g,"%5C"),w.hash=b.hash.replace(/\\/g,"%5C");var R=e.split("#");!w.search&&~R[0].indexOf("?")&&(w.search="?"),w.hash||""!==R[1]||(w.hash="#"),w.query=r?t.decode(b.search.substr(1)):w.search.substr(1),w.pathname=U+d(b.pathname).replace(/"/g,"%22"),"about:"===w.protocol&&"blank"===w.pathname&&(w.protocol="",w.pathname=""),x&&"/"!==e[0]&&(w.pathname=w.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===w.pathname&&(w.pathname=""),w.path=w.pathname+w.search,w.auth=[b.username,b.password].map(decodeURIComponent).filter(Boolean).join(":"),w.port=b.port,j&&(w.host=w.host.replace(j+"00",j),w.port=w.port.slice(0,-2)),w.href=U?""+w.pathname+w.search+w.hash:o(w);var O=/^(file)/.test(w.href)?["host","hostname"]:[];return Object.keys(w).forEach(function(e){~O.indexOf(e)||(w[e]=w[e]||null)}),w}exports.parse=g,exports.format=o,exports.resolve=n,exports.resolveObject=function(e,t){return g(n(e,t))},exports.Url=l;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/finally-polyfill.min.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Promise.prototype.finally=function(n){if("function"!=typeof n)return this.then(n,n);var t=this.constructor||Promise;return this.then(function(r){return t.resolve(n()).then(function(){return r})},function(r){return t.resolve(n()).then(function(){throw r})})};

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/unfetch.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/unfetch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t}),t(a())},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null)})};
//# sourceMappingURL=unfetch.js.map


/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-build-watcher'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '10px';
  shadowHost.style.right = '20px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99999;
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-build-watcher-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css); // State

  var isVisible = false;
  var isBuilding = false;
  var timeoutId = null; // Handle events

  var evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: '/_next/webpack-hmr'
  });
  evtSource.addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      handleMessage(event);
    } catch (_unused) {}
  });

  function handleMessage(event) {
    var obj = JSON.parse(event.data); // eslint-disable-next-line default-case

    switch (obj.action) {
      case 'building':
        timeoutId && clearTimeout(timeoutId);
        isVisible = true;
        isBuilding = true;
        updateContainer();
        break;

      case 'built':
      case 'sync':
        isBuilding = false; // Wait for the fade out transtion to complete

        timeoutId = setTimeout(function () {
          isVisible = false;
          updateContainer();
        }, 100);
        updateContainer();
        break;
    }
  }

  function updateContainer() {
    if (isBuilding) {
      container.classList.add("".concat(prefix, "building"));
    } else {
      container.classList.remove("".concat(prefix, "building"));
    }

    if (isVisible) {
      container.classList.add("".concat(prefix, "visible"));
    } else {
      container.classList.remove("".concat(prefix, "visible"));
    }
  }
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = "".concat(prefix, "container");
  container.innerHTML = "\n    <div id=\"".concat(prefix, "icon-wrapper\">\n      <svg viewBox=\"0 0 226 200\">\n        <defs>\n          <linearGradient\n            x1=\"114.720775%\"\n            y1=\"181.283245%\"\n            x2=\"39.5399306%\"\n            y2=\"100%\"\n            id=\"").concat(prefix, "linear-gradient\"\n          >\n            <stop stop-color=\"#FFFFFF\" offset=\"0%\" />\n            <stop stop-color=\"#000000\" offset=\"100%\" />\n          </linearGradient>\n        </defs>\n        <g id=\"").concat(prefix, "icon-group\" fill=\"none\" stroke=\"url(#").concat(prefix, "linear-gradient)\" stroke-width=\"18\">\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\n        </g>\n      </svg>\n    </div>\n  ");
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #".concat(prefix, "container {\n      position: absolute;\n      bottom: 10px;\n      right: 30px;\n\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: initial;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n\n      padding: 8px 10px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: none;\n      opacity: 0;\n      transition: opacity 0.1s ease, bottom 0.1s ease;\n      animation: ").concat(prefix, "fade-in 0.1s ease-in-out;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "visible {\n      display: flex;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "building {\n      bottom: 20px;\n      opacity: 1;\n    }\n\n    #").concat(prefix, "icon-wrapper {\n      width: 16px;\n      height: 16px;\n    }\n\n    #").concat(prefix, "icon-wrapper > svg {\n      width: 100%;\n      height: 100%;\n    }\n\n    #").concat(prefix, "icon-group {\n      animation: ").concat(prefix, "strokedash 1s ease-in-out both infinite;\n    }\n\n    @keyframes ").concat(prefix, "fade-in {\n      from {\n        bottom: 10px;\n        opacity: 0;\n      }\n      to {\n        bottom: 20px;\n        opacity: 1;\n      }\n    }\n\n    @keyframes ").concat(prefix, "strokedash {\n      0% {\n        stroke-dasharray: 0 226;\n      }\n      80%,\n      100% {\n        stroke-dasharray: 659 226;\n      }\n    }\n  ");
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/eventsource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getEventSourceWrapper = getEventSourceWrapper;
var eventCallbacks = [];

function EventSourceWrapper(options) {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  if (!options.timeout) {
    options.timeout = 20 * 1000;
  }

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log('[HMR] connected');
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }

    if (event.data.indexOf('action') !== -1) {
      eventCallbacks.forEach(function (cb) {
        return cb(event);
      });
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    close: function close() {
      clearInterval(timer);
      source.close();
    },
    addMessageListener: function addMessageListener(fn) {
      listeners.push(fn);
    }
  };
}

_c = EventSourceWrapper;

function getEventSourceWrapper(options) {
  if (!options.ondemand) {
    return {
      addMessageListener: function addMessageListener(cb) {
        eventCallbacks.push(cb);
      }
    };
  }

  return EventSourceWrapper(options);
}

var _c;

$RefreshReg$(_c, "EventSourceWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/**
MIT License
Copyright (c) 2015-present, Facebook, Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic

var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.


function formatMessage(message) {
  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = _slicedToArray(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return "".concat(friendlySyntaxErrorLabel, " ").concat(errorMessage, " (").concat(errorLine, ":").concat(errorColumn, ")");
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "".concat(friendlySyntaxErrorLabel, " $3 ($1:$2)\n")); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')].concat(_toConsumableArray(lines.slice(2).filter(function (line) {
      return line.indexOf(' @ ') !== 0;
    })));
  } // Add helpful message for users trying to use Sass for the first time


  if (lines[1] && lines[1].match(/Cannot find module.+node-sass/)) {
    // ./file.module.scss (<<loader info>>) => ./file.module.scss
    lines[0] = lines[0].replace(/(.+) \(.+?(?=\?\?).+?\)/, '$1');
    lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
    lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
    lines[1] += '\nLearn more: https://err.sh/next.js/install-sass';
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = connect;

var DevOverlay = _interopRequireWildcard(__webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"));

var _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ "./node_modules/next/dist/compiled/strip-ansi/index.js"));

var _eventsource = __webpack_require__(/*! ./eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js"));
/**
* MIT License
*
* Copyright (c) 2013-present, Facebook, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// This file is a modified version of the Create React App HMR dev client that
// can be found here:
// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js
// This alternative WebpackDevServer combines the functionality of:
// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js
// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js
// It only supports their simplest configuration (hot updates on same server).
// It makes some opinionated choices on top, like adding a syntax error overlay
// that looks similar to our console output. The error overlay is inspired by:
// https://github.com/glenjamin/webpack-hot-middleware


var hadRuntimeError = false;
var customHmrEventHandler;

function connect(options) {
  DevOverlay.register();
  (0, _eventsource.getEventSourceWrapper)(options).addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      processMessage(event);
    } catch (ex) {
      console.warn('Invalid HMR message: ' + event.data + '\n' + ex);
    }
  });
  return {
    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {
      customHmrEventHandler = handler;
    },
    onUnrecoverableError: function onUnrecoverableError() {
      hadRuntimeError = true;
    }
  };
} // Remember some state related to hot module replacement.


var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;

function clearOutdatedErrors() {
  // Clean up outdated compile errors, if any.
  if (typeof console !== 'undefined' && typeof console.clear === 'function') {
    if (hasCompileErrors) {
      console.clear();
    }
  }
} // Successful compilation.


function handleSuccess() {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false; // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with warnings (e.g. ESLint).


function handleWarnings(warnings) {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    // Print warnings to the console.
    var formatted = (0, _formatWebpackMessages["default"])({
      warnings: warnings,
      errors: []
    });

    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
      for (var i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
          break;
        }

        console.warn((0, _stripAnsi["default"])(formatted.warnings[i]));
      }
    }
  }

  printWarnings(); // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with errors (e.g. syntax error or missing modules).


function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true; // "Massage" webpack messages.

  var formatted = (0, _formatWebpackMessages["default"])({
    errors: errors,
    warnings: []
  }); // Only show the first error.

  DevOverlay.onBuildError(formatted.errors[0]); // Also log them to the console.

  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    for (var i = 0; i < formatted.errors.length; i++) {
      console.error((0, _stripAnsi["default"])(formatted.errors[i]));
    }
  } // Do not attempt to reload now.
  // We will reload on next success instead.


  if (undefined) {
    if (self.__NEXT_HMR_CB) {
      self.__NEXT_HMR_CB(formatted.errors[0]);

      self.__NEXT_HMR_CB = null;
    }
  }
}

function onFastRefresh(hasUpdates) {
  DevOverlay.onBuildOk();

  if (hasUpdates) {
    DevOverlay.onRefresh();
  }

  console.log('[Fast Refresh] done');
} // There is a newer version of the code available.


function handleAvailableHash(hash) {
  // Update last known compilation hash.
  mostRecentCompilationHash = hash;
} // Handle messages from the server.


function processMessage(e) {
  var obj = JSON.parse(e.data);

  switch (obj.action) {
    case 'building':
      {
        console.log('[Fast Refresh] rebuilding');
        break;
      }

    case 'built':
    case 'sync':
      {
        if (obj.hash) {
          handleAvailableHash(obj.hash);
        }

        var errors = obj.errors,
            warnings = obj.warnings;
        var hasErrors = Boolean(errors && errors.length);

        if (hasErrors) {
          return handleErrors(errors);
        }

        var hasWarnings = Boolean(warnings && warnings.length);

        if (hasWarnings) {
          return handleWarnings(warnings);
        }

        return handleSuccess();
      }

    default:
      {
        if (customHmrEventHandler) {
          customHmrEventHandler(obj);
          break;
        }

        break;
      }
  }
} // Is there a newer version of this code available?


function isUpdateAvailable() {
  /* globals __webpack_hash__ */
  // __webpack_hash__ is the hash of the current compilation.
  // It's a global variable injected by Webpack.
  return mostRecentCompilationHash !== __webpack_require__.h();
} // Webpack disallows updates in other states.


function canApplyUpdates() {
  return module.hot.status() === 'idle';
}

function afterApplyUpdates(fn) {
  if (canApplyUpdates()) {
    fn();
  } else {
    var handler = function handler(status) {
      if (status === 'idle') {
        module.hot.removeStatusHandler(handler);
        fn();
      }
    };

    module.hot.addStatusHandler(handler);
  }
} // Attempt to update code on the fly, fall back to a hard reload.


function tryApplyUpdates(onHotUpdateSuccess) {
  if (false) {}

  if (!isUpdateAvailable() || !canApplyUpdates()) {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || hadRuntimeError || !updatedModules) {
      if (err) {
        console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React tree.\n" + 'You might have a file which renders a React component but also exports a value that is imported by a non-React component.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible you are using class components at the top-level of your application, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one function component in your React tree.');
      } else if (hadRuntimeError) {
        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');
      }

      window.location.reload();
      return;
    }

    var hasUpdates = Boolean(updatedModules.length);

    if (typeof onHotUpdateSuccess === 'function') {
      // Maybe we want to do something.
      onHotUpdateSuccess(hasUpdates);
    }

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates(hasUpdates ? undefined : onHotUpdateSuccess);
    } else {
      if (undefined) {
        afterApplyUpdates(function () {
          if (self.__NEXT_HMR_CB) {
            self.__NEXT_HMR_CB();

            self.__NEXT_HMR_CB = null;
          }
        });
      }
    }
  } // https://webpack.js.org/api/hot-module-replacement/#check


  module.hot.check(
  /* autoApply */
  true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/event-source-polyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/event-source-polyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));
/* eslint-disable */
// Improved version of https://github.com/Yaffle/EventSource/
// Available under MIT License (MIT)
// Only tries to support IE11 and nothing below


var document = window.document;
var Response = window.Response;
var TextDecoder = window.TextDecoder;
var TextEncoder = window.TextEncoder;
var AbortController = window.AbortController;

if (AbortController == undefined) {
  AbortController = function AbortController() {
    this.signal = null;

    this.abort = function () {};
  };
}

function TextDecoderPolyfill() {
  this.bitsNeeded = 0;
  this.codePoint = 0;
}

_c = TextDecoderPolyfill;

TextDecoderPolyfill.prototype.decode = function (octets) {
  function valid(codePoint, shift, octetsCount) {
    if (octetsCount === 1) {
      return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07ff;
    }

    if (octetsCount === 2) {
      return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xd7ff || codePoint >= 0xe000 >> shift && codePoint << shift <= 0xffff;
    }

    if (octetsCount === 3) {
      return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10ffff;
    }

    throw new Error();
  }

  function octetsCount(bitsNeeded, codePoint) {
    if (bitsNeeded === 6 * 1) {
      return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
    }

    if (bitsNeeded === 6 * 2) {
      return codePoint > 15 ? 3 : 2;
    }

    if (bitsNeeded === 6 * 3) {
      return 3;
    }

    throw new Error();
  }

  var REPLACER = 0xfffd;
  var string = '';
  var bitsNeeded = this.bitsNeeded;
  var codePoint = this.codePoint;

  for (var i = 0; i < octets.length; i += 1) {
    var octet = octets[i];

    if (bitsNeeded !== 0) {
      if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
        string += String.fromCharCode(codePoint);
      }
    }

    if (bitsNeeded === 0) {
      if (octet >= 0 && octet <= 127) {
        bitsNeeded = 0;
        codePoint = octet;
      } else if (octet >= 192 && octet <= 223) {
        bitsNeeded = 6 * 1;
        codePoint = octet & 31;
      } else if (octet >= 224 && octet <= 239) {
        bitsNeeded = 6 * 2;
        codePoint = octet & 15;
      } else if (octet >= 240 && octet <= 247) {
        bitsNeeded = 6 * 3;
        codePoint = octet & 7;
      } else {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }

      if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }
    } else {
      bitsNeeded -= 6;
      codePoint = codePoint << 6 | octet & 63;
    }

    if (bitsNeeded === 0) {
      if (codePoint <= 0xffff) {
        string += String.fromCharCode(codePoint);
      } else {
        string += String.fromCharCode(0xd800 + (codePoint - 0xffff - 1 >> 10));
        string += String.fromCharCode(0xdc00 + (codePoint - 0xffff - 1 & 0x3ff));
      }
    }
  }

  this.bitsNeeded = bitsNeeded;
  this.codePoint = codePoint;
  return string;
}; // Firefox < 38 throws an error with stream option


var supportsStreamOption = function supportsStreamOption() {
  try {
    return new TextDecoder().decode(new TextEncoder().encode('test'), {
      stream: true
    }) === 'test';
  } catch (error) {
    console.log(error);
  }

  return false;
}; // IE, Edge


if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  TextDecoder = TextDecoderPolyfill;
}

var k = function k() {};

function XHRWrapper(xhr) {
  this.withCredentials = false;
  this.responseType = '';
  this.readyState = 0;
  this.status = 0;
  this.statusText = '';
  this.responseText = '';
  this.onprogress = k;
  this.onreadystatechange = k;
  this._contentType = '';
  this._xhr = xhr;
  this._sendTimeout = 0;
  this._abort = k;
}

_c2 = XHRWrapper;

XHRWrapper.prototype.open = function (method, url) {
  this._abort(true);

  var that = this;
  var xhr = this._xhr;
  var state = 1;
  var timeout = 0;

  this._abort = function (silent) {
    if (that._sendTimeout !== 0) {
      clearTimeout(that._sendTimeout);
      that._sendTimeout = 0;
    }

    if (state === 1 || state === 2 || state === 3) {
      state = 4;
      xhr.onload = k;
      xhr.onerror = k;
      xhr.onabort = k;
      xhr.onprogress = k;
      xhr.onreadystatechange = k; // IE 8 - 9: XDomainRequest#abort() does not fire any event
      // Opera < 10: XMLHttpRequest#abort() does not fire any event

      xhr.abort();

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      if (!silent) {
        that.readyState = 4;
        that.onreadystatechange();
      }
    }

    state = 0;
  };

  var onStart = function onStart() {
    if (state === 1) {
      // state = 2;
      var status = 0;
      var statusText = '';
      var contentType = undefined;

      if (!('contentType' in xhr)) {
        try {
          status = xhr.status;
          statusText = xhr.statusText;
          contentType = xhr.getResponseHeader('Content-Type');
        } catch (error) {
          // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
          // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
          // https://bugs.webkit.org/show_bug.cgi?id=29121
          status = 0;
          statusText = '';
          contentType = undefined; // Firefox < 14, Chrome ?, Safari ?
          // https://bugs.webkit.org/show_bug.cgi?id=29658
          // https://bugs.webkit.org/show_bug.cgi?id=77854
        }
      } else {
        status = 200;
        statusText = 'OK';
        contentType = xhr.contentType;
      }

      if (status !== 0) {
        state = 2;
        that.readyState = 2;
        that.status = status;
        that.statusText = statusText;
        that._contentType = contentType;
        that.onreadystatechange();
      }
    }
  };

  var onProgress = function onProgress() {
    onStart();

    if (state === 2 || state === 3) {
      state = 3;
      var responseText = '';

      try {
        responseText = xhr.responseText;
      } catch (error) {// IE 8 - 9 with XMLHttpRequest
      }

      that.readyState = 3;
      that.responseText = responseText;
      that.onprogress();
    }
  };

  var onFinish = function onFinish() {
    // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
    // IE 8 fires "onload" without "onprogress"
    onProgress();

    if (state === 1 || state === 2 || state === 3) {
      state = 4;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      that.readyState = 4;
      that.onreadystatechange();
    }
  };

  var onReadyStateChange = function onReadyStateChange() {
    if (xhr != undefined) {
      // Opera 12
      if (xhr.readyState === 4) {
        onFinish();
      } else if (xhr.readyState === 3) {
        onProgress();
      } else if (xhr.readyState === 2) {
        onStart();
      }
    }
  };

  var onTimeout = function onTimeout() {
    timeout = setTimeout(function () {
      onTimeout();
    }, 500);

    if (xhr.readyState === 3) {
      onProgress();
    }
  }; // XDomainRequest#abort removes onprogress, onerror, onload


  xhr.onload = onFinish;
  xhr.onerror = onFinish; // improper fix to match Firefox behaviour, but it is better than just ignore abort
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  // https://code.google.com/p/chromium/issues/detail?id=153570
  // IE 8 fires "onload" without "onprogress

  xhr.onabort = onFinish; // https://bugzilla.mozilla.org/show_bug.cgi?id=736723

  if (!('sendAsBinary' in XMLHttpRequest.prototype) && !('mozAnon' in XMLHttpRequest.prototype)) {
    xhr.onprogress = onProgress;
  } // IE 8 - 9 (XMLHTTPRequest)
  // Opera < 12
  // Firefox < 3.5
  // Firefox 3.5 - 3.6 - ? < 9.0
  // onprogress is not fired sometimes or delayed
  // see also #64


  xhr.onreadystatechange = onReadyStateChange;

  if ('contentType' in xhr) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + 'padding=true';
  }

  xhr.open(method, url, true);

  if ('readyState' in xhr) {
    // workaround for Opera 12 issue with "progress" events
    // #91
    timeout = setTimeout(function () {
      onTimeout();
    }, 0);
  }
};

XHRWrapper.prototype.abort = function () {
  this._abort(false);
};

XHRWrapper.prototype.getResponseHeader = function (name) {
  return this._contentType;
};

XHRWrapper.prototype.setRequestHeader = function (name, value) {
  var xhr = this._xhr;

  if ('setRequestHeader' in xhr) {
    xhr.setRequestHeader(name, value);
  }
};

XHRWrapper.prototype.getAllResponseHeaders = function () {
  return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() : '';
};

XHRWrapper.prototype.send = function () {
  // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  if (!('ontimeout' in XMLHttpRequest.prototype) && document != undefined && document.readyState != undefined && document.readyState !== 'complete') {
    var that = this;
    that._sendTimeout = setTimeout(function () {
      that._sendTimeout = 0;
      that.send();
    }, 4);
    return;
  }

  var xhr = this._xhr; // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)

  xhr.withCredentials = this.withCredentials;
  xhr.responseType = this.responseType;

  try {
    // xhr.send(); throws "Not enough arguments" in Firefox 3.0
    xhr.send(undefined);
  } catch (error1) {
    // Safari 5.1.7, Opera 12
    throw error1;
  }
};

function toLowerCase(name) {
  return name.replace(/[A-Z]/g, function (c) {
    return String.fromCharCode(c.charCodeAt(0) + 0x20);
  });
}

function HeadersPolyfill(all) {
  // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  var map = Object.create(null);
  var array = all.split('\r\n');

  for (var i = 0; i < array.length; i += 1) {
    var line = array[i];
    var parts = line.split(': ');
    var name = parts.shift();
    var value = parts.join(': ');
    map[toLowerCase(name)] = value;
  }

  this._map = map;
}

_c3 = HeadersPolyfill;

HeadersPolyfill.prototype.get = function (name) {
  return this._map[toLowerCase(name)];
};

function XHRTransport() {}

_c4 = XHRTransport;

XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  xhr.open('GET', url);
  var offset = 0;

  xhr.onprogress = function () {
    var responseText = xhr.responseText;
    var chunk = responseText.slice(offset);
    offset += chunk.length;
    onProgressCallback(chunk);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 2) {
      var status = xhr.status;
      var statusText = xhr.statusText;
      var contentType = xhr.getResponseHeader('Content-Type');
      var headers = xhr.getAllResponseHeaders();
      onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers), function () {
        xhr.abort();
      });
    } else if (xhr.readyState === 4) {
      onFinishCallback();
    }
  };

  xhr.withCredentials = withCredentials;
  xhr.responseType = 'text';

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name)) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  xhr.send();
};

function HeadersWrapper(headers) {
  this._headers = headers;
}

_c5 = HeadersWrapper;

HeadersWrapper.prototype.get = function (name) {
  return this._headers.get(name);
};

function FetchTransport() {}

_c6 = FetchTransport;

FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  var controller = new AbortController();
  var signal = controller.signal; // see #120

  var textDecoder = new TextDecoder();
  (0, _unfetch["default"])(url, {
    headers: headers,
    credentials: withCredentials ? 'include' : 'same-origin',
    signal: signal,
    cache: 'no-store'
  }).then(function (response) {
    var reader = response.body.getReader();
    onStartCallback(response.status, response.statusText, response.headers.get('Content-Type'), new HeadersWrapper(response.headers), function () {
      controller.abort();
      reader.cancel();
    });
    return new Promise(function (resolve, reject) {
      var readNextChunk = function readNextChunk() {
        reader.read().then(function (result) {
          if (result.done) {
            // Note: bytes in textDecoder are ignored
            resolve(undefined);
          } else {
            var chunk = textDecoder.decode(result.value, {
              stream: true
            });
            onProgressCallback(chunk);
            readNextChunk();
          }
        })['catch'](function (error) {
          reject(error);
        });
      };

      readNextChunk();
    });
  }).then(function (result) {
    onFinishCallback();
    return result;
  }, function (error) {
    onFinishCallback();
    return Promise.reject(error);
  });
};

function EventTarget() {
  this._listeners = Object.create(null);
}

_c7 = EventTarget;

function throwError(e) {
  setTimeout(function () {
    throw e;
  }, 0);
}

EventTarget.prototype.dispatchEvent = function (event) {
  event.target = this;
  var typeListeners = this._listeners[event.type];

  if (typeListeners != undefined) {
    var length = typeListeners.length;

    for (var i = 0; i < length; i += 1) {
      var listener = typeListeners[i];

      try {
        if (typeof listener.handleEvent === 'function') {
          listener.handleEvent(event);
        } else {
          listener.call(this, event);
        }
      } catch (e) {
        throwError(e);
      }
    }
  }
};

EventTarget.prototype.addEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners == undefined) {
    typeListeners = [];
    listeners[type] = typeListeners;
  }

  var found = false;

  for (var i = 0; i < typeListeners.length; i += 1) {
    if (typeListeners[i] === listener) {
      found = true;
    }
  }

  if (!found) {
    typeListeners.push(listener);
  }
};

EventTarget.prototype.removeEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners != undefined) {
    var filtered = [];

    for (var i = 0; i < typeListeners.length; i += 1) {
      if (typeListeners[i] !== listener) {
        filtered.push(typeListeners[i]);
      }
    }

    if (filtered.length === 0) {
      delete listeners[type];
    } else {
      listeners[type] = filtered;
    }
  }
};

function Event(type) {
  this.type = type;
  this.target = undefined;
}

_c8 = Event;

function MessageEvent(type, options) {
  Event.call(this, type);
  this.data = options.data;
  this.lastEventId = options.lastEventId;
}

_c9 = MessageEvent;
MessageEvent.prototype = Object.create(Event.prototype);

function ConnectionEvent(type, options) {
  Event.call(this, type);
  this.status = options.status;
  this.statusText = options.statusText;
  this.headers = options.headers;
}

_c10 = ConnectionEvent;
ConnectionEvent.prototype = Object.create(Event.prototype);
var WAITING = -1;
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 2;
var AFTER_CR = -1;
var FIELD_START = 0;
var FIELD = 1;
var VALUE_START = 2;
var VALUE = 3;
var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;
var MINIMUM_DURATION = 1000;
var MAXIMUM_DURATION = 18000000;

var parseDuration = function parseDuration(value, def) {
  var n = parseInt(value, 10);

  if (n !== n) {
    n = def;
  }

  return clampDuration(n);
};

var clampDuration = function clampDuration(n) {
  return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
};

var fire = function fire(that, f, event) {
  try {
    if (typeof f === 'function') {
      f.call(that, event);
    }
  } catch (e) {
    throwError(e);
  }
};

function EventSourcePolyfill(url, options) {
  EventTarget.call(this);
  this.onopen = undefined;
  this.onmessage = undefined;
  this.onerror = undefined;
  this.url = undefined;
  this.readyState = undefined;
  this.withCredentials = undefined;
  this._close = undefined;
  start(this, url, options);
}

_c11 = EventSourcePolyfill;
var isFetchSupported = _unfetch["default"] != undefined && Response != undefined && 'body' in Response.prototype;

function start(es, url, options) {
  url = String(url);
  var withCredentials = options != undefined && Boolean(options.withCredentials);
  var initialRetry = clampDuration(1000);
  var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);
  var lastEventId = '';
  var retry = initialRetry;
  var wasActivity = false;
  var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;
  var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : XMLHttpRequest;
  var xhr = isFetchSupported && !(options != undefined && options.Transport != undefined) ? undefined : new XHRWrapper(new CurrentTransport());
  var transport = xhr == undefined ? new FetchTransport() : new XHRTransport();
  var cancelFunction = undefined;
  var timeout = 0;
  var currentState = WAITING;
  var dataBuffer = '';
  var lastEventIdBuffer = '';
  var eventTypeBuffer = '';
  var textBuffer = '';
  var state = FIELD_START;
  var fieldStart = 0;
  var valueStart = 0;

  var onStart = function onStart(status, statusText, contentType, headers, cancel) {
    if (currentState === CONNECTING) {
      cancelFunction = cancel;

      if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
        currentState = OPEN;
        wasActivity = true;
        retry = initialRetry;
        es.readyState = OPEN;
        var event = new ConnectionEvent('open', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onopen, event);
      } else {
        var message = '';

        if (status !== 200) {
          if (statusText) {
            statusText = statusText.replace(/\s+/g, ' ');
          }

          message = "EventSource's response has a status " + status + ' ' + statusText + ' that is not 200. Aborting the connection.';
        } else {
          message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? '-' : contentType.replace(/\s+/g, ' ')) + '. Aborting the connection.';
        }

        throwError(new Error(message));
        close();
        var event = new ConnectionEvent('error', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onerror, event);
      }
    }
  };

  var onProgress = function onProgress(textChunk) {
    if (currentState === OPEN) {
      var n = -1;

      for (var i = 0; i < textChunk.length; i += 1) {
        var c = textChunk.charCodeAt(i);

        if (c === '\n'.charCodeAt(0) || c === '\r'.charCodeAt(0)) {
          n = i;
        }
      }

      var chunk = (n !== -1 ? textBuffer : '') + textChunk.slice(0, n + 1);
      textBuffer = (n === -1 ? textBuffer : '') + textChunk.slice(n + 1);

      if (chunk !== '') {
        wasActivity = true;
      }

      for (var position = 0; position < chunk.length; position += 1) {
        var c = chunk.charCodeAt(position);

        if (state === AFTER_CR && c === '\n'.charCodeAt(0)) {
          state = FIELD_START;
        } else {
          if (state === AFTER_CR) {
            state = FIELD_START;
          }

          if (c === '\r'.charCodeAt(0) || c === '\n'.charCodeAt(0)) {
            if (state !== FIELD_START) {
              if (state === FIELD) {
                valueStart = position + 1;
              }

              var field = chunk.slice(fieldStart, valueStart - 1);
              var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === ' '.charCodeAt(0) ? 1 : 0), position);

              if (field === 'data') {
                dataBuffer += '\n';
                dataBuffer += value;
              } else if (field === 'id') {
                lastEventIdBuffer = value;
              } else if (field === 'event') {
                eventTypeBuffer = value;
              } else if (field === 'retry') {
                initialRetry = parseDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === 'heartbeatTimeout') {
                heartbeatTimeout = parseDuration(value, heartbeatTimeout);

                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(function () {
                    onTimeout();
                  }, heartbeatTimeout);
                }
              }
            }

            if (state === FIELD_START) {
              if (dataBuffer !== '') {
                lastEventId = lastEventIdBuffer;

                if (eventTypeBuffer === '') {
                  eventTypeBuffer = 'message';
                }

                var event = new MessageEvent(eventTypeBuffer, {
                  data: dataBuffer.slice(1),
                  lastEventId: lastEventIdBuffer
                });
                es.dispatchEvent(event);

                if (eventTypeBuffer === 'message') {
                  fire(es, es.onmessage, event);
                }

                if (currentState === CLOSED) {
                  return;
                }
              }

              dataBuffer = '';
              eventTypeBuffer = '';
            }

            state = c === '\r'.charCodeAt(0) ? AFTER_CR : FIELD_START;
          } else {
            if (state === FIELD_START) {
              fieldStart = position;
              state = FIELD;
            }

            if (state === FIELD) {
              if (c === ':'.charCodeAt(0)) {
                valueStart = position + 1;
                state = VALUE_START;
              }
            } else if (state === VALUE_START) {
              state = VALUE;
            }
          }
        }
      }
    }
  };

  var onFinish = function onFinish() {
    if (currentState === OPEN || currentState === CONNECTING) {
      currentState = WAITING;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      timeout = setTimeout(function () {
        onTimeout();
      }, retry);
      retry = clampDuration(Math.min(initialRetry * 16, retry * 2));
      es.readyState = CONNECTING;
      var event = new Event('error');
      es.dispatchEvent(event);
      fire(es, es.onerror, event);
    }
  };

  var close = function close() {
    currentState = CLOSED;

    if (cancelFunction != undefined) {
      cancelFunction();
      cancelFunction = undefined;
    }

    if (timeout !== 0) {
      clearTimeout(timeout);
      timeout = 0;
    }

    es.readyState = CLOSED;
  };

  var onTimeout = function onTimeout() {
    timeout = 0;

    if (currentState !== WAITING) {
      if (!wasActivity && cancelFunction != undefined) {
        throwError(new Error('No activity within ' + heartbeatTimeout + ' milliseconds. Reconnecting.'));
        cancelFunction();
        cancelFunction = undefined;
      } else {
        wasActivity = false;
        timeout = setTimeout(function () {
          onTimeout();
        }, heartbeatTimeout);
      }

      return;
    }

    wasActivity = false;
    timeout = setTimeout(function () {
      onTimeout();
    }, heartbeatTimeout);
    currentState = CONNECTING;
    dataBuffer = '';
    eventTypeBuffer = '';
    lastEventIdBuffer = lastEventId;
    textBuffer = '';
    fieldStart = 0;
    valueStart = 0;
    state = FIELD_START; // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
    // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.

    var requestURL = url;

    if (url.slice(0, 5) !== 'data:' && url.slice(0, 5) !== 'blob:') {
      if (lastEventId !== '') {
        requestURL += (url.indexOf('?') === -1 ? '?' : '&') + 'lastEventId=' + encodeURIComponent(lastEventId);
      }
    }

    var requestHeaders = {};
    requestHeaders['Accept'] = 'text/event-stream';

    if (headers != undefined) {
      for (var name in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name)) {
          requestHeaders[name] = headers[name];
        }
      }
    }

    try {
      transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
    } catch (error) {
      close();
      throw error;
    }
  };

  es.url = url;
  es.readyState = CONNECTING;
  es.withCredentials = withCredentials;
  es._close = close;
  onTimeout();
}

EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
EventSourcePolyfill.prototype.OPEN = OPEN;
EventSourcePolyfill.prototype.CLOSED = CLOSED;

EventSourcePolyfill.prototype.close = function () {
  this._close();
};

EventSourcePolyfill.CONNECTING = CONNECTING;
EventSourcePolyfill.OPEN = OPEN;
EventSourcePolyfill.CLOSED = CLOSED;
EventSourcePolyfill.prototype.withCredentials = undefined;
var _default = EventSourcePolyfill;
exports["default"] = _default;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;

$RefreshReg$(_c, "TextDecoderPolyfill");
$RefreshReg$(_c2, "XHRWrapper");
$RefreshReg$(_c3, "HeadersPolyfill");
$RefreshReg$(_c4, "XHRTransport");
$RefreshReg$(_c5, "HeadersWrapper");
$RefreshReg$(_c6, "FetchTransport");
$RefreshReg$(_c7, "EventTarget");
$RefreshReg$(_c8, "Event");
$RefreshReg$(_c9, "MessageEvent");
$RefreshReg$(_c10, "ConnectionEvent");
$RefreshReg$(_c11, "EventSourcePolyfill");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.displayContent = displayContent;

function displayContent(callback) {
  // This is the fallback helper that removes Next.js' no-FOUC styles when
  // CSS mode is enabled. This only really activates if you haven't created
  // _any_ styles in your application yet.
  ;
  (window.requestAnimationFrame || setTimeout)(function () {
    for (var x = document.querySelectorAll('[data-next-hide-fouc]'), i = x.length; i--;) {
      x[i].parentNode.removeChild(x[i]);
    }

    if (callback) {
      callback();
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = _interopRequireDefault(__webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js"));

var _onDemandEntriesUtils = __webpack_require__(/*! ./on-demand-entries-utils */ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js");

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var assetPrefix;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assetPrefix = _ref.assetPrefix;

            _router["default"].ready(function () {
              _router["default"].events.on('routeChangeComplete', _onDemandEntriesUtils.setupPing.bind(void 0, assetPrefix, function () {
                return _router["default"].pathname;
              }));
            });

            (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
              return _router["default"].pathname;
            }, _onDemandEntriesUtils.currentPage); // prevent HMR connection from being closed when running tests

            if (!undefined) {
              document.addEventListener('visibilitychange', function (event) {
                var state = document.visibilityState;

                if (state === 'visible') {
                  (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
                    return _router["default"].pathname;
                  }, true);
                } else {
                  (0, _onDemandEntriesUtils.closePing)();
                }
              });
              window.addEventListener('beforeunload', function () {
                (0, _onDemandEntriesUtils.closePing)();
              });
            }

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.closePing = closePing;
exports.setupPing = setupPing;
exports.currentPage = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");
/* global location */


var evtSource;
var currentPage;
exports.currentPage = currentPage;

function closePing() {
  if (evtSource) evtSource.close();
  evtSource = null;
}

function setupPing(assetPrefix, pathnameFn, retry) {
  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed

  if (pathname === currentPage && !retry) return;
  exports.currentPage = currentPage = pathname; // close current EventSource connection

  closePing();
  var url = "".concat(assetPrefix, "/_next/webpack-hmr?page=").concat(currentPage);
  evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: url,
    timeout: 5000,
    ondemand: 1
  });
  evtSource.addMessageListener(function (event) {
    if (event.data.indexOf('{') === -1) return;

    try {
      var payload = JSON.parse(event.data);

      if (payload.invalid) {
        // Payload can be invalid even if the page does not exist.
        // So, we need to make sure it exists before reloading.
        (0, _unfetch["default"])(location.href, {
          credentials: 'same-origin'
        }).then(function (pageRes) {
          if (pageRes.status === 200) {
            location.reload();
          }
        });
      }
    } catch (err) {
      console.error('on-demand-entries failed to parse response', err);
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/prerender-indicator.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/prerender-indicator.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _router = _interopRequireDefault(__webpack_require__(/*! ../router */ "./node_modules/next/dist/client/router.js"));

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-prerender-indicator'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '20px';
  shadowHost.style.right = '10px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99998;
  shadowHost.style.transition = 'all 100ms ease';
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-prerender-indicator-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css);
  var expandEl = container.querySelector('a');
  var closeEl = container.querySelector("#".concat(prefix, "close")); // State

  var dismissKey = '__NEXT_DISMISS_PRERENDER_INDICATOR';
  var dismissUntil = parseInt(window.localStorage.getItem(dismissKey), 10);
  var dismissed = dismissUntil > new Date().getTime();
  var isVisible = !dismissed && window.__NEXT_DATA__.nextExport;

  function updateContainer() {
    if (isVisible) {
      container.classList.add("".concat(prefix, "visible"));
    } else {
      container.classList.remove("".concat(prefix, "visible"));
    }
  }

  var expandedClass = "".concat(prefix, "expanded");
  var toggleTimeout;

  var toggleExpand = function toggleExpand() {
    var expand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    clearTimeout(toggleTimeout);
    toggleTimeout = setTimeout(function () {
      if (expand) {
        expandEl.classList.add(expandedClass);
        closeEl.style.display = 'flex';
      } else {
        expandEl.classList.remove(expandedClass);
        closeEl.style.display = 'none';
      }
    }, 50);
  };

  closeEl.addEventListener('click', function () {
    var oneHourAway = new Date().getTime() + 1 * 60 * 60 * 1000;
    window.localStorage.setItem(dismissKey, oneHourAway + '');
    isVisible = false;
    updateContainer();
  });
  closeEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  closeEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });
  expandEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  expandEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });

  _router["default"].events.on('routeChangeComplete', function () {
    isVisible = window.next.isPrerendered;
    updateContainer();
  });

  updateContainer();
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = "".concat(prefix, "container");
  container.innerHTML = "\n    <button id=\"".concat(prefix, "close\" title=\"Hide indicator for session\">\n      <span>\xD7</span>\n    </button>\n    <a href=\"https://nextjs.org/docs#automatic-static-optimization-indicator\" target=\"_blank\" rel=\"noreferrer\">\n      <div id=\"").concat(prefix, "icon-wrapper\">\n          <svg width=\"15\" height=\"20\" viewBox=\"0 0 60 80\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path d=\"M36 3L30.74 41H8L36 3Z\" fill=\"black\"/>\n          <path d=\"M25 77L30.26 39H53L25 77Z\" fill=\"black\"/>\n          <path d=\"M13.5 33.5L53 39L47.5 46.5L7 41.25L13.5 33.5Z\" fill=\"black\"/>\n          </svg>\n          Prerendered Page\n      </div>\n    </a>\n  ");
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #".concat(prefix, "container {\n      position: absolute;\n      display: none;\n      bottom: 10px;\n      right: 15px;\n    }\n\n    #").concat(prefix, "close {\n      top: -10px;\n      right: -10px;\n      border: none;\n      width: 18px;\n      height: 18px;\n      color: #333333;\n      font-size: 16px;\n      cursor: pointer;\n      display: none;\n      position: absolute;\n      background: #ffffff;\n      border-radius: 100%;\n      align-items: center;\n      flex-direction: column;\n      justify-content: center;\n    }\n\n    #").concat(prefix, "container a {\n      color: inherit;\n      text-decoration: none;\n      width: 15px;\n      height: 23px;\n      overflow: hidden;\n\n      border-radius: 3px;\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: pointer;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n\n      padding: 4px 2px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: flex;\n      transition: opacity 0.1s ease, bottom 0.1s ease, width 0.3s ease;\n      animation: ").concat(prefix, "fade-in 0.1s ease-in-out;\n    }\n\n    #").concat(prefix, "icon-wrapper {\n      width: 140px;\n      height: 20px;\n      display: flex;\n      flex-shrink: 0;\n      align-items: center;\n      position: relative;\n    }\n\n    #").concat(prefix, "icon-wrapper svg {\n      flex-shrink: 0;\n      margin-right: 3px;\n    }\n\n    #").concat(prefix, "container a.").concat(prefix, "expanded {\n      width: 135px;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "visible {\n      display: flex;\n      bottom: 10px;\n      opacity: 1;\n    }\n\n    @keyframes ").concat(prefix, "fade-in {\n      from {\n        bottom: 0px;\n        opacity: 0;\n      }\n      to {\n        bottom: 10px;\n        opacity: 1;\n      }\n    }\n  ");
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _hotDevClient = _interopRequireDefault(__webpack_require__(/*! ./error-overlay/hot-dev-client */ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js"));

var _default = function _default(_ref) {
  var assetPrefix = _ref.assetPrefix;
  var options = {
    path: "".concat(assetPrefix, "/_next/webpack-hmr")
  };
  var devClient = (0, _hotDevClient["default"])(options);
  devClient.subscribeToHmrEvent(function (obj) {
    if (obj.action === 'reloadPage') {
      return window.location.reload();
    }

    if (obj.action === 'removedPage') {
      var _obj$data = _slicedToArray(obj.data, 1),
          page = _obj$data[0];

      if (page === window.next.router.pathname) {
        return window.location.reload();
      }

      return;
    }

    if (obj.action === 'addedPage') {
      var _obj$data2 = _slicedToArray(obj.data, 1),
          _page = _obj$data2[0];

      if (_page === window.next.router.pathname && typeof window.next.router.components[_page] === 'undefined') {
        return window.location.reload();
      }

      return;
    }

    throw new Error('Unexpected action ' + obj.action);
  });
  return devClient;
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initHeadManager;
var DOMAttributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};

function reactElementToDOM(_ref) {
  var type = _ref.type,
      props = _ref.props;
  var el = document.createElement(type);

  for (var p in props) {
    if (!props.hasOwnProperty(p)) continue;
    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM

    if (props[p] === undefined) continue;
    var attr = DOMAttributeNames[p] || p.toLowerCase();
    el.setAttribute(attr, props[p]);
  }

  var children = props.children,
      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;

  if (dangerouslySetInnerHTML) {
    el.innerHTML = dangerouslySetInnerHTML.__html || '';
  } else if (children) {
    el.textContent = typeof children === 'string' ? children : children.join('');
  }

  return el;
}

function updateElements(type, components) {
  var headEl = document.getElementsByTagName('head')[0];
  var headCountEl = headEl.querySelector('meta[name=next-head-count]');

  if (true) {
    if (!headCountEl) {
      console.error('Warning: next-head-count is missing. https://err.sh/next.js/next-head-count-missing');
      return;
    }
  }

  var headCount = Number(headCountEl.content);
  var oldTags = [];

  for (var i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {
    if (j.tagName.toLowerCase() === type) {
      oldTags.push(j);
    }
  }

  var newTags = components.map(reactElementToDOM).filter(function (newTag) {
    for (var k = 0, len = oldTags.length; k < len; k++) {
      var oldTag = oldTags[k];

      if (oldTag.isEqualNode(newTag)) {
        oldTags.splice(k, 1);
        return false;
      }
    }

    return true;
  });
  oldTags.forEach(function (t) {
    return t.parentNode.removeChild(t);
  });
  newTags.forEach(function (t) {
    return headEl.insertBefore(t, headCountEl);
  });
  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
}

function initHeadManager() {
  var updatePromise = null;
  return function (head) {
    var promise = updatePromise = Promise.resolve().then(function () {
      if (promise !== updatePromise) return;
      updatePromise = null;
      var tags = {};
      head.forEach(function (h) {
        var components = tags[h.type] || [];
        components.push(h);
        tags[h.type] = components;
      });
      var titleComponent = tags.title ? tags.title[0] : null;
      var title = '';

      if (titleComponent) {
        var children = titleComponent.props.children;
        title = typeof children === 'string' ? children : children.join('');
      }

      if (title !== document.title) document.title = title;
      ['meta', 'base', 'link', 'style', 'script'].forEach(function (type) {
        updateElements(type, tags[type] || []);
      });
    });
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireWildcard3 = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.render = render;
exports.renderError = renderError;
exports["default"] = exports.emitter = exports.router = exports.version = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

var _router = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");

var _querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));

var _headManagerContext = __webpack_require__(/*! ../next-server/lib/head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var envConfig = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/runtime-config */ "./node_modules/next/dist/next-server/lib/runtime-config.js"));

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ "./node_modules/next/dist/client/head-manager.js"));

var _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ "./node_modules/next/dist/client/page-loader.js"));

var _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ "./node_modules/next/dist/client/performance-relayer.js"));
/* global location */
/// <reference types="react-dom/experimental" />


if (!('finally' in Promise.prototype)) {
  // eslint-disable-next-line no-extend-native
  Promise.prototype["finally"] = __webpack_require__(/*! next/dist/build/polyfills/finally-polyfill.min */ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js");
}

var data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);
window.__NEXT_DATA__ = data;
var version = "9.4.4";
exports.version = version;
var props = data.props,
    err = data.err,
    page = data.page,
    query = data.query,
    buildId = data.buildId,
    assetPrefix = data.assetPrefix,
    runtimeConfig = data.runtimeConfig,
    dynamicIds = data.dynamicIds,
    isFallback = data.isFallback;
var prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime

__webpack_require__.p = "".concat(prefix, "/_next/"); //eslint-disable-line
// Initialize next/config with the environment configuration

envConfig.setConfig({
  serverRuntimeConfig: {},
  publicRuntimeConfig: runtimeConfig || {}
});
var asPath = (0, _utils.getURL)();
var pageLoader = new _pageLoader["default"](buildId, prefix);

var register = function register(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      r = _ref2[0],
      f = _ref2[1];

  return pageLoader.registerPage(r, f);
};

if (window.__NEXT_P) {
  // Defer page registration for another tick. This will increase the overall
  // latency in hydrating the page, but reduce the total blocking time.
  window.__NEXT_P.map(function (p) {
    return setTimeout(function () {
      return register(p);
    }, 0);
  });
}

window.__NEXT_P = [];
window.__NEXT_P.push = register;
var updateHead = (0, _headManager["default"])();
var appElement = document.getElementById('__next');
var lastAppProps;

var _lastRenderReject;

var webpackHMR;
var router;
exports.router = router;
var Component;
var App, onPerfEntry;

var Container = /*#__PURE__*/function (_react$default$Compon) {
  _inherits(Container, _react$default$Compon);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "componentDidCatch",
    value: function componentDidCatch(err, info) {
      this.props.fn(err, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToHash();

      if (false) {} // We need to replace the router state if:
      // - the page was (auto) exported and has a query string or search (hash)
      // - it was auto exported and is a dynamic route (to provide params)
      // - if it is a client-side skeleton (fallback render)


      if (router.isSsr && (isFallback || data.nextExport && ((0, _isDynamic.isDynamicRoute)(router.pathname) || location.search) || props && props.__N_SSG && location.search)) {
        // update query on mount for exported pages
        router.replace(router.pathname + '?' + (0, _querystring.stringify)((0, _extends2["default"])((0, _extends2["default"])({}, router.query), (0, _querystring.parse)(location.search.substr(1)))), asPath, {
          // WARNING: `_h` is an internal option for handing Next.js
          // client-side hydration. Your app should _never_ use this property.
          // It may change at any time without notice.
          _h: 1,
          // Fallback pages must trigger the data fetch, so the transition is
          // not shallow.
          // Other pages (strictly updating query) happens shallowly, as data
          // requirements would already be present.
          shallow: !isFallback
        });
      }

      if (undefined) {
        window.__NEXT_HYDRATED = true;

        if (window.__NEXT_HYDRATED_CB) {
          window.__NEXT_HYDRATED_CB();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.scrollToHash();
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash() {
      var _location = location,
          hash = _location.hash;
      hash = hash && hash.substring(1);
      if (!hash) return;
      var el = document.getElementById(hash);
      if (!el) return; // If we call scrollIntoView() in here without a setTimeout
      // it won't scroll properly.

      setTimeout(function () {
        return el.scrollIntoView();
      }, 0);
    }
  }, {
    key: "render",
    value: function render() {
      if (false) {}

      if (true) {
        var _require = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"),
            ReactDevOverlay = _require.ReactDevOverlay;

        return /*#__PURE__*/_react["default"].createElement(ReactDevOverlay, null, this.props.children);
      }
    }
  }]);

  return Container;
}(_react["default"].Component);

var emitter = (0, _mitt["default"])();
exports.emitter = emitter;

var _default = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _ref4,
        passedWebpackHMR,
        _yield$pageLoader$loa,
        app,
        mod,
        initialErr,
        _yield$pageLoader$loa2,
        _require2,
        isValidElementType,
        _require3,
        getNodeError,
        renderCtx,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref4 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, passedWebpackHMR = _ref4.webpackHMR;

            // This makes sure this specific lines are removed in production
            if (true) {
              webpackHMR = passedWebpackHMR;
            }

            _context.next = 4;
            return pageLoader.loadPageScript('/_app');

          case 4:
            _yield$pageLoader$loa = _context.sent;
            app = _yield$pageLoader$loa.page;
            mod = _yield$pageLoader$loa.mod;
            App = app;

            if (mod && mod.reportWebVitals) {
              onPerfEntry = function onPerfEntry(_ref5) {
                var id = _ref5.id,
                    name = _ref5.name,
                    startTime = _ref5.startTime,
                    value = _ref5.value,
                    duration = _ref5.duration,
                    entryType = _ref5.entryType,
                    entries = _ref5.entries;
                // Combines timestamp with random number for unique ID
                var uniqueID = "".concat(Date.now(), "-").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);
                var perfStartEntry;

                if (entries && entries.length) {
                  perfStartEntry = entries[0].startTime;
                }

                mod.reportWebVitals({
                  id: id || uniqueID,
                  name: name,
                  startTime: startTime || perfStartEntry,
                  value: value == null ? duration : value,
                  label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'
                });
              };
            }

            initialErr = err;
            _context.prev = 10;
            ;
            _context.next = 14;
            return pageLoader.loadPage(page);

          case 14:
            _yield$pageLoader$loa2 = _context.sent;
            Component = _yield$pageLoader$loa2.page;

            if (false) {}

            _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

            if (isValidElementType(Component)) {
              _context.next = 20;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"".concat(page, "\""));

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](10);
            // This catches errors like throwing in the top level of a module
            initialErr = _context.t0;

          case 25:
            if (true) {
              _require3 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"), getNodeError = _require3.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so
              // that the overlay is rendered.

              if (initialErr) {
                if (initialErr === err) {
                  setTimeout(function () {
                    var error;

                    try {
                      // Generate a new error object. We `throw` it because some browsers
                      // will set the `stack` when thrown, and we want to ensure ours is
                      // not overridden when we re-throw it below.
                      throw new Error(initialErr.message);
                    } catch (e) {
                      error = e;
                    }

                    error.name = initialErr.name;
                    error.stack = initialErr.stack;
                    var node = getNodeError(error);
                    throw node;
                  });
                } // We replaced the server-side error with a client-side error, and should
                // no longer rewrite the stack trace to a Node error.
                else {
                    setTimeout(function () {
                      throw initialErr;
                    });
                  }
              }
            }

            if (!window.__NEXT_PRELOADREADY) {
              _context.next = 29;
              break;
            }

            _context.next = 29;
            return window.__NEXT_PRELOADREADY(dynamicIds);

          case 29:
            exports.router = router = (0, _router.createRouter)(page, query, asPath, {
              initialProps: props,
              pageLoader: pageLoader,
              App: App,
              Component: Component,
              wrapApp: wrapApp,
              err: initialErr,
              isFallback: isFallback,
              subscription: function subscription(_ref6, App) {
                var Component = _ref6.Component,
                    props = _ref6.props,
                    err = _ref6.err;
                return render({
                  App: App,
                  Component: Component,
                  props: props,
                  err: err
                });
              }
            }); // call init-client middleware

            if (false) {}

            renderCtx = {
              App: App,
              Component: Component,
              props: props,
              err: initialErr
            };

            if (true) {
              _context.next = 35;
              break;
            }

            render(renderCtx);
            return _context.abrupt("return", emitter);

          case 35:
            if (false) {}

            return _context.abrupt("return", {
              emitter: emitter,
              render: render,
              renderCtx: renderCtx
            });

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[10, 22]]);
  }));

  return function _default() {
    return _ref3.apply(this, arguments);
  };
}();

exports["default"] = _default;

function render(_x) {
  return _render.apply(this, arguments);
} // This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.


function _render() {
  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!props.err) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return renderError(props);

          case 3:
            return _context2.abrupt("return");

          case 4:
            _context2.prev = 4;
            _context2.next = 7;
            return doRender(props);

          case 7:
            _context2.next = 14;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

            if (true) {
              // Ensure this error is displayed in the overlay in development
              setTimeout(function () {
                throw _context2.t0;
              });
            }

            _context2.next = 14;
            return renderError((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              err: _context2.t0
            }));

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9]]);
  }));
  return _render.apply(this, arguments);
}

function renderError(props) {
  var App = props.App,
      err = props.err; // In development runtime errors are caught by our overlay
  // In production we catch runtime errors using componentDidCatch which will trigger renderError

  if (true) {
    // A Next.js rendering runtime error is always unrecoverable
    // FIXME: let's make this recoverable (error in GIP client-transition)
    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can
    // render itself.

    return doRender({
      App: function App() {
        return null;
      },
      props: {},
      Component: function Component() {
        return null;
      },
      err: null
    });
  }

  if (false) {} // Make sure we log the error to the console, otherwise users can't track down issues.


  console.error(err);
  return pageLoader.loadPage('/_error').then(function (_ref7) {
    var ErrorComponent = _ref7.page;
    // In production we do a normal render with the `ErrorComponent` as component.
    // If we've gotten here upon initial render, we can use the props from the server.
    // Otherwise, we need to call `getInitialProps` on `App` before mounting.
    var AppTree = wrapApp(App);
    var appCtx = {
      Component: ErrorComponent,
      AppTree: AppTree,
      router: router,
      ctx: {
        err: err,
        pathname: page,
        query: query,
        asPath: asPath,
        AppTree: AppTree
      }
    };
    return Promise.resolve(props.props ? props.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then(function (initProps) {
      return doRender((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
        err: err,
        Component: ErrorComponent,
        props: initProps
      }));
    });
  });
} // If hydrate does not exist, eg in preact.


var isInitialRender = typeof _reactDom["default"].hydrate === 'function';
var reactRoot = null;

function renderReactElement(reactEl, domEl) {
  if (false) { var opts; } else {
    // mark start of hydrate/render
    if (_utils.ST) {
      performance.mark('beforeRender');
    } // The check for `.hydrate` is there to support React alternatives like preact


    if (isInitialRender) {
      _reactDom["default"].hydrate(reactEl, domEl, markHydrateComplete);

      isInitialRender = false;

      if (onPerfEntry && _utils.ST) {
        (0, _performanceRelayer["default"])(onPerfEntry);
      }
    } else {
      _reactDom["default"].render(reactEl, domEl, markRenderComplete);
    }
  }
}

function markHydrateComplete() {
  if (!_utils.ST) return;
  performance.mark('afterHydrate'); // mark end of hydration

  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');
  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);
  }

  clearMarks();
}

function markRenderComplete() {
  if (!_utils.ST) return;
  performance.mark('afterRender'); // mark end of render

  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');

  if (!navStartEntries.length) {
    return;
  }

  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');
  performance.measure('Next.js-render', 'beforeRender', 'afterRender');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);
    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);
  }

  clearMarks();
  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {
    return performance.clearMeasures(measure);
  });
}

function clearMarks() {
  ;
  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {
    return performance.clearMarks(mark);
  });
}

function AppContainer(_ref8) {
  var children = _ref8.children;
  return /*#__PURE__*/_react["default"].createElement(Container, {
    fn: function fn(error) {
      return renderError({
        App: App,
        err: error
      })["catch"](function (err) {
        return console.error('Error rendering page: ', err);
      });
    }
  }, /*#__PURE__*/_react["default"].createElement(_routerContext.RouterContext.Provider, {
    value: (0, _router.makePublicRouterInstance)(router)
  }, /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Provider, {
    value: updateHead
  }, children)));
}

_c = AppContainer;

var wrapApp = function wrapApp(App) {
  return function (props) {
    var appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
      Component: Component,
      err: err,
      router: router
    });
    return /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps));
  };
};

function doRender(_x2) {
  return _doRender.apply(this, arguments);
}

function _doRender() {
  _doRender = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref9) {
    var App, Component, props, err, appProps, resolvePromise, renderPromise, elem;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            App = _ref9.App, Component = _ref9.Component, props = _ref9.props, err = _ref9.err;
            Component = Component || lastAppProps.Component;
            props = props || lastAppProps.props;
            appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              Component: Component,
              err: err,
              router: router
            }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

            lastAppProps = appProps;
            renderPromise = new Promise(function (resolve, reject) {
              if (_lastRenderReject) {
                _lastRenderReject();
              }

              resolvePromise = function resolvePromise() {
                _lastRenderReject = null;
                resolve();
              };

              _lastRenderReject = function lastRenderReject() {
                _lastRenderReject = null;
                reject();
              };
            });
            elem = /*#__PURE__*/_react["default"].createElement(Root, {
              callback: resolvePromise
            }, /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps))); // We catch runtime errors using componentDidCatch which will trigger renderError

            renderReactElement( false ? /*#__PURE__*/undefined : elem, appElement);
            _context3.next = 10;
            return renderPromise;

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _doRender.apply(this, arguments);
}

function Root(_ref10) {
  _s();

  var callback = _ref10.callback,
      children = _ref10.children;

  // We use `useLayoutEffect` to guarantee the callback is executed
  // as soon as React flushes the update.
  _react["default"].useLayoutEffect(function () {
    return callback();
  }, [callback]);

  return children;
}

_s(Root, "n7/vCynhJvM+pLkyL2DMQUF0odM=");

_c2 = Root;

var _c, _c2;

$RefreshReg$(_c, "AppContainer");
$RefreshReg$(_c2, "Root");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var next = _interopRequireWildcard(__webpack_require__(/*! ./ */ "./node_modules/next/dist/client/index.js"));

var _eventSourcePolyfill = _interopRequireDefault(__webpack_require__(/*! ./dev/event-source-polyfill */ "./node_modules/next/dist/client/dev/event-source-polyfill.js"));

var _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ "./node_modules/next/dist/client/dev/on-demand-entries-client.js"));

var _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js"));

var _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ "./node_modules/next/dist/client/dev/dev-build-watcher.js"));

var _prerenderIndicator = _interopRequireDefault(__webpack_require__(/*! ./dev/prerender-indicator */ "./node_modules/next/dist/client/dev/prerender-indicator.js"));

var _fouc = __webpack_require__(/*! ./dev/fouc */ "./node_modules/next/dist/client/dev/fouc.js");
/* globals import('./dev/noop'); */
// Temporary workaround for the issue described here:
// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123
// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import
// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries
// eslint-disable-next-line no-unused-expressions


__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.t.bind(null, /*! ./dev/noop */ "./node_modules/next/dist/client/dev/noop.js", 7));
; // Support EventSource on Internet Explorer 11

if (!window.EventSource) {
  window.EventSource = _eventSourcePolyfill["default"];
}

var _window = window,
    assetPrefix = _window.__NEXT_DATA__.assetPrefix;
var prefix = assetPrefix || '';
var webpackHMR = (0, _webpackHotMiddlewareClient["default"])({
  assetPrefix: prefix
});
window.next = next;
(0, next["default"])({
  webpackHMR: webpackHMR
}).then(function (_ref) {
  var emitter = _ref.emitter,
      renderCtx = _ref.renderCtx,
      render = _ref.render;
  (0, _onDemandEntriesClient["default"])({
    assetPrefix: prefix
  });
  if (true) (0, _devBuildWatcher["default"])();

  if ( true && // disable by default in electron
  !(typeof process !== 'undefined' && 'electron' in process.versions)) {
    (0, _prerenderIndicator["default"])();
  } // delay rendering until after styles have been applied in development


  (0, _fouc.displayContent)(function () {
    render(renderCtx);
  });
})["catch"](function (err) {
  console.error('Error was not caught', err);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _isDynamic = __webpack_require__(/*! ./../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./../next-server/lib/router/utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./../next-server/lib/router/utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _router = __webpack_require__(/*! ./../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

function hasRel(rel, link) {
  try {
    link = document.createElement('link');
    return link.relList.supports(rel);
  } catch (_unused) {}
}

var relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload
// macOS and iOS (Safari does not support prefetch)
'preload' : // https://caniuse.com/#feat=link-rel-prefetch
// IE 11, Edge 12+, nearly all evergreen
'prefetch';
var hasNoModule = ('noModule' in document.createElement('script'));
/** @param {string} route */

function normalizeRoute(route) {
  if (route[0] !== '/') {
    throw new Error("Route name should start with a \"/\", got \"".concat(route, "\""));
  }

  route = route.replace(/\/index$/, '/');
  if (route === '/') return route;
  return route.replace(/\/$/, '');
}

function appendLink(href, rel, as) {
  return new Promise(function (res, rej, link) {
    link = document.createElement('link');
    link.crossOrigin = undefined;
    link.href = href;
    link.rel = rel;
    if (as) link.as = as;
    link.onload = res;
    link.onerror = rej;
    document.head.appendChild(link);
  });
}

var PageLoader = /*#__PURE__*/function () {
  function PageLoader(buildId, assetPrefix) {
    _classCallCheck(this, PageLoader);

    this.buildId = buildId;
    this.assetPrefix = assetPrefix;
    this.pageCache = {};
    this.pageRegisterEvents = (0, _mitt["default"])();
    this.loadingRoutes = {};

    if (false) {}
    /** @type {Promise<Set<string>>} */


    this.promisedSsgManifest = new Promise(function (resolve) {
      if (window.__SSG_MANIFEST) {
        resolve(window.__SSG_MANIFEST);
      } else {
        window.__SSG_MANIFEST_CB = function () {
          resolve(window.__SSG_MANIFEST);
        };
      }
    });
  } // Returns a promise for the dependencies for a particular route


  _createClass(PageLoader, [{
    key: "getDependencies",
    value: function getDependencies(route) {
      var _this = this;

      return this.promisedBuildManifest.then(function (man) {
        return man[route] && man[route].map(function (url) {
          return "".concat(_this.assetPrefix, "/_next/").concat(encodeURI(url));
        }) || [];
      });
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "getDataHref",
    value: function getDataHref(href, asPath) {
      var _this2 = this;

      var getHrefForSlug =
      /** @type string */
      function getHrefForSlug(path) {
        path = (0, _router.delBasePath)(path);
        return "".concat(_this2.assetPrefix, "/_next/data/").concat(_this2.buildId).concat(path === '/' ? '/index' : path, ".json");
      };

      var _ref = (0, _url.parse)(href, true),
          hrefPathname = _ref.pathname,
          query = _ref.query;

      var _ref2 = (0, _url.parse)(asPath),
          asPathname = _ref2.pathname;

      var route = normalizeRoute(hrefPathname);
      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),
          interpolatedRoute;

      if (isDynamic) {
        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
        var dynamicGroups = dynamicRegex.groups;
        var dynamicMatches = // Try to match the dynamic route against the asPath
        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query;
        interpolatedRoute = route;

        if (!Object.keys(dynamicGroups).every(function (param) {
          var value = dynamicMatches[param];
          var repeat = dynamicGroups[param].repeat; // support single-level catch-all
          // TODO: more robust handling for user-error (passing `/`)

          if (repeat && !Array.isArray(value)) value = [value];
          return param in dynamicMatches && ( // Interpolate group into data URL if present
          interpolatedRoute = interpolatedRoute.replace("[".concat(repeat ? '...' : '').concat(param, "]"), repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));
        })) {
          interpolatedRoute = ''; // did not satisfy all requirements
          // n.b. We ignore this error because we handle warning for this case in
          // development in the `<Link>` component directly.
        }
      }

      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "prefetchData",
    value: function prefetchData(href, asPath) {
      var _this3 = this;

      var _ref3 = (0, _url.parse)(href, true),
          hrefPathname = _ref3.pathname;

      var route = normalizeRoute(hrefPathname);
      return this.promisedSsgManifest.then(function (s, _dataHref) {
        return (// Check if the route requires a data file
          s.has(route) && ( // Try to generate data href, noop when falsy
          _dataHref = _this3.getDataHref(href, asPath)) && // noop when data has already been prefetched (dedupe)
          !document.querySelector("link[rel=\"".concat(relPrefetch, "\"][href^=\"").concat(_dataHref, "\"]")) && // Inject the `<link rel=prefetch>` tag for above computed `href`.
          appendLink(_dataHref, relPrefetch, 'fetch')
        );
      });
    }
  }, {
    key: "loadPage",
    value: function loadPage(route) {
      return this.loadPageScript(route);
    }
  }, {
    key: "loadPageScript",
    value: function loadPageScript(route) {
      var _this4 = this;

      route = normalizeRoute(route);
      return new Promise(function (resolve, reject) {
        var fire = function fire(_ref4) {
          var error = _ref4.error,
              page = _ref4.page,
              mod = _ref4.mod;

          _this4.pageRegisterEvents.off(route, fire);

          delete _this4.loadingRoutes[route];

          if (error) {
            reject(error);
          } else {
            resolve({
              page: page,
              mod: mod
            });
          }
        }; // If there's a cached version of the page, let's use it.


        var cachedPage = _this4.pageCache[route];

        if (cachedPage) {
          var error = cachedPage.error,
              page = cachedPage.page,
              mod = cachedPage.mod;
          error ? reject(error) : resolve({
            page: page,
            mod: mod
          });
          return;
        } // Register a listener to get the page


        _this4.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it
        // rather downloading it again.


        if (document.querySelector("script[data-next-page=\"".concat(route, "\"]"))) {
          return;
        }

        if (!_this4.loadingRoutes[route]) {
          _this4.loadingRoutes[route] = true;

          if (false) {} else {
            _this4.loadRoute(route);
          }
        }
      });
    }
  }, {
    key: "loadRoute",
    value: function loadRoute(route) {
      route = normalizeRoute(route);
      var scriptRoute = route === '/' ? '/index.js' : "".concat(route, ".js");
      var url = "".concat(this.assetPrefix, "/_next/static/").concat(encodeURIComponent(this.buildId), "/pages").concat(encodeURI(scriptRoute));
      this.loadScript(url, route, true);
    }
  }, {
    key: "loadScript",
    value: function loadScript(url, route, isPage) {
      var _this5 = this;

      var script = document.createElement('script');

      if (false) {}

      script.crossOrigin = undefined;
      script.src = url;

      script.onerror = function () {
        var error = new Error("Error loading script ".concat(url));
        error.code = 'PAGE_LOAD_ERROR';

        _this5.pageRegisterEvents.emit(route, {
          error: error
        });
      };

      document.body.appendChild(script);
    } // This method if called by the route code.

  }, {
    key: "registerPage",
    value: function registerPage(route, regFn) {
      var _this6 = this;

      var register = function register() {
        try {
          var mod = regFn();
          var pageData = {
            page: mod["default"] || mod,
            mod: mod
          };
          _this6.pageCache[route] = pageData;

          _this6.pageRegisterEvents.emit(route, pageData);
        } catch (error) {
          _this6.pageCache[route] = {
            error: error
          };

          _this6.pageRegisterEvents.emit(route, {
            error: error
          });
        }
      };

      if (true) {
        // Wait for webpack to become idle if it's not.
        // More info: https://github.com/vercel/next.js/pull/1511
        if ( true && module.hot.status() !== 'idle') {
          console.log("Waiting for webpack to become \"idle\" to initialize the page: \"".concat(route, "\""));

          var check = function check(status) {
            if (status === 'idle') {
              module.hot.removeStatusHandler(check);
              register();
            }
          };

          module.hot.status(check);
          return;
        }
      }

      register();
    }
    /**
    * @param {string} route
    * @param {boolean} [isDependency]
    */

  }, {
    key: "prefetch",
    value: function prefetch(route, isDependency) {
      var _this7 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }
      /** @type {string} */


      var url;

      if (isDependency) {
        url = route;
      } else {
        route = normalizeRoute(route);
        var scriptRoute = "".concat(route === '/' ? '/index' : route, ".js");

        if (false) {}

        url = "".concat(this.assetPrefix, "/_next/static/").concat(encodeURIComponent(this.buildId), "/pages").concat(encodeURI(scriptRoute));
      }

      return Promise.all(document.querySelector("link[rel=\"".concat(relPrefetch, "\"][href^=\"").concat(url, "\"], script[data-next-page=\"").concat(route, "\"]")) ? [] : [appendLink(url, relPrefetch, url.match(/\.css$/) ? 'style' : 'script'),  false && false]).then( // do not return any data
      function () {}, // swallow prefetch errors
      function () {});
    }
  }]);

  return PageLoader;
}();

exports["default"] = PageLoader;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var _webVitals = __webpack_require__(/*! web-vitals */ "./node_modules/web-vitals/dist/web-vitals.es5.min.js");

var _default = function _default(onPerfEntry) {
  (0, _webVitals.getCLS)(onPerfEntry);
  (0, _webVitals.getFID)(onPerfEntry);
  (0, _webVitals.getFCP)(onPerfEntry);
  (0, _webVitals.getLCP)(onPerfEntry);
  (0, _webVitals.getTTFB)(onPerfEntry);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: ".concat(eventField)); // tslint:disable-next-line:no-console

          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, module) {module.exports = function (e, r) {
  "use strict";

  var t = {};

  function __webpack_require__(r) {
    if (t[r]) {
      return t[r].exports;
    }

    var n = t[r] = {
      i: r,
      l: false,
      exports: {}
    };
    e[r].call(n.exports, n, n.exports, __webpack_require__);
    n.l = true;
    return n.exports;
  }

  __webpack_require__.ab = __dirname + "/";

  function startup() {
    return __webpack_require__(855);
  }

  return startup();
}({
  849: function _(e) {
    "use strict";

    e.exports = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onlyFirst = _ref.onlyFirst,
          e = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

      var r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  },
  855: function _(e, r, t) {
    "use strict";

    var n = t(849);

    e.exports = function (e) {
      return typeof e === "string" ? e.replace(n(), "") : e;
    };
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, "/", __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = _react["default"].createContext(null);

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = _react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports["default"] = void 0;

var _url2 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function addBasePath(path) {
  return path.indexOf(basePath) !== 0 ? basePath + path : path;
}

function delBasePath(path) {
  return path.indexOf(basePath) === 0 ? path.substr(basePath.length) || '/' : path;
}

function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

var prepareRoute = function prepareRoute(path) {
  return toRoute(!path || path === '/' ? '/index' : path);
};

function fetchNextData(pathname, query, isServerRender, cb) {
  var attempts = isServerRender ? 3 : 1;

  function getResponse() {
    return fetch((0, _utils.formatWithValidation)({
      pathname: addBasePath( // @ts-ignore __NEXT_DATA__
      "/_next/data/".concat(__NEXT_DATA__.buildId).concat(delBasePath(pathname), ".json")),
      query: query
    }), {
      // Cookies are required to be present for Next.js' SSG "Preview Mode".
      // Cookies may also be required for `getServerSideProps`.
      //
      // > `fetch` won’t send cookies, unless you set the credentials init
      // > option.
      // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      //
      // > For maximum browser compatibility when it comes to sending &
      // > receiving cookies, always supply the `credentials: 'same-origin'`
      // > option instead of relying on the default.
      // https://github.com/github/fetch#caveats
      credentials: 'same-origin'
    }).then(function (res) {
      if (!res.ok) {
        if (--attempts > 0 && res.status >= 500) {
          return getResponse();
        }

        throw new Error("Failed to load static props");
      }

      return res.json();
    });
  }

  return getResponse().then(function (data) {
    return cb ? cb(data) : data;
  })["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      ;
      err.code = 'PAGE_LOAD_ERROR';
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as2, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;

    this.onPopState = function (e) {
      if (!e.state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var pathname = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: pathname,
          query: query
        }), (0, _utils.getURL)());

        return;
      } // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (e.state && _this.isSsr && e.state.as === _this.asPath && (0, _url2.parse)(e.state.url).pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(e.state)) {
        return;
      }

      var _e$state = e.state,
          url = _e$state.url,
          as = _e$state.as,
          options = _e$state.options;

      if (true) {
        if (typeof url === 'undefined' || typeof as === 'undefined') {
          console.warn('`popstate` event triggered but `event.state` did not have `url` or `as` https://err.sh/vercel/next.js/popstate-state-empty');
        }
      }

      _this.replace(url, as, options);
    };

    this._getStaticData = function (asPath) {
      var pathname = prepareRoute((0, _url2.parse)(asPath).pathname);
      return  false ? undefined : fetchNextData(pathname, null, _this.isSsr, function (data) {
        return _this.sdc[pathname] = data;
      });
    };

    this._getServerData = function (asPath) {
      var _ref2 = (0, _url2.parse)(asPath, true),
          pathname = _ref2.pathname,
          query = _ref2.query;

      pathname = prepareRoute(pathname);
      return fetchNextData(pathname, query, _this.isSsr);
    }; // represents the current component key


    this.route = toRoute(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as2;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as2.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: _pathname,
          query: _query
        }), _as2);
      }

      window.addEventListener('popstate', this.onPopState);
    }
  } // @deprecated backwards compatibility even though it's a private method.


  _createClass(Router, [{
    key: "update",
    value: function update(route, mod) {
      var Component = mod["default"] || mod;
      var data = this.components[route];

      if (!data) {
        throw new Error("Cannot update unavailable route: ".concat(route));
      }

      var newData = Object.assign({}, data, {
        Component: Component,
        __N_SSG: mod.__N_SSG,
        __N_SSP: mod.__N_SSP
      });
      this.components[route] = newData; // pages/_app.js updated

      if (route === '/_app') {
        this.notify(this.components[this.route]);
        return;
      }

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function change(method, _url, _as, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!options._h) {
          _this2.isSsr = false;
        } // marking route changes as a navigation start entry


        if (_utils.ST) {
          performance.mark('routeChange');
        } // If url and as provided as an object representation,
        // we'll format them into the string version here.


        var url = typeof _url === 'object' ? (0, _utils.formatWithValidation)(_url) : _url;
        var as = typeof _as === 'object' ? (0, _utils.formatWithValidation)(_as) : _as;
        url = addBasePath(url);
        as = addBasePath(as); // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly for the SSR page.

        if (false) { var rewriteUrlForNextExport; }

        _this2.abortComponentLoad(as); // If the url change is only related to a hash change
        // We should not proceed. We should only change the state.
        // WARNING: `_h` is an internal option for handing Next.js client-side
        // hydration. Your app should _never_ use this property. It may change at
        // any time without notice.


        if (!options._h && _this2.onlyAHashChange(as)) {
          _this2.asPath = as;
          Router.events.emit('hashChangeStart', as);

          _this2.changeState(method, url, as, options);

          _this2.scrollToHash(as);

          Router.events.emit('hashChangeComplete', as);
          return resolve(true);
        }

        var _ref3 = (0, _url2.parse)(url, true),
            pathname = _ref3.pathname,
            query = _ref3.query,
            protocol = _ref3.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return resolve(false);
        } // If asked to change the current URL we should reload the current page
        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
        // We also need to set the method = replaceState always
        // as this should not go into the history (That's how browsers work)
        // We should compare the new asPath to the current asPath, not the url


        if (!_this2.urlIsNew(as)) {
          method = 'replaceState';
        }

        var route = toRoute(pathname);
        var _options$shallow = options.shallow,
            shallow = _options$shallow === void 0 ? false : _options$shallow;

        if ((0, _isDynamic.isDynamicRoute)(route)) {
          var _ref4 = (0, _url2.parse)(as),
              asPathname = _ref4.pathname;

          var routeRegex = (0, _routeRegex.getRouteRegex)(route);
          var routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);

          if (!routeMatch) {
            var missingParams = Object.keys(routeRegex.groups).filter(function (param) {
              return !query[param];
            });

            if (missingParams.length > 0) {
              if (true) {
                console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
              }

              return reject(new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/vercel/next.js/incompatible-href-as"));
            }
          } else {
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);
          }
        }

        Router.events.emit('routeChangeStart', as); // If shallow is true and the route exists in the router cache we reuse the previous result

        _this2.getRouteInfo(route, pathname, query, as, shallow).then(function (routeInfo) {
          var error = routeInfo.error;

          if (error && error.cancelled) {
            return resolve(false);
          }

          Router.events.emit('beforeHistoryChange', as);

          _this2.changeState(method, url, as, options);

          if (true) {
            var appComp = _this2.components['/_app'].Component;
            window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
          }

          _this2.set(route, pathname, query, as, routeInfo).then(function () {
            if (error) {
              Router.events.emit('routeChangeError', error, as);
              throw error;
            }

            Router.events.emit('routeChangeComplete', as);
            return resolve(true);
          });
        }, reject);
      });
    }
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        window.history[method]({
          url: url,
          as: as,
          options: options
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "getRouteInfo",
    value: function getRouteInfo(route, pathname, query, as) {
      var _this3 = this;

      var shallow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var cachedRouteInfo = this.components[route]; // If there is a shallow route transition possible
      // If the route is already rendered on the screen.

      if (shallow && cachedRouteInfo && this.route === route) {
        return Promise.resolve(cachedRouteInfo);
      }

      var handleError = function handleError(err, loadErrorFail) {
        return new Promise(function (resolve) {
          if (err.code === 'PAGE_LOAD_ERROR' || loadErrorFail) {
            // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.
            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So, we need to mark it as a cancelled error and stop the routing logic.

            err.cancelled = true; // @ts-ignore TODO: fix the control flow here

            return resolve({
              error: err
            });
          }

          if (err.cancelled) {
            // @ts-ignore TODO: fix the control flow here
            return resolve({
              error: err
            });
          }

          resolve(_this3.fetchComponent('/_error').then(function (res) {
            var Component = res.page;
            var routeInfo = {
              Component: Component,
              err: err
            };
            return new Promise(function (resolve) {
              _this3.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              }).then(function (props) {
                routeInfo.props = props;
                routeInfo.error = err;
                resolve(routeInfo);
              }, function (gipErr) {
                console.error('Error in error page `getInitialProps`: ', gipErr);
                routeInfo.error = err;
                routeInfo.props = {};
                resolve(routeInfo);
              });
            });
          })["catch"](function (err) {
            return handleError(err, true);
          }));
        });
      };

      return new Promise(function (resolve, reject) {
        if (cachedRouteInfo) {
          return resolve(cachedRouteInfo);
        }

        _this3.fetchComponent(route).then(function (res) {
          return resolve({
            Component: res.page,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          });
        }, reject);
      }).then(function (routeInfo) {
        var Component = routeInfo.Component,
            __N_SSG = routeInfo.__N_SSG,
            __N_SSP = routeInfo.__N_SSP;

        if (true) {
          var _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"),
              isValidElementType = _require.isValidElementType;

          if (!isValidElementType(Component)) {
            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
          }
        }

        return _this3._getData(function () {
          return __N_SSG ? _this3._getStaticData(as) : __N_SSP ? _this3._getServerData(as) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
          {
            pathname: pathname,
            query: query,
            asPath: as
          });
        }).then(function (props) {
          routeInfo.props = props;
          _this3.components[route] = routeInfo;
          return routeInfo;
        });
      })["catch"](handleError);
    }
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function prefetch(url) {
      var _this4 = this;

      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        var _ref5 = (0, _url2.parse)(url),
            pathname = _ref5.pathname,
            protocol = _ref5.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return;
        } // Prefetch is not supported in development mode because it would trigger on-demand-entries


        if (true) {
          return;
        }

        var route = delBasePath(toRoute(pathname));
        Promise.all([_this4.pageLoader.prefetchData(url, delBasePath(asPath)), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]).then(function () {
          return resolve();
        }, reject);
      });
    }
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                route = delBasePath(route);
                _context.next = 5;
                return this.pageLoader.loadPage(route);

              case 5:
                componentResult = _context.sent;

                if (!cancelled) {
                  _context.next = 10;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 10:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context.abrupt("return", componentResult);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchComponent(_x) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        var e = new Error('Route Cancelled');
        e.cancelled = true;
        Router.events.emit('routeChangeError', e, as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }], [{
    key: "_rewriteUrlForNextExport",
    value: function _rewriteUrlForNextExport(url) {
      if (false) { var rewriteUrlForNextExport; } else {
        return url;
      }
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function getRouteRegex(normalizedRoute) {
  // Escape all characters that could be considered RegEx
  var escapedRoute = escapeRegex(normalizedRoute.replace(/\/$/, '') || '/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = escapedRoute.replace(/\/\\\[([^/]+?)\\\](?=\/|$)/g, function (_, $1) {
    var isOptional = /^\\\[.*\\\]$/.test($1);

    if (isOptional) {
      $1 = $1.slice(2, -2);
    }

    var isCatchAll = /^(\\\.){3}/.test($1);

    if (isCatchAll) {
      $1 = $1.slice(6);
    }

    groups[$1 // Un-escape key
    .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1') // eslint-disable-next-line no-sequences
    ] = {
      pos: groupIndex++,
      repeat: isCatchAll
    };
    return isCatchAll ? isOptional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
  });
  var namedParameterizedRoute; // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
    groups: groups,
    namedRegex: namedParameterizedRoute ? "^".concat(namedParameterizedRoute, "(?:/)?$") : undefined
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/runtime-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/runtime-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.setConfig = setConfig;
exports["default"] = void 0;
var runtimeConfig;

var _default = function _default() {
  return runtimeConfig;
};

exports["default"] = _default;

function setConfig(configValue) {
  runtimeConfig = configValue;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) === null || _App$prototype === void 0 ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url, options) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _url.format)(url, options);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/platform/platform.js":
/*!*******************************************!*\
  !*** ./node_modules/platform/platform.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation 3',
      'PlayStation 4',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (true) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return platform;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!***********************************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference dll_a0ea8196e869b9b4425e ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_a0ea8196e869b9b4425e */ "dll-reference dll_a0ea8196e869b9b4425e"))("./node_modules/react-dom/index.js");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*******************************************************************************************!*\
  !*** delegated ./node_modules/react/index.js from dll-reference dll_a0ea8196e869b9b4425e ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_a0ea8196e869b9b4425e */ "dll-reference dll_a0ea8196e869b9b4425e"))("./node_modules/react/index.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}




/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js");

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/web-vitals/dist/web-vitals.es5.min.js":
/*!************************************************************!*\
  !*** ./node_modules/web-vitals/dist/web-vitals.es5.min.js ***!
  \************************************************************/
/*! exports provided: getCLS, getFCP, getFID, getLCP, getTTFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCLS", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFCP", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFID", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLCP", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTTFB", function() { return h; });
var t,n,e=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},i=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:t,value:n,delta:0,entries:[],id:e(),isFinal:!1}},a=function(t,n){try{if(PerformanceObserver.supportedEntryTypes.includes(t)){var e=new PerformanceObserver((function(t){return t.getEntries().map(n)}));return e.observe({type:t,buffered:!0}),e}}catch(t){}},r=!1,o=!1,s=function(t){r=!t.persisted},u=function(){addEventListener("pagehide",s),addEventListener("unload",(function(){}))},c=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];o||(u(),o=!0),addEventListener("visibilitychange",(function(n){var e=n.timeStamp;"hidden"===document.visibilityState&&t({timeStamp:e,isUnloading:r})}),{capture:!0,once:n})},l=function(t,n,e,i){var a;return function(){e&&n.isFinal&&e.disconnect(),n.value>=0&&(i||n.isFinal||"hidden"===document.visibilityState)&&(n.delta=n.value-(a||0),(n.delta||n.isFinal||void 0===a)&&(t(n),a=n.value))}},p=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("CLS",0),r=function(t){t.hadRecentInput||(e.value+=t.value,e.entries.push(t),s())},o=a("layout-shift",r),s=l(t,e,o,n);c((function(t){var n=t.isUnloading;o&&o.takeRecords().map(r),n&&(e.isFinal=!0),s()}))},d=function(){return void 0===t&&(t="hidden"===document.visibilityState?0:1/0,c((function(n){var e=n.timeStamp;return t=e}),!0)),{get timeStamp(){return t}}},m=function(t){var n=i("FCP"),e=d(),r=a("paint",(function(t){"first-contentful-paint"===t.name&&t.startTime<e.timeStamp&&(n.value=t.startTime,n.isFinal=!0,n.entries.push(t),o())})),o=l(t,n,r)},v=function(t){var n=i("FID"),e=d(),r=function(t){t.startTime<e.timeStamp&&(n.value=t.processingStart-t.startTime,n.entries.push(t),n.isFinal=!0,s())},o=a("first-input",r),s=l(t,n,o);c((function(){o&&(o.takeRecords().map(r),o.disconnect())}),!0),o||window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay((function(t,i){i.timeStamp<e.timeStamp&&(n.value=t,n.isFinal=!0,n.entries=[{entryType:"first-input",name:i.type,target:i.target,cancelable:i.cancelable,startTime:i.timeStamp,processingStart:i.timeStamp+t}],s())}))},f=function(){return n||(n=new Promise((function(t){return["scroll","keydown","pointerdown"].map((function(n){addEventListener(n,t,{once:!0,passive:!0,capture:!0})}))}))),n},g=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("LCP"),r=d(),o=function(t){var n=t.startTime;n<r.timeStamp?(e.value=n,e.entries.push(t)):e.isFinal=!0,u()},s=a("largest-contentful-paint",o),u=l(t,e,s,n),p=function(){e.isFinal||(s&&s.takeRecords().map(o),e.isFinal=!0,u())};f().then(p),c(p,!0)},h=function(t){var n,e=i("TTFB");n=function(){try{var n=performance.getEntriesByType("navigation")[0]||function(){var t=performance.timing,n={entryType:"navigation",startTime:0};for(var e in t)"navigationStart"!==e&&"toJSON"!==e&&(n[e]=Math.max(t[e]-t.navigationStart,0));return n}();e.value=e.delta=n.responseStart,e.entries=[n],e.isFinal=!0,t(e)}catch(t){}},"complete"===document.readyState?setTimeout(n,0):addEventListener("pageshow",n)};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "dll-reference dll_a0ea8196e869b9b4425e":
/*!*******************************************!*\
  !*** external "dll_a0ea8196e869b9b4425e" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = dll_a0ea8196e869b9b4425e;

/***/ })

},[["./node_modules/next/dist/client/next-dev.js","static/runtime/webpack.js"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvRXJyb3JCb3VuZGFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL0NvZGVGcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvQ29kZUZyYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nQm9keS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0NvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2dIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL3N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL0xlZnRSaWdodERpYWxvZ0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L092ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvYm9keS1sb2NrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9TaGFkb3dQb3J0YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL1Rlcm1pbmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9Ub2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L3N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9CdWlsZEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL0Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9SdW50aW1lRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvc3RhY2stZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL3N0eWxlcy9CYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0NvbXBvbmVudFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL3N0eWxlcy9Dc3NSZXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9lbGVtZW50L2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2VsZW1lbnQvZm9jdXMuc3ZnLWZvcmVpZ24tb2JqZWN0LWhhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZ2V0L3BhcmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZ2V0L3NoYWRvdy1ob3N0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2FjdGl2ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2ZvY3VzLXJlbGV2YW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL2ZvY3VzYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9pcy51dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvb25seS10YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy90YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92YWxpZC1hcmVhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL3ZhbGlkLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL3Zpc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvbWFpbnRhaW4vZGlzYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21hcC9rZXljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL29ic2VydmUvc2hhZG93LW11dGF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS9mb2N1c2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvZm9jdXNhYmxlLnF1aWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L2ZvY3VzYWJsZS5zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvc2hhZG93LWhvc3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYmJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLnNvcnQtYXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LXNoYWRvd2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3RhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc2VsZWN0b3IvZm9jdXNhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2Nzcy1zaGFkb3ctcGllcmNpbmctZGVlcC1jb21iaW5hdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2RldGVjdC1mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLWltZy10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWFyZWEtd2l0aG91dC1ocmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYnJva2VuLWltYWdlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1jaGlsZHJlbi1vZi1mb2N1c2FibGUtZmxleGJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1maWVsZHNldC1kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1maWVsZHNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1mbGV4Ym94LWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1mb3JtLWRpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWltZy1pc21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbWctdXNlbWFwLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWluLWhpZGRlbi1pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtaW4temVyby1kaW1lbnNpb24tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWludmFsaWQtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtbGFiZWwtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN2Zy1oaWRkZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN2Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1vYmplY3Qtc3dmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtcmVkaXJlY3QtbGVnZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXNjcm9sbC1ib2R5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXNjcm9sbC1jb250YWluZXItd2l0aG91dC1vdmVyZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN1bW1hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWZvY3VzYWJsZS1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWZvcmVpZ25vYmplY3QtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLWluLWlmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmctbmVnYXRpdmUtdGFiaW5kZXgtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLXVzZS10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdGFiaW5kZXgtdHJhaWxpbmctY2hhcmFjdGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2hlbHBlci9zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvZ2lmLmludmFsaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvZ2lmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL21wMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9tZWRpYS9tcDQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3N1cHBvcnRzLWNhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3N1cHBvcnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL3RhYnNlcXVlbmNlLWFyZWEtYXQtaW1nLXBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvYXJyYXktZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2NvbXBhcmUtcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9lbGVtZW50LW1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtY29udGVudC1kb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC1kb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC1mcmFtZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZ2V0LXdpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2ltYWdlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL21lcmdlLWRvbS1vcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL25vZGUtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3NlbGVjdC1pbi1zaGFkb3dzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvc29ydC1kb20tb3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90YWJpbmRleC12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3RvZ2dsZS1hdHRyaWJ1dGUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90b2dnbGUtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvd2hlbi9rZXkuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy93aGVuL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MuZXNjYXBlL2Nzcy5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25hdGl2ZS11cmwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9maW5hbGx5LXBvbHlmaWxsLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy91bmZldGNoLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L2Rldi1idWlsZC13YXRjaGVyLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9mb3JtYXQtd2VicGFjay1tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L2V2ZW50LXNvdXJjZS1wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9mb3VjLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9vbi1kZW1hbmQtZW50cmllcy11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vY2xpZW50L2Rldi9wcmVyZW5kZXItaW5kaWNhdG9yLmpzIiwid2VicGFjazovLy8uLi8uLi8uLi9jbGllbnQvZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50LmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NsaWVudC9uZXh0LWRldi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyLmpzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvcGVyZm9ybWFuY2UtcmVsYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovLy8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcnVudGltZS1jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGxhdGZvcm0vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfYTBlYTgxOTZlODY5YjliNDQyNWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtcGFyc2VyL2Rpc3Qvc3RhY2stdHJhY2UtcGFyc2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViLXZpdGFscy9kaXN0L3dlYi12aXRhbHMuZXM1Lm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlXCIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm9ubHlGaXJzdCIsInBhdHRlcm4iLCJqb2luIiwiUmVnRXhwIiwidW5kZWZpbmVkIiwic2hhZG93SG9zdCIsImRvY3VtZW50IiwicHJlZml4Iiwic2hhZG93Um9vdCIsIm1vZGUiLCJjb250YWluZXIiLCJjcmVhdGVDb250YWluZXIiLCJjc3MiLCJjcmVhdGVDc3MiLCJpc1Zpc2libGUiLCJpc0J1aWxkaW5nIiwidGltZW91dElkIiwiZXZ0U291cmNlIiwicGF0aCIsImV2ZW50IiwiaGFuZGxlTWVzc2FnZSIsIm9iaiIsIkpTT04iLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiZXZlbnRDYWxsYmFja3MiLCJsYXN0QWN0aXZpdHkiLCJsaXN0ZW5lcnMiLCJvcHRpb25zIiwiaW5pdCIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJoYW5kbGVEaXNjb25uZWN0Iiwic291cmNlIiwid2luZG93IiwiY29uc29sZSIsImkiLCJjYiIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsIkV2ZW50U291cmNlV3JhcHBlciIsImZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCIsIm1lc3NhZ2UiLCJsaW5lcyIsImxpbmUiLCJwYXJzaW5nRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJlcnJvckxpbmUiLCJpbmRleCIsImFyciIsImZvcm1hdHRlZEVycm9ycyIsImpzb24iLCJmb3JtYXRNZXNzYWdlIiwiZm9ybWF0dGVkV2FybmluZ3MiLCJyZXN1bHQiLCJlcnJvcnMiLCJ3YXJuaW5ncyIsImhhZFJ1bnRpbWVFcnJvciIsIkRldk92ZXJsYXkiLCJwcm9jZXNzTWVzc2FnZSIsInN1YnNjcmliZVRvSG1yRXZlbnQiLCJjdXN0b21IbXJFdmVudEhhbmRsZXIiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImlzRmlyc3RDb21waWxhdGlvbiIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJoYXNDb21waWxlRXJyb3JzIiwiY2xlYXJPdXRkYXRlZEVycm9ycyIsImlzSG90VXBkYXRlIiwidHJ5QXBwbHlVcGRhdGVzIiwib25GYXN0UmVmcmVzaCIsImZvcm1hdHRlZCIsInByaW50V2FybmluZ3MiLCJwcm9jZXNzIiwic2VsZiIsImUiLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImhhbmRsZUVycm9ycyIsImhhc1dhcm5pbmdzIiwiaGFuZGxlV2FybmluZ3MiLCJoYW5kbGVTdWNjZXNzIiwiY2FuQXBwbHlVcGRhdGVzIiwiZm4iLCJzdGF0dXMiLCJpc1VwZGF0ZUF2YWlsYWJsZSIsImVyciIsImhhc1VwZGF0ZXMiLCJ1cGRhdGVkTW9kdWxlcyIsIm9uSG90VXBkYXRlU3VjY2VzcyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwiUmVzcG9uc2UiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiQWJvcnRDb250cm9sbGVyIiwiVGV4dERlY29kZXJQb2x5ZmlsbCIsIm9jdGV0c0NvdW50IiwiY29kZVBvaW50IiwiYml0c05lZWRlZCIsIlJFUExBQ0VSIiwic3RyaW5nIiwib2N0ZXRzIiwib2N0ZXQiLCJ2YWxpZCIsIlN0cmluZyIsInN1cHBvcnRzU3RyZWFtT3B0aW9uIiwic3RyZWFtIiwiayIsInRoYXQiLCJ4aHIiLCJzdGF0ZSIsInRpbWVvdXQiLCJvblN0YXJ0Iiwic3RhdHVzVGV4dCIsImNvbnRlbnRUeXBlIiwib25Qcm9ncmVzcyIsInJlc3BvbnNlVGV4dCIsIm9uRmluaXNoIiwib25SZWFkeVN0YXRlQ2hhbmdlIiwib25UaW1lb3V0IiwiWE1MSHR0cFJlcXVlc3QiLCJ1cmwiLCJYSFJXcmFwcGVyIiwibmFtZSIsImMiLCJtYXAiLCJPYmplY3QiLCJhcnJheSIsImFsbCIsInBhcnRzIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsIkhlYWRlcnNQb2x5ZmlsbCIsIlhIUlRyYW5zcG9ydCIsIm9mZnNldCIsImNodW5rIiwib25Qcm9ncmVzc0NhbGxiYWNrIiwiaGVhZGVycyIsIm9uU3RhcnRDYWxsYmFjayIsIm9uRmluaXNoQ2FsbGJhY2siLCJIZWFkZXJzV3JhcHBlciIsImNvbnRyb2xsZXIiLCJzaWduYWwiLCJ0ZXh0RGVjb2RlciIsImNyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWFkZXIiLCJyZXNwb25zZSIsInJlYWROZXh0Q2h1bmsiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsIkV2ZW50VGFyZ2V0IiwidHlwZUxpc3RlbmVycyIsImxlbmd0aCIsImxpc3RlbmVyIiwidGhyb3dFcnJvciIsInR5cGUiLCJmb3VuZCIsImZpbHRlcmVkIiwiRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJDb25uZWN0aW9uRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsImZpcmUiLCJmIiwic3RhcnQiLCJpc0ZldGNoU3VwcG9ydGVkIiwiZmV0Y2giLCJpbml0aWFsUmV0cnkiLCJoZWFydGJlYXRUaW1lb3V0IiwibGFzdEV2ZW50SWQiLCJyZXRyeSIsIndhc0FjdGl2aXR5IiwiQ3VycmVudFRyYW5zcG9ydCIsInRyYW5zcG9ydCIsImNhbmNlbEZ1bmN0aW9uIiwiY3VycmVudFN0YXRlIiwiZGF0YUJ1ZmZlciIsImxhc3RFdmVudElkQnVmZmVyIiwiZXZlbnRUeXBlQnVmZmVyIiwidGV4dEJ1ZmZlciIsImZpZWxkU3RhcnQiLCJ2YWx1ZVN0YXJ0IiwiZXMiLCJ0ZXh0Q2h1bmsiLCJwb3NpdGlvbiIsImZpZWxkIiwiZGF0YSIsInJlcXVlc3RVUkwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXF1ZXN0SGVhZGVycyIsIkV2ZW50U291cmNlUG9seWZpbGwiLCJ4IiwiY2FsbGJhY2siLCJSb3V0ZXIiLCJzZXR1cFBpbmciLCJjdXJyZW50UGFnZSIsInBhdGhuYW1lIiwicGF0aG5hbWVGbiIsImNsb3NlUGluZyIsImFzc2V0UHJlZml4Iiwib25kZW1hbmQiLCJwYXlsb2FkIiwibG9jYXRpb24iLCJwYWdlUmVzIiwiZXhwYW5kRWwiLCJjbG9zZUVsIiwiZGlzbWlzc0tleSIsImRpc21pc3NVbnRpbCIsImRpc21pc3NlZCIsImV4cGFuZGVkQ2xhc3MiLCJ0b2dnbGVFeHBhbmQiLCJleHBhbmQiLCJ0b2dnbGVUaW1lb3V0Iiwib25lSG91ckF3YXkiLCJkZXZDbGllbnQiLCJwYWdlIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJhY2NlcHRDaGFyc2V0IiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImVsIiwicHJvcHMiLCJwIiwiYXR0ciIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJoZWFkRWwiLCJoZWFkQ291bnRFbCIsImhlYWRDb3VudCIsIk51bWJlciIsIm9sZFRhZ3MiLCJqIiwibmV3VGFncyIsImNvbXBvbmVudHMiLCJuZXdUYWciLCJsZW4iLCJvbGRUYWciLCJ0IiwidXBkYXRlUHJvbWlzZSIsImhlYWQiLCJwcm9taXNlIiwidGFncyIsImgiLCJ0aXRsZUNvbXBvbmVudCIsInRpdGxlIiwidXBkYXRlRWxlbWVudHMiLCJyZXF1aXJlIiwidmVyc2lvbiIsIl9fTkVYVF9WRVJTSU9OIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsImVudkNvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwicnVudGltZUNvbmZpZyIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJQYWdlTG9hZGVyIiwicmVnaXN0ZXIiLCJ1cGRhdGVIZWFkIiwiYXBwRWxlbWVudCIsImNvbXBvbmVudERpZE1vdW50Iiwicm91dGVyIiwiX2giLCJzaGFsbG93IiwiY29tcG9uZW50RGlkVXBkYXRlIiwic2Nyb2xsVG9IYXNoIiwiaGFzaCIsInJlbmRlciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiZW1pdHRlciIsIndlYnBhY2tITVIiLCJBcHAiLCJtb2QiLCJvblBlcmZFbnRyeSIsInVuaXF1ZUlEIiwiRGF0ZSIsImVudHJpZXMiLCJwZXJmU3RhcnRFbnRyeSIsImlkIiwic3RhcnRUaW1lIiwibGFiZWwiLCJlbnRyeVR5cGUiLCJpbml0aWFsRXJyIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXJyb3IiLCJub2RlIiwiZ2V0Tm9kZUVycm9yIiwiaW5pdGlhbFByb3BzIiwid3JhcEFwcCIsInN1YnNjcmlwdGlvbiIsInJlbmRlckN0eCIsInJlbmRlckVycm9yIiwiZG9SZW5kZXIiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwicXVlcnkiLCJpbml0UHJvcHMiLCJpc0luaXRpYWxSZW5kZXIiLCJSZWFjdERPTSIsInJlYWN0Um9vdCIsIlNUIiwicGVyZm9ybWFuY2UiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwibWVhc3VyZSIsIm1hcmsiLCJhcHBQcm9wcyIsImxhc3RBcHBQcm9wcyIsInJlbmRlclByb21pc2UiLCJsYXN0UmVuZGVyUmVqZWN0IiwicmVzb2x2ZVByb21pc2UiLCJlbGVtIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiX19SRVBMQUNFX05PT1BfSU1QT1JUX18iLCJfX05FWFRfREFUQV9fIiwibGluayIsInJlbFByZWZldGNoIiwiaGFzUmVsIiwiaGFzTm9Nb2R1bGUiLCJyb3V0ZSIsImNvbnN0cnVjdG9yIiwibWFuIiwiZW5jb2RlVVJJIiwiZ2V0SHJlZkZvclNsdWciLCJidWlsZElkIiwibm9ybWFsaXplUm91dGUiLCJpc0R5bmFtaWMiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsInBhcmFtIiwicmVwZWF0IiwiQXJyYXkiLCJzIiwiX2RhdGFIcmVmIiwiYXBwZW5kTGluayIsImxvYWRQYWdlIiwibG9hZFBhZ2VTY3JpcHQiLCJjYWNoZWRQYWdlIiwibG9hZFJvdXRlIiwic2NyaXB0Um91dGUiLCJsb2FkU2NyaXB0Iiwic2NyaXB0IiwicmVnRm4iLCJwYWdlRGF0YSIsImNoZWNrIiwiY24iLCJuYXZpZ2F0b3IiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiZ2V0IiwiZ2V0Um91dGVyIiwiZXZlbnRGaWVsZCIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwiX3JvdXRlciIsImluc3RhbmNlIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsInIiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibCIsImNhbGwiLCJhYiIsIl9fZGlybmFtZSIsInN0YXJ0dXAiLCJyZXBsYWNlIiwiSGVhZE1hbmFnZXJDb250ZXh0Iiwib24iLCJvZmYiLCJlbWl0IiwiaGFuZGxlciIsImJhc2VQYXRoIiwicHJlcGFyZVJvdXRlIiwidG9Sb3V0ZSIsImF0dGVtcHRzIiwiaXNTZXJ2ZXJSZW5kZXIiLCJhZGRCYXNlUGF0aCIsImRlbEJhc2VQYXRoIiwicmVzIiwiZ2V0UmVzcG9uc2UiLCJzZGMiLCJzdWIiLCJjbGMiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImZldGNoTmV4dERhdGEiLCJfX05fU1NHIiwiX19OX1NTUCIsImFzIiwibmV3RGF0YSIsInJlbG9hZCIsImNoYW5nZSIsIm1ldGhvZCIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwibWlzc2luZ1BhcmFtcyIsImFzUGF0aG5hbWUiLCJyb3V0ZUluZm8iLCJhcHBDb21wIiwiY2hhbmdlU3RhdGUiLCJnZXRSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJoYW5kbGVFcnJvciIsImdpcEVyciIsInNldCIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiY2FuY2VsbGVkIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiYWJvcnRDb21wb25lbnRMb2FkIiwibm90aWZ5IiwidXBkYXRlIiwiVEVTVF9ST1VURSIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyYW1zIiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsImVudHJ5Iiwic3RyIiwiZXNjYXBlZFJvdXRlIiwiZXNjYXBlUmVnZXgiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwiaXNPcHRpb25hbCIsIiQxIiwiaXNDYXRjaEFsbCIsInBvcyIsIm5hbWVkUmVnZXgiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsInVzZWQiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwiaHJlZiIsImdldERpc3BsYXlOYW1lIiwibG9hZEdldEluaXRpYWxQcm9wcyIsInBhZ2VQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJrZXkiLCJTUCIsImFuc2lSZWdleCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ0pBLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFvQjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUNoTmE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDN0NhOztBQUViO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMscUZBQTRCOztBQUU1RDs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRS9DOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEOzs7Ozs7Ozs7Ozs7QUN4RGE7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxtQkFBTyxDQUFDLHVEQUFXOztBQUVsQzs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRTVEOztBQUVBLHVCQUF1QixtQkFBTyxDQUFDLG1GQUEyQjs7QUFFMUQ7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsNkVBQXdCOztBQUVyRDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRTFDOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUNwR2E7O0FBRWI7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxtQkFBTyxDQUFDLHVEQUFXOztBQUVsQzs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRTVEOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLCtFQUF5Qjs7QUFFdkQ7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsNkVBQXdCOztBQUVyRDs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DOztBQUVBLHVCQUF1QixtQkFBTyxDQUFDLG1GQUEyQjs7QUFFMUQ7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWtCOztBQUUxQzs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBbUI7O0FBRTNDLFVBQVUsbUJBQU8sQ0FBQyx1REFBVzs7QUFFN0IsaUJBQWlCLG1CQUFPLENBQUMseUVBQXNCOztBQUUvQzs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxnQkFBZ0I7QUFDMUYsdURBQXVELGdCQUFnQjs7QUFFdkU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ2pvQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwREFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBVTs7Ozs7Ozs7Ozs7O0FDSHZELG9LOzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUNwTGE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7QUNOQSxnSzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsU0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Ozs7Ozs7Ozs7Ozs7QUNyQkEsMEMiLCJmaWxlIjoic3RhdGljL3J1bnRpbWUvbWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XHJcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xyXG4gICAgYXJyMltpXSA9IGFycltpXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhcnIyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XHJcblxyXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XHJcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xyXG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNlbGY7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcclxuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJlamVjdChlcnJvcik7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaW5mby5kb25lKSB7XHJcbiAgICByZXNvbHZlKHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xyXG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcclxuXHJcbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XHJcblxyXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcclxuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcclxuICAgICAgdmFyIGEgPSBbbnVsbF07XHJcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcclxuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xyXG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcclxuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcclxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gIHJldHVybiBDb25zdHJ1Y3RvcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICB9O1xyXG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxuXHJcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH1cclxuICB9KTtcclxuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xyXG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XHJcbiAgICBcImRlZmF1bHRcIjogb2JqXHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xyXG5cclxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xyXG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcclxuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNhY2hlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcclxuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBcImRlZmF1bHRcIjogb2JqXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XHJcblxyXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xyXG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5ld09iaiA9IHt9O1xyXG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XHJcblxyXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xyXG5cclxuICBpZiAoY2FjaGUpIHtcclxuICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XHJcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XHJcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XHJcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XHJcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XHJcbiAgdmFyIF9hcnIgPSBbXTtcclxuICB2YXIgX24gPSB0cnVlO1xyXG4gIHZhciBfZCA9IGZhbHNlO1xyXG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcclxuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIF9kID0gdHJ1ZTtcclxuICAgIF9lID0gZXJyO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9hcnI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XHJcblxyXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xyXG5cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICByZXR1cm4gY2FsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgby5fX3Byb3RvX18gPSBwO1xyXG4gICAgcmV0dXJuIG87XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XHJcblxyXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcclxuXHJcbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xyXG5cclxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcclxuXHJcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xyXG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcclxuXHJcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XHJcblxyXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcclxuXHJcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xyXG5cclxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xyXG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XHJcblxyXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX3R5cGVvZihvYmopO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xyXG5cclxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xyXG4gIGlmICghbykgcmV0dXJuO1xyXG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XHJcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcclxuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcclxuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcm5hbC9idXNcIikpO1xyXG52YXIgcGFyc2VTdGFja18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrXCIpO1xyXG52YXIgaXNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbnZhciBzdGFja1RyYWNlTGltaXQgPSB1bmRlZmluZWQ7XHJcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXYpIHtcclxuICAgIHZhciBlcnJvciA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5lcnJvcjtcclxuICAgIGlmICghZXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgZSA9IGVycm9yO1xyXG4gICAgQnVzLmVtaXQoe1xyXG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUixcclxuICAgICAgICByZWFzb246IGVycm9yLFxyXG4gICAgICAgIGZyYW1lczogcGFyc2VTdGFja18xLnBhcnNlU3RhY2soZS5zdGFjaylcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XHJcbiAgICB2YXIgcmVhc29uID0gZXYgPT09IG51bGwgfHwgZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2LnJlYXNvbjtcclxuICAgIGlmICghcmVhc29uIHx8XHJcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcclxuICAgICAgICB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGUgPSByZWFzb247XHJcbiAgICBCdXMuZW1pdCh7XHJcbiAgICAgICAgdHlwZTogQnVzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTixcclxuICAgICAgICByZWFzb246IHJlYXNvbixcclxuICAgICAgICBmcmFtZXM6IHBhcnNlU3RhY2tfMS5wYXJzZVN0YWNrKGUuc3RhY2spXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcigpIHtcclxuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XHJcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTA7XHJcbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcclxuZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcclxuICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaXNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgICBpZiAoc3RhY2tUcmFjZUxpbWl0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xyXG59XHJcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XHJcbmZ1bmN0aW9uIG9uQnVpbGRPaygpIHtcclxuICAgIEJ1cy5lbWl0KHsgdHlwZTogQnVzLlRZUEVfQlVJTERfT0sgfSk7XHJcbn1cclxuZXhwb3J0cy5vbkJ1aWxkT2sgPSBvbkJ1aWxkT2s7XHJcbmZ1bmN0aW9uIG9uQnVpbGRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX0VSUk9SLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xyXG59XHJcbmV4cG9ydHMub25CdWlsZEVycm9yID0gb25CdWlsZEVycm9yO1xyXG5mdW5jdGlvbiBvblJlZnJlc2goKSB7XHJcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX1JFRkZSRVNIIH0pO1xyXG59XHJcbmV4cG9ydHMub25SZWZyZXNoID0gb25SZWZyZXNoO1xyXG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lc1wiKTtcclxuZXhwb3J0cy5nZXROb2RlRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5nZXROb2RlRXJyb3I7XHJcbnZhciBSZWFjdERldk92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheVwiKTtcclxuZXhwb3J0cy5SZWFjdERldk92ZXJsYXkgPSBSZWFjdERldk92ZXJsYXlfMVtcImRlZmF1bHRcIl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRXJyb3JCb3VuZGFyeSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXJyb3JCb3VuZGFyeS5wcm90b3R5cGUuY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiAoZXJyb3IsIFxyXG4gICAgLy8gTG9vc2VseSB0eXBlZCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIFJlYWN0IHZlcnNpb24gYW5kIHdhc1xyXG4gICAgLy8gYWNjaWRlbnRhbGx5IGV4Y2x1ZGVkIGluIHNvbWUgdmVyc2lvbnMuXHJcbiAgICBlcnJvckluZm8pIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXJyb3IsIChlcnJvckluZm8gPT09IG51bGwgfHwgZXJyb3JJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHx8IG51bGwpO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IgfSk7XHJcbiAgICB9O1xyXG4gICAgRXJyb3JCb3VuZGFyeS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yXHJcbiAgICAgICAgICAgID8gLy8gVGhlIGNvbXBvbmVudCBoYXMgdG8gYmUgdW5tb3VudGVkIG9yIGVsc2UgaXQgd291bGQgY29udGludWUgdG8gZXJyb3JcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFcnJvckJvdW5kYXJ5O1xyXG59KHJlYWN0XzFbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpKTtcclxuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59O1xyXG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgQnVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2J1c1wiKSk7XHJcbnZhciBTaGFkb3dQb3J0YWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvU2hhZG93UG9ydGFsXCIpO1xyXG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xyXG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0J1aWxkRXJyb3JcIik7XHJcbnZhciBFcnJvckJvdW5kYXJ5XzEgPSByZXF1aXJlKFwiLi9FcnJvckJvdW5kYXJ5XCIpO1xyXG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XHJcbnZhciBDb21wb25lbnRTdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlcy9Db21wb25lbnRTdHlsZXNcIik7XHJcbnZhciBDc3NSZXNldF8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Nzc1Jlc2V0XCIpO1xyXG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xyXG4gICAgc3dpdGNoIChldi50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9CVUlMRF9PSzoge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX0VSUk9SOiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgQnVzLlRZUEVfUkVGRlJFU0g6IHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfRVJST1I6XHJcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IG5leHRJZDogc3RhdGUubmV4dElkICsgMSwgZXJyb3JzOiBfX3NwcmVhZChzdGF0ZS5lcnJvcnMsIFt7IGlkOiBzdGF0ZS5uZXh0SWQsIGV2ZW50OiBldiB9XSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgICAgICAgICB2YXIgXzEgPSBldjtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBSZWFjdERldk92ZXJsYXkoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgeyBuZXh0SWQ6IDEsIGJ1aWxkRXJyb3I6IG51bGwsIGVycm9yczogW10gfSksIDIpLCBzdGF0ZSA9IF9iWzBdLCBkaXNwYXRjaCA9IF9iWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBCdXMub24oZGlzcGF0Y2gpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIEJ1cy5vZmYoZGlzcGF0Y2gpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbZGlzcGF0Y2hdKTtcclxuICAgIHZhciBvbkNvbXBvbmVudEVycm9yID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRTdGFjaykge1xyXG4gICAgICAgIC8vIFRPRE86IHNwZWNpYWwgaGFuZGxpbmdcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBoYXNCdWlsZEVycm9yID0gc3RhdGUuYnVpbGRFcnJvciAhPSBudWxsO1xyXG4gICAgdmFyIGhhc1J1bnRpbWVFcnJvcnMgPSBCb29sZWFuKHN0YXRlLmVycm9ycy5sZW5ndGgpO1xyXG4gICAgdmFyIGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycztcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnlfMS5FcnJvckJvdW5kYXJ5LCB7IG9uRXJyb3I6IG9uQ29tcG9uZW50RXJyb3IgfSwgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IHZvaWQgMCA/IGNoaWxkcmVuIDogbnVsbCksXHJcbiAgICAgICAgaXNNb3VudGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhZG93UG9ydGFsXzEuU2hhZG93UG9ydGFsLCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENzc1Jlc2V0XzEuQ3NzUmVzZXQsIG51bGwpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VfMS5CYXNlLCBudWxsKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRTdHlsZXNfMS5Db21wb25lbnRTdHlsZXMsIG51bGwpLFxyXG4gICAgICAgICAgICBoYXNCdWlsZEVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnVpbGRFcnJvcl8xLkJ1aWxkRXJyb3IsIHsgbWVzc2FnZTogc3RhdGUuYnVpbGRFcnJvciB9KSkgOiBoYXNSdW50aW1lRXJyb3JzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JzXzEuRXJyb3JzLCB7IGVycm9yczogc3RhdGUuZXJyb3JzIH0pKSA6IHVuZGVmaW5lZCkpIDogdW5kZWZpbmVkKSk7XHJcbn1cclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZWFjdERldk92ZXJsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XHJcbmV4cG9ydHMuVFlQRV9CVUlMRF9FUlJPUiA9ICdidWlsZC1lcnJvcic7XHJcbmV4cG9ydHMuVFlQRV9SRUZGUkVTSCA9ICdmYXN0LXJlZnJlc2gnO1xyXG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX0VSUk9SID0gJ3VuaGFuZGxlZC1lcnJvcic7XHJcbmV4cG9ydHMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZC1yZWplY3Rpb24nO1xyXG52YXIgaGFuZGxlcnMgPSBuZXcgU2V0KCk7XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG5mdW5jdGlvbiBkcmFpbigpIHtcclxuICAgIC8vIERyYWluaW5nIHNob3VsZCBuZXZlciBoYXBwZW4gc3luY2hyb25vdXNseSBpbiBjYXNlIG11bHRpcGxlIGhhbmRsZXJzIGFyZVxyXG4gICAgLy8gcmVnaXN0ZXJlZC5cclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZXYgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKGV2KTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgLy8gVW50aWwgd2UgYXJlIG91dCBvZiBldmVudHM6XHJcbiAgICAgICAgQm9vbGVhbihxdWV1ZS5sZW5ndGgpICYmXHJcbiAgICAgICAgICAgIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxyXG4gICAgICAgICAgICAvLyBldmVudChzKVxyXG4gICAgICAgICAgICBCb29sZWFuKGhhbmRsZXJzLnNpemUpKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCAxKTtcclxufVxyXG5mdW5jdGlvbiBlbWl0KGV2KSB7XHJcbiAgICBxdWV1ZS5wdXNoKE9iamVjdC5mcmVlemUoX19hc3NpZ24oe30sIGV2KSkpO1xyXG4gICAgZHJhaW4oKTtcclxufVxyXG5leHBvcnRzLmVtaXQgPSBlbWl0O1xyXG5mdW5jdGlvbiBvbihmbikge1xyXG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVycy5hZGQoZm4pO1xyXG4gICAgZHJhaW4oKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMub24gPSBvbjtcclxuZnVuY3Rpb24gb2ZmKGZuKSB7XHJcbiAgICBpZiAoaGFuZGxlcnMuaGFzKGZuKSkge1xyXG4gICAgICAgIGhhbmRsZXJzW1wiZGVsZXRlXCJdKGZuKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLm9mZiA9IG9mZjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHN0cmlwX2Fuc2lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3RyaXAtYW5zaVwiKSk7XHJcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XHJcbmV4cG9ydHMuQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKF9hKSB7XHJcbiAgICB2YXIgc3RhY2tGcmFtZSA9IF9hLnN0YWNrRnJhbWUsIGNvZGVGcmFtZSA9IF9hLmNvZGVGcmFtZTtcclxuICAgIC8vIFN0cmlwIGxlYWRpbmcgc3BhY2VzIG91dCBvZiB0aGUgY29kZSBmcmFtZTpcclxuICAgIHZhciBmb3JtYXR0ZWRGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGNvZGVGcmFtZS5zcGxpdCgvXFxyP1xcbi9nKTtcclxuICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gbGluZXNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14+PyArXFxkKyArXFx8ICggKikvLmV4ZWMoc3RyaXBfYW5zaV8xW1wiZGVmYXVsdFwiXShsaW5lKSk7IH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5wb3AoKTsgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYywgbikgeyByZXR1cm4gKGlzTmFOKGMpID8gbi5sZW5ndGggOiBNYXRoLm1pbihjLCBuLmxlbmd0aCkpOyB9LCBOYU4pO1xyXG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHZhciBwXzEgPSAnICcucmVwZWF0KHByZWZpeExlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lc1xyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIH4oYSA9IGxpbmUuaW5kZXhPZignfCcpKVxyXG4gICAgICAgICAgICAgICAgICAgID8gbGluZS5zdWJzdHJpbmcoMCwgYSkgKyBsaW5lLnN1YnN0cmluZyhhKS5yZXBsYWNlKHBfMSwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XHJcbiAgICB9LCBbY29kZUZyYW1lXSk7XHJcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBhbnNlcl8xW1wiZGVmYXVsdFwiXS5hbnNpVG9Kc29uKGZvcm1hdHRlZEZyYW1lLCB7XHJcbiAgICAgICAgICAgIGpzb246IHRydWUsXHJcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxyXG4gICAgICAgICAgICByZW1vdmVfZW1wdHk6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xyXG4gICAgdmFyIG9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YWNrRnJhbWUpIHtcclxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzdGFja0ZyYW1lW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW3N0YWNrRnJhbWVdKTtcclxuICAgIC8vIFRPRE86IG1ha2UgdGhlIGNhcmV0IGFic29sdXRlXHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNvZGVmcmFtZVwiOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyByb2xlOiBcImxpbmtcIiwgb25DbGljazogb3BlbiwgdGFiSW5kZXg6IDEsIHRpdGxlOiBcIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShzdGFja0ZyYW1lKSxcclxuICAgICAgICAgICAgICAgIFwiIEAgXCIsXHJcbiAgICAgICAgICAgICAgICBzdGFja0ZyYW1lLm1ldGhvZE5hbWUpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiIH0pLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEwXCIsIHkxOiBcIjE0XCIsIHgyOiBcIjIxXCIsIHkyOiBcIjNcIiB9KSkpLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoclwiLCBudWxsKSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIG51bGwsIGRlY29kZWQubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGtleTogXCJmcmFtZS1cIiArIGluZGV4LCBzdHlsZTogX19hc3NpZ24oeyBjb2xvcjogZW50cnkuZmcgPyBcInZhcigtLWNvbG9yLVwiICsgZW50cnkuZmcgKyBcIilcIiA6IHVuZGVmaW5lZCB9LCAoZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2JvbGQnXHJcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cclxuICAgICAgICAgICAgICAgIDogZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2l0YWxpYydcclxuICAgICAgICAgICAgICAgICAgICA/IHsgZm9udFN0eWxlOiAnaXRhbGljJyB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4vQ29kZUZyYW1lXCIpO1xyXG5leHBvcnRzLkNvZGVGcmFtZSA9IENvZGVGcmFtZV8xLkNvZGVGcmFtZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0ge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1iZyk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWZnKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSAqIHtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gaHIge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2spO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHA6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHAgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiAxZW07XFxuICAgIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGhyIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbiAgfVxcblwiXSkpKTtcclxuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHVzZV9vbl9jbGlja19vdXRzaWRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaG9va3MvdXNlLW9uLWNsaWNrLW91dHNpZGVcIik7XHJcbnZhciBEaWFsb2cgPSBmdW5jdGlvbiBEaWFsb2coX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCB0eXBlID0gX2EudHlwZSwgb25DbG9zZSA9IF9hLm9uQ2xvc2UsIHByb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcInR5cGVcIiwgXCJvbkNsb3NlXCJdKTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShudWxsKSwgMiksIGRpYWxvZyA9IF9iWzBdLCBzZXREaWFsb2cgPSBfYlsxXTtcclxuICAgIHZhciBvbkRpYWxvZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgc2V0RGlhbG9nKG5vZGUpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdXNlX29uX2NsaWNrX291dHNpZGVfMS51c2VPbkNsaWNrT3V0c2lkZShkaWFsb2csIG9uQ2xvc2UpO1xyXG4gICAgLy8gTWFrZSBIVE1MRWxlbWVudHMgd2l0aCBgcm9sZT1saW5rYCBhY2Nlc3NpYmxlIHRvIGJlIHRyaWdnZXJlZCBieSB0aGVcclxuICAgIC8vIGtleWJvYXJkLCBpLmUuIFtFbnRlcl0uXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChkaWFsb2cgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290ID0gZGlhbG9nLmdldFJvb3ROb2RlKCk7XHJcbiAgICAgICAgLy8gQWx3YXlzIHRydWUsIGJ1dCB3ZSBkbyB0aGlzIGZvciBUeXBlU2NyaXB0OlxyXG4gICAgICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gcm9vdDtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiZcclxuICAgICAgICAgICAgICAgIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnbGluaycpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBlbC5jbGljaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTsgfTtcclxuICAgIH0sIFtkaWFsb2ddKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogb25EaWFsb2csIFwiZGF0YS1uZXh0anMtZGlhbG9nXCI6IHRydWUsIHRhYkluZGV4OiAtMSwgcm9sZTogXCJkaWFsb2dcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHNbJ2FyaWEtbGFiZWxsZWRieSddLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogcHJvcHNbJ2FyaWEtZGVzY3JpYmVkYnknXSwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOiB0cnVlLCBjbGFzc05hbWU6IFwiYmFubmVyLVwiICsgdHlwZSB9KSxcclxuICAgICAgICBjaGlsZHJlbikpO1xyXG59O1xyXG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dCb2R5ID0gZnVuY3Rpb24gRGlhbG9nQm9keShfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJvZHlcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dDb250ZW50ID0gZnVuY3Rpb24gRGlhbG9nQ29udGVudChfYSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gRGlhbG9nQ29udGVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBEaWFsb2dIZWFkZXIoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcclxufTtcclxuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi9EaWFsb2dcIik7XHJcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nXzEuRGlhbG9nO1xyXG52YXIgRGlhbG9nQm9keV8xID0gcmVxdWlyZShcIi4vRGlhbG9nQm9keVwiKTtcclxuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keV8xLkRpYWxvZ0JvZHk7XHJcbnZhciBEaWFsb2dDb250ZW50XzEgPSByZXF1aXJlKFwiLi9EaWFsb2dDb250ZW50XCIpO1xyXG5leHBvcnRzLkRpYWxvZ0NvbnRlbnQgPSBEaWFsb2dDb250ZW50XzEuRGlhbG9nQ29udGVudDtcclxudmFyIERpYWxvZ0hlYWRlcl8xID0gcmVxdWlyZShcIi4vRGlhbG9nSGVhZGVyXCIpO1xyXG5leHBvcnRzLkRpYWxvZ0hlYWRlciA9IERpYWxvZ0hlYWRlcl8xLkRpYWxvZ0hlYWRlcjtcclxudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlc18xLnN0eWxlcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1kb3VibGUpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gMy41cmVtKTtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDU3NnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDU0MHB4O1xcbiAgICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXApIHZhcigtLXNpemUtZ2FwLXF1YWQpIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA3MjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDk2MHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLXdhcm5pbmcge1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2kteWVsbG93KTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItZXJyb3Ige1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXTo6YWZ0ZXIge1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgLyogYmFubmVyIHdpZHRoOiAqL1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiBpbmhlcml0O1xcbiAgICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0ge1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgLyogY2FsYyhwYWRkaW5nICsgYmFubmVyIHdpZHRoIG9mZnNldCkgKi9cXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctaGVhZGVyXSB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctYm9keV0ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZsZXg6IDEgMSBhdXRvO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWRvdWJsZSlcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSAzLjVyZW0pO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdKSkpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBMZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBMZWZ0UmlnaHREaWFsb2dIZWFkZXIoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIG5leHQgPSBfYS5uZXh0LCBjbG9zZSA9IF9hLmNsb3NlO1xyXG4gICAgdmFyIGJ1dHRvbkxlZnQgPSBSZWFjdC51c2VSZWYoKTtcclxuICAgIHZhciBidXR0b25SaWdodCA9IFJlYWN0LnVzZVJlZigpO1xyXG4gICAgdmFyIGJ1dHRvbkNsb3NlID0gUmVhY3QudXNlUmVmKCk7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBuYXYgPSBfYlswXSwgc2V0TmF2ID0gX2JbMV07XHJcbiAgICB2YXIgb25OYXYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBzZXROYXYoZWwpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobmF2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcm9vdCA9IG5hdi5nZXRSb290Tm9kZSgpO1xyXG4gICAgICAgIHZhciBkID0gc2VsZi5kb2N1bWVudDtcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25MZWZ0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzICYmIHByZXZpb3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25SaWdodC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uUmlnaHQuY3VycmVudC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByb290LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgYSAhPT0gYnV0dG9uQ2xvc2UuY3VycmVudCAmJiBhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChyb290ICE9PSBkKSB7XHJcbiAgICAgICAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcclxuICAgICAgICAgICAgICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtjbG9zZSwgbmF2LCBuZXh0LCBwcmV2aW91c10pO1xyXG4gICAgLy8gVW5sb2NrIGZvY3VzIGZvciBicm93c2VycyBsaWtlIEZpcmVmb3gsIHRoYXQgYnJlYWsgYWxsIHVzZXIgZm9jdXMgaWYgdGhlXHJcbiAgICAvLyBjdXJyZW50bHkgZm9jdXNlZCBpdGVtIGJlY29tZXMgZGlzYWJsZWQuXHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XHJcbiAgICAgICAgLy8gQWx3YXlzIHRydWUsIGJ1dCB3ZSBkbyB0aGlzIGZvciBUeXBlU2NyaXB0OlxyXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHJvb3QuYWN0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhID09PSBidXR0b25MZWZ0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGJ1dHRvblJpZ2h0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25SaWdodC5jdXJyZW50LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtuYXYsIG5leHQsIHByZXZpb3VzXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm5hdlwiLCB7IHJlZjogb25OYXYgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uTGVmdCwgdHlwZTogXCJidXR0b25cIiwgZGlzYWJsZWQ6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBcImFyaWEtZGlzYWJsZWRcIjogcHJldmlvdXMgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IHByZXZpb3VzICE9PSBudWxsICYmIHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cyA6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHZpZXdCb3g6IFwiMCAwIDE0IDE0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvblJpZ2h0LCB0eXBlOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogbmV4dCA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCwgXCJhcmlhLWRpc2FibGVkXCI6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IHVuZGVmaW5lZCB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHZpZXdCb3g6IFwiMCAwIDE0IDE0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMTIuODMzMyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xLjE2NjYzIDYuOTk5OTlIMTJIMS4xNjY2M1pcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9KSkpLFxyXG4gICAgICAgICAgICBcIlxcdTAwQTBcIixcclxuICAgICAgICAgICAgY2hpbGRyZW4pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvbkNsb3NlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBjbG9zZSwgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2VcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCIyNFwiLCBoZWlnaHQ6IFwiMjRcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDZMNiAxOFwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2TDE4IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSkpKTtcclxufTtcclxuZXhwb3J0cy5MZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBMZWZ0UmlnaHREaWFsb2dIZWFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XHJcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyO1xyXG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4yKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246ZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC40KTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246Zmlyc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpIDAgMCB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtaGFsZikgMDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG5cXG4gICAgb3BhY2l0eTogMC40O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZTpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG5cXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmRpc2FibGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuNCk7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKSAwIDAgdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWhhbGYpIDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuXFxuICAgIG9wYWNpdHk6IDAuNDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGU6aG92ZXIge1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuXCJdKSkpO1xyXG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIGRpc2FibGVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vZGlzYWJsZWRcIikpO1xyXG52YXIgdGFiX2ZvY3VzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzXCIpKTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBib2R5X2xvY2tlcl8xID0gcmVxdWlyZShcIi4vYm9keS1sb2NrZXJcIik7XHJcbnZhciBPdmVybGF5ID0gZnVuY3Rpb24gT3ZlcmxheShfYSkge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZml4ZWQgPSBfYS5maXhlZDtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYm9keV9sb2NrZXJfMS5sb2NrKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYm9keV9sb2NrZXJfMS51bmxvY2soKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG51bGwpLCAyKSwgb3ZlcmxheSA9IF9iWzBdLCBzZXRPdmVybGF5ID0gX2JbMV07XHJcbiAgICB2YXIgb25PdmVybGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgc2V0T3ZlcmxheShlbCk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdmVybGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFuZGxlMSA9IGRpc2FibGVkXzFbXCJkZWZhdWx0XCJdKHsgZmlsdGVyOiBvdmVybGF5IH0pO1xyXG4gICAgICAgIHZhciBoYW5kbGUyID0gdGFiX2ZvY3VzXzFbXCJkZWZhdWx0XCJdKHsgY29udGV4dDogb3ZlcmxheSB9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBoYW5kbGUxLmRpc2VuZ2FnZSgpO1xyXG4gICAgICAgICAgICBoYW5kbGUyLmRpc2VuZ2FnZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbb3ZlcmxheV0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheVwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiBvbk92ZXJsYXkgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BcIjogdHJ1ZSwgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkIH0pLFxyXG4gICAgICAgIGNoaWxkcmVuKSk7XHJcbn07XHJcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xyXG52YXIgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nO1xyXG52YXIgYWN0aXZlTG9ja3MgPSAwO1xyXG5mdW5jdGlvbiBsb2NrKCkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUxvY2tzKysgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjcm9sbEJhckdhcCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHNjcm9sbEJhckdhcCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmxvY2sgPSBsb2NrO1xyXG5mdW5jdGlvbiB1bmxvY2soKSB7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYWN0aXZlTG9ja3MgPT09IDAgfHwgLS1hY3RpdmVMb2NrcyAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcclxuICAgICAgICAgICAgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcclxuICAgICAgICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5sb2NrID0gdW5sb2NrO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL092ZXJsYXlcIik7XHJcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXlfMS5PdmVybGF5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICB6LWluZGV4OiA5MDAwO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHBhZGRpbmc6IDEwdmggMTVweCAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNywgMTcsIDE3LCAwLjIpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIHJlYWN0X2RvbV8xID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcclxuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBmdW5jdGlvbiBQb3J0YWwoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgdmFyIG1vdW50Tm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcclxuICAgIHZhciBwb3J0YWxOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHNoYWRvd05vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoKSwgMiksIGZvcmNlVXBkYXRlID0gX2JbMV07XHJcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbW91bnROb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudDtcclxuICAgICAgICBwb3J0YWxOb2RlLmN1cnJlbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25leHRqcy1wb3J0YWwnKTtcclxuICAgICAgICBzaGFkb3dOb2RlLmN1cnJlbnQgPSBwb3J0YWxOb2RlLmN1cnJlbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xyXG4gICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xyXG4gICAgICAgIGZvcmNlVXBkYXRlKHt9KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocG9ydGFsTm9kZS5jdXJyZW50ICYmIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBvcnRhbE5vZGUuY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IChyZWFjdF9kb21fMS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBtb3VudE5vZGUgfSkpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBhbnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNlclwiKSk7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5leHBvcnRzLlRlcm1pbmFsID0gZnVuY3Rpb24gVGVybWluYWwoX2EpIHtcclxuICAgIHZhciBjb250ZW50ID0gX2EuY29udGVudDtcclxuICAgIHZhciBkZWNvZGVkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFuc2VyXzFbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24oY29udGVudCwge1xyXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxyXG4gICAgICAgICAgICB1c2VfY2xhc3NlczogdHJ1ZSxcclxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbY29udGVudF0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10ZXJtaW5hbFwiOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLCBkZWNvZGVkLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IFwidGVybWluYWwtZW50cnktXCIgKyBpbmRleCwgc3R5bGU6IF9fYXNzaWduKHsgY29sb3I6IGVudHJ5LmZnID8gXCJ2YXIoLS1jb2xvci1cIiArIGVudHJ5LmZnICsgXCIpXCIgOiB1bmRlZmluZWQgfSwgKGVudHJ5LmRlY29yYXRpb24gPT09ICdib2xkJ1xyXG4gICAgICAgICAgICAgICAgPyB7IGZvbnRXZWlnaHQ6IDgwMCB9XHJcbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IGZvbnRTdHlsZTogJ2l0YWxpYycgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgfSwgZW50cnkuY29udGVudCkpOyB9KSkpKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4vVGVybWluYWxcIik7XHJcbmV4cG9ydHMuVGVybWluYWwgPSBUZXJtaW5hbF8xLlRlcm1pbmFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtcclxuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxuZXhwb3J0cy5Ub2FzdCA9IGZ1bmN0aW9uIFRvYXN0KF9hKSB7XHJcbiAgICB2YXIgb25DbGljayA9IF9hLm9uQ2xpY2ssIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSwgb25DbGljazogb25DbGljaywgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXCI6IHRydWUgfSwgY2hpbGRyZW4pKSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xyXG52YXIgVG9hc3RfMSA9IHJlcXVpcmUoXCIuL1RvYXN0XCIpO1xyXG5leHBvcnRzLlRvYXN0ID0gVG9hc3RfMS5Ub2FzdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0pKSk7XHJcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcclxudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL092ZXJsYXlcIik7XHJcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVGVybWluYWxcIik7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG5leHBvcnRzLkJ1aWxkRXJyb3IgPSBmdW5jdGlvbiBCdWlsZEVycm9yKF9hKSB7XHJcbiAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XHJcbiAgICB2YXIgbm9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgfSwgW10pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXlfMS5PdmVybGF5LCB7IGZpeGVkOiB0cnVlIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2csIHsgdHlwZTogXCJlcnJvclwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiwgb25DbG9zZTogbm9vcCB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0hlYWRlciwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCIgfSwgXCJGYWlsZWQgdG8gY29tcGlsZVwiKSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0JvZHksIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUZXJtaW5hbF8xLlRlcm1pbmFsLCB7IGNvbnRlbnQ6IG1lc3NhZ2UgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBvY2N1cmVkIGR1cmluZyB0aGUgYnVpbGQgcHJvY2VzcyBhbmQgY2FuIG9ubHkgYmUgZGlzbWlzc2VkIGJ5IGZpeGluZyB0aGUgZXJyb3IuXCIpKSkpKSkpKTtcclxufTtcclxuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXIgPiBoNCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIgcCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgc21hbGwge1xcbiAgICBjb2xvcjogIzc1NzU3NTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIGJ1c18xID0gcmVxdWlyZShcIi4uL2J1c1wiKTtcclxudmFyIERpYWxvZ18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvRGlhbG9nXCIpO1xyXG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XHJcbnZhciBPdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5XCIpO1xyXG52YXIgVG9hc3RfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1RvYXN0XCIpO1xyXG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XHJcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xyXG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xyXG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XHJcbmZ1bmN0aW9uIGdldEVycm9yU2lnbmF0dXJlKGV2KSB7XHJcbiAgICB2YXIgZXZlbnQgPSBldi5ldmVudDtcclxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgYnVzXzEuVFlQRV9VTkhBTkRMRURfRVJST1I6XHJcbiAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT046IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlYXNvbi5uYW1lICsgXCI6OlwiICsgZXZlbnQucmVhc29uLm1lc3NhZ2UgKyBcIjo6XCIgKyBldmVudC5yZWFzb24uc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICB2YXIgXyA9IGV2ZW50O1xyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVycm9yQnlUeXBlKGV2KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkLCBldmVudCwgX2EsIF9iLCBfO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZXYuaWQsIGV2ZW50ID0gZXYuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBldmVudC50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9FUlJPUjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYnVzXzEuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGV2ZW50LnJlYXNvblxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhY2tfZnJhbWVfMS5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzKG5vZGVTdGFja0ZyYW1lc18xLmlzTm9kZUVycm9yKGV2ZW50LnJlYXNvbiksIGV2ZW50LmZyYW1lcyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9iLmZyYW1lcyA9IF9jLnNlbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgXyA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBzeXN0ZW0gaW52YXJpYW50IHZpb2xhdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLkVycm9ycyA9IGZ1bmN0aW9uIEVycm9ycyhfYSkge1xyXG4gICAgdmFyIGVycm9ycyA9IF9hLmVycm9ycztcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSh7fSksIDIpLCBsb29rdXBzID0gX2JbMF0sIHNldExvb2t1cHMgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IF9fcmVhZChSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVhZHkgPSBbXTtcclxuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XHJcbiAgICAgICAgLy8gRW5zdXJlIGVycm9ycyBhcmUgZGlzcGxheWVkIGluIHRoZSBvcmRlciB0aGV5IG9jY3VycmVkIGluOlxyXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGVycm9ycy5sZW5ndGg7ICsraWR4KSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3JzW2lkeF07XHJcbiAgICAgICAgICAgIHZhciBpZCA9IGUuaWQ7XHJcbiAgICAgICAgICAgIGlmIChpZCBpbiBsb29rdXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkeS5wdXNoKGxvb2t1cHNbaWRdKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZXJyb3JzXHJcbiAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGVycm9yc1tpZHggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRFcnJvclNpZ25hdHVyZShwcmV2KSA9PT0gZ2V0RXJyb3JTaWduYXR1cmUoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0ID0gZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcmVhZHksIG5leHRdO1xyXG4gICAgfSwgW2Vycm9ycywgbG9va3Vwc10pLCAyKSwgcmVhZHlFcnJvcnMgPSBfY1swXSwgbmV4dEVycm9yID0gX2NbMV07XHJcbiAgICB2YXIgaXNMb2FkaW5nID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWR5RXJyb3JzLmxlbmd0aCA8IDEgJiYgQm9vbGVhbihlcnJvcnMubGVuZ3RoKTtcclxuICAgIH0sIFtlcnJvcnMubGVuZ3RoLCByZWFkeUVycm9ycy5sZW5ndGhdKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG5leHRFcnJvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXJyb3JCeVR5cGUobmV4dEVycm9yKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGlmIHRoZSBkZXNpcmVkIGVycm9yIGNoYW5nZWQgd2hpbGUgd2Ugd2VyZSByZXNvbHZpbmcsXHJcbiAgICAgICAgICAgIC8vIHRodXMgd2UncmUgbm90IHRyYWNraW5nIGl0IHVzaW5nIGEgcmVmLiBPbmNlIHRoZSB3b3JrIGhhcyBiZWVuIGRvbmUsXHJcbiAgICAgICAgICAgIC8vIHdlJ2xsIHN0b3JlIGl0LlxyXG4gICAgICAgICAgICBzZXRMb29rdXBzKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBtKSwgKF9hID0ge30sIF9hW3Jlc29sdmVkLmlkXSA9IHJlc29sdmVkLCBfYSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgdGhpcywgdGhvdWdoIGFuIGVkZ2UgY2FzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW25leHRFcnJvcl0pO1xyXG4gICAgdmFyIF9kID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKGZhbHNlKSwgMiksIGlzTWluaW1pemVkID0gX2RbMF0sIHNldE1pbmltaXplZCA9IF9kWzFdO1xyXG4gICAgdmFyIF9lID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKDApLCAyKSwgYWN0aXZlSWR4ID0gX2VbMF0sIHNldEFjdGl2ZUluZGV4ID0gX2VbMV07XHJcbiAgICB2YXIgcHJldmlvdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLm1heCgwLCB2IC0gMSk7IH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIG5leHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWFkeUVycm9ycy5sZW5ndGggLSAxLCB2ICsgMSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW3JlYWR5RXJyb3JzLmxlbmd0aF0pO1xyXG4gICAgdmFyIGFjdGl2ZUVycm9yID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHJlYWR5RXJyb3JzW2FjdGl2ZUlkeF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7IH0sIFthY3RpdmVJZHgsIHJlYWR5RXJyb3JzXSk7XHJcbiAgICAvLyBSZXNldCBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGVyZSBhcmUgbm8gZXJyb3JzIHRvIGJlIGRpc3BsYXllZC5cclxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGxldHMgaGFuZGxlIGl0LlxyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgc2V0TG9va3Vwcyh7fSk7XHJcbiAgICAgICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUluZGV4KDApO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtlcnJvcnMubGVuZ3RoXSk7XHJcbiAgICB2YXIgbWluaW1pemUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldE1pbmltaXplZCh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciByZW9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgd2l0aCBubyBlcnJvcnMsIGJ1dCBpZiBpdCBpcywgbGV0J3NcclxuICAgIC8vIGhhbmRsZSBpdCBncmFjZWZ1bGx5IGJ5IHJlbmRlcmluZyBub3RoaW5nLlxyXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGxvYWRpbmcgc3RhdGVcclxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5XzEuT3ZlcmxheSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNNaW5pbWl6ZWQpIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9hc3RfMS5Ub2FzdCwgeyBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnRcIiwgb25DbGljazogcmVvcGVuIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibmV4dGpzLXRvYXN0LWVycm9yc1wiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjEyXCIsIGN5OiBcIjEyXCIsIHI6IFwiMTBcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjhcIiwgeDI6IFwiMTJcIiwgeTI6IFwiMTJcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjE2XCIsIHgyOiBcIjEyLjAxXCIsIHkyOiBcIjE2XCIgfSkpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgZXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzU2VydmVyRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5pc05vZGVFcnJvcihhY3RpdmVFcnJvci5lcnJvcik7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheV8xLk92ZXJsYXksIG51bGwsXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2csIHsgdHlwZTogXCJlcnJvclwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19sYWJlbFwiLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wiLCBvbkNsb3NlOiBtaW5pbWl6ZSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0hlYWRlciwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExlZnRSaWdodERpYWxvZ0hlYWRlcl8xLkxlZnRSaWdodERpYWxvZ0hlYWRlciwgeyBwcmV2aW91czogYWN0aXZlSWR4ID4gMCA/IHByZXZpb3VzIDogbnVsbCwgbmV4dDogYWN0aXZlSWR4IDwgcmVhZHlFcnJvcnMubGVuZ3RoIC0gMSA/IG5leHQgOiBudWxsLCBjbG9zZTogbWluaW1pemUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBhY3RpdmVJZHggKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG9mXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCByZWFkeUVycm9ycy5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdW5oYW5kbGVkIGVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPCAyID8gJycgOiAncycpKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIiB9LCBpc1NlcnZlckVycm9yID8gJ1NlcnZlciBFcnJvcicgOiAnVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3InKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXJyb3IuZXJyb3IubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI6IFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcnJvci5lcnJvci5tZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlckVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBoYXBwZW5lZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBwYWdlLiBBbnkgY29uc29sZSBsb2dzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0ZXJtaW5hbCB3aW5kb3cuXCIpKSkgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dCb2R5LCB7IGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJ1bnRpbWVFcnJvcl8xLlJ1bnRpbWVFcnJvciwgeyBrZXk6IGFjdGl2ZUVycm9yLmlkLnRvU3RyaW5nKCksIGVycm9yOiBhY3RpdmVFcnJvciB9KSkpKSkpO1xyXG59O1xyXG5leHBvcnRzLnN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQ6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQ6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxudmFyIHN0YWNrX2ZyYW1lXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdGFjay1mcmFtZVwiKTtcclxudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcclxuICAgIC8vIFRPRE86IGFiaWxpdHkgdG8gZXhwYW5kIHJlc29sdmVkIGZyYW1lc1xyXG4gICAgLy8gVE9ETzogcmVuZGVyIGVycm9yIG9yIGV4dGVybmFsIGluZGljYXRvclxyXG4gICAgdmFyIGZyYW1lID0gX2EuZnJhbWU7XHJcbiAgICB2YXIgX2I7XHJcbiAgICB2YXIgZiA9IChfYiA9IGZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnJhbWUuc291cmNlU3RhY2tGcmFtZTtcclxuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcclxuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcclxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBmW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcG9ydCBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW2hhc1NvdXJjZSwgZl0pO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXCI6IHRydWUgfSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgeyBcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6IEJvb2xlYW4oZnJhbWUuZXhwYW5kZWQpIH0sIGYubWV0aG9kTmFtZSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1oYXMtc291cmNlXCI6IGhhc1NvdXJjZSA/ICd0cnVlJyA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGhhc1NvdXJjZSA/IDEwIDogdW5kZWZpbmVkLCByb2xlOiBoYXNTb3VyY2UgPyAnbGluaycgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG9wZW4sIHRpdGxlOiBoYXNTb3VyY2UgPyAnQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvcicgOiB1bmRlZmluZWQgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShmKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBwb2ludHM6IFwiMTUgMyAyMSAzIDIxIDlcIiB9KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSkpKTtcclxufTtcclxudmFyIFJ1bnRpbWVFcnJvciA9IGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihfYSkge1xyXG4gICAgdmFyIGVycm9yID0gX2EuZXJyb3I7XHJcbiAgICB2YXIgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBlcnJvci5mcmFtZXMuZmluZEluZGV4KGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZXhwYW5kZWQgJiZcclxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmXHJcbiAgICAgICAgICAgICAgICBCb29sZWFuKGVudHJ5Lm9yaWdpbmFsU3RhY2tGcmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbZXJyb3IuZnJhbWVzXSk7XHJcbiAgICB2YXIgZmlyc3RGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gZXJyb3IuZnJhbWVzW2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgfSwgW2Vycm9yLmZyYW1lcywgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleF0pO1xyXG4gICAgdmFyIGFsbExlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDBcclxuICAgICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgICA6IGVycm9yLmZyYW1lcy5zbGljZSgwLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4KTtcclxuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShmaXJzdEZyYW1lID09IG51bGwpLCAyKSwgYWxsID0gX2JbMF0sIHNldEFsbCA9IF9iWzFdO1xyXG4gICAgdmFyIHRvZ2dsZUFsbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRBbGwoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBsZWFkaW5nRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxMZWFkaW5nRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxMZWFkaW5nRnJhbWVzXSk7XHJcbiAgICB2YXIgYWxsQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpOyB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XHJcbiAgICB2YXIgdmlzaWJsZUNhbGxTdGFja0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxsQ2FsbFN0YWNrRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxDYWxsU3RhY2tGcmFtZXNdKTtcclxuICAgIHZhciBjYW5TaG93TW9yZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCAhPT0gdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggfHxcclxuICAgICAgICAgICAgKGFsbCAmJiBmaXJzdEZyYW1lICE9IG51bGwpKTtcclxuICAgIH0sIFtcclxuICAgICAgICBhbGwsXHJcbiAgICAgICAgYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCxcclxuICAgICAgICBmaXJzdEZyYW1lLFxyXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXHJcbiAgICAgICAgZmlyc3RGcmFtZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJTb3VyY2VcIiksXHJcbiAgICAgICAgICAgIGxlYWRpbmdGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJsZWFkaW5nLWZyYW1lLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUZyYW1lXzEuQ29kZUZyYW1lLCB7IHN0YWNrRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLCBjb2RlRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxDb2RlRnJhbWUgfSkpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDYWxsIFN0YWNrXCIpLFxyXG4gICAgICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUsIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU3RhY2tGcmFtZSwgeyBrZXk6IFwiY2FsbC1zdGFjay1cIiArIGluZGV4ICsgXCItXCIgKyBhbGwsIGZyYW1lOiBmcmFtZSB9KSk7IH0pKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY2FuU2hvd01vcmUgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcclxuICAgICAgICAgICAgICAgIGFsbCA/ICdIaWRlJyA6ICdTaG93JyxcclxuICAgICAgICAgICAgICAgIFwiIGNvbGxhcHNlZCBmcmFtZXNcIikpKSA6IHVuZGVmaW5lZCkpO1xyXG59O1xyXG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcclxuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBidXR0b25bZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25dIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMyk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNiB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgY29sb3I6ICMyMjI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNltkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZD0nZmFsc2UnXSB7XFxuICAgIGNvbG9yOiAjNjY2O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBjb2xvcjogIzk5OTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XFxuXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcge1xcbiAgICBkaXNwbGF5OiB1bnNldDtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIHN0YWNrdHJhY2VfcGFyc2VyXzEgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1wYXJzZXJcIik7XHJcbmZ1bmN0aW9uIGdldEZpbGVzeXN0ZW1GcmFtZShmcmFtZSkge1xyXG4gICAgdmFyIGYgPSBfX2Fzc2lnbih7fSwgZnJhbWUpO1xyXG4gICAgaWYgKHR5cGVvZiBmLmZpbGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgIC8vIFBvc2l4OlxyXG4gICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCcvJykgfHxcclxuICAgICAgICAgICAgLy8gV2luMzI6XHJcbiAgICAgICAgICAgIC9eW2Etel06XFxcXC9pLnRlc3QoZi5maWxlKSB8fFxyXG4gICAgICAgICAgICAvLyBXaW4zMiBVTkM6XHJcbiAgICAgICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCdcXFxcXFxcXCcpKSB7XHJcbiAgICAgICAgICAgIGYuZmlsZSA9IFwiZmlsZTovL1wiICsgZi5maWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmO1xyXG59XHJcbmV4cG9ydHMuZ2V0RmlsZXN5c3RlbUZyYW1lID0gZ2V0RmlsZXN5c3RlbUZyYW1lO1xyXG52YXIgc3ltYm9sTm9kZUVycm9yID0gU3ltYm9sKCdOZXh0anNOb2RlRXJyb3InKTtcclxuZnVuY3Rpb24gaXNOb2RlRXJyb3IoZXJyb3IpIHtcclxuICAgIHJldHVybiBzeW1ib2xOb2RlRXJyb3IgaW4gZXJyb3I7XHJcbn1cclxuZXhwb3J0cy5pc05vZGVFcnJvciA9IGlzTm9kZUVycm9yO1xyXG5mdW5jdGlvbiBnZXROb2RlRXJyb3IoZXJyb3IpIHtcclxuICAgIHZhciBuO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIG4gPSBlO1xyXG4gICAgfVxyXG4gICAgbi5uYW1lID0gZXJyb3IubmFtZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbi5zdGFjayA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2UoZXJyb3Iuc3RhY2spXHJcbiAgICAgICAgICAgIC5tYXAoZ2V0RmlsZXN5c3RlbUZyYW1lKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIiAgICBhdCBcIiArIGYubWV0aG9kTmFtZTtcclxuICAgICAgICAgICAgaWYgKGYuZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvYyA9IGYuZmlsZTtcclxuICAgICAgICAgICAgICAgIGlmIChmLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2MgKz0gXCI6XCIgKyBmLmxpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYuY29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyArPSBcIjpcIiArIGYuY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAoXCIgKyBsb2MgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIG4uc3RhY2sgPSBlcnJvci5zdGFjaztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBzeW1ib2xOb2RlRXJyb3IsIHtcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5leHBvcnRzLmdldE5vZGVFcnJvciA9IGdldE5vZGVFcnJvcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIG5vb3Aoc3RyaW5ncykge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAga2V5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gKHN0cmluZ3Muc2xpY2UoMCwgbGFzdEluZGV4KS5yZWR1Y2UoZnVuY3Rpb24gKHAsIHMsIGkpIHsgcmV0dXJuIHAgKyBzICsga2V5c1tpXTsgfSwgJycpICtcclxuICAgICAgICBzdHJpbmdzW2xhc3RJbmRleF0pO1xyXG59XHJcbmV4cG9ydHMubm9vcCA9IG5vb3A7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgc3RhY2t0cmFjZV9wYXJzZXJfMSA9IHJlcXVpcmUoXCJzdGFja3RyYWNlLXBhcnNlclwiKTtcclxudmFyIHJlZ2V4TmV4dFN0YXRpYyA9IC9cXC9fbmV4dChcXC9zdGF0aWNcXC8uKykvZztcclxuZnVuY3Rpb24gcGFyc2VTdGFjayhzdGFjaykge1xyXG4gICAgdmFyIGZyYW1lcyA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2Uoc3RhY2spO1xyXG4gICAgcmV0dXJuIGZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChmcmFtZS5maWxlKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHJlZ2V4TmV4dFN0YXRpYy5leGVjKHVybC5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0RGlyID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU1RfRElSKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvXFxcXC9nLCAnLycpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0RGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuZmlsZSA9ICdmaWxlOi8vJyArIGRpc3REaXIuY29uY2F0KHJlcy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9jKSB7IH1cclxuICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBhcnNlU3RhY2sgPSBwYXJzZVN0YWNrO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoaXNTZXJ2ZXJTaWRlLCBmcmFtZXMpIHtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChmcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSkgeyByZXR1cm4gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGlzU2VydmVyU2lkZSwgZnJhbWUpOyB9KSk7XHJcbn1cclxuZXhwb3J0cy5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcztcclxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGlzU2VydmVyU2lkZSwgc291cmNlKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgZnVuY3Rpb24gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcywga2V5LCBjb250cm9sbGVyLCB0bSwgcmVzLCBfYywgX2QsIF9lLCBib2R5O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2lzU2VydmVyU2lkZScsIFN0cmluZyhpc1NlcnZlclNpZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHNvdXJjZVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIuYWJvcnQoKTsgfSwgMzAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbGZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmV0Y2goXCIvX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9mLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIXJlcy5vayB8fCByZXMuc3RhdHVzID09PSAyMDQpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSAoX2MgPSBQcm9taXNlKS5yZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gRXJyb3IuYmluZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLnRleHQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2QuYXBwbHkoX2MsIFtuZXcgKF9lLmFwcGx5KEVycm9yLCBbdm9pZCAwLCBfZi5zZW50KCldKSkoKV0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9mLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZDogKChfYiA9IGJvZHkub3JpZ2luYWxTdGFja0ZyYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWJvZHkub3JpZ2luYWxTdGFja0ZyYW1lLmZpbGUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IGJvZHkub3JpZ2luYWxTdGFja0ZyYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBib2R5Lm9yaWdpbmFsQ29kZUZyYW1lIHx8IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghKCgoX2EgPSBzb3VyY2UuZmlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0c1dpdGgoJ3dlYnBhY2staW50ZXJuYWw6JykpIHx8ICgoX2IgPSBzb3VyY2UuZmlsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBlcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlYXNvbjogbnVsbCxcclxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIGVycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICByZWFzb246IChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ1Vua25vd24gRXJyb3InLFxyXG4gICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmdldE9yaWdpbmFsU3RhY2tGcmFtZSA9IGdldE9yaWdpbmFsU3RhY2tGcmFtZTtcclxuZnVuY3Rpb24gZ2V0RnJhbWVTb3VyY2UoZnJhbWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBzdHIgPSAnJztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHUgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xyXG4gICAgICAgIC8vIFN0cmlwIHRoZSBvcmlnaW4gZm9yIHNhbWUtb3JpZ2luIHNjcmlwdHMuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAoKF9hID0gZ2xvYmFsVGhpcy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yaWdpbikgIT09IHUub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIC8vIFVSTHMgY2FuIGJlIHZhbGlkIHdpdGhvdXQgYW4gYG9yaWdpbmAsIHNvIGxvbmcgYXMgdGhleSBoYXZlIGFcclxuICAgICAgICAgICAgLy8gYHByb3RvY29sYC4gSG93ZXZlciwgYG9yaWdpbmAgaXMgcHJlZmVycmVkLlxyXG4gICAgICAgICAgICBpZiAodS5vcmlnaW4gPT09ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHUucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gdS5vcmlnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RyaXAgcXVlcnkgc3RyaW5nIGluZm9ybWF0aW9uIGFzIGl0J3MgdHlwaWNhbGx5IHRvbyB2ZXJib3NlIHRvIGJlXHJcbiAgICAgICAgLy8gbWVhbmluZ2Z1bC5cclxuICAgICAgICBzdHIgKz0gdS5wYXRobmFtZTtcclxuICAgICAgICBzdHIgKz0gJyAnO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9iKSB7XHJcbiAgICAgICAgc3RyICs9IChmcmFtZS5maWxlIHx8ICcodW5rbm93biknKSArICcgJztcclxuICAgIH1cclxuICAgIGlmIChmcmFtZS5saW5lTnVtYmVyICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoZnJhbWUuY29sdW1uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiOlwiICsgZnJhbWUuY29sdW1uICsgXCIpIFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiKSBcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKTtcclxufVxyXG5leHBvcnRzLmdldEZyYW1lU291cmNlID0gZ2V0RnJhbWVTb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5mdW5jdGlvbiB1c2VPbkNsaWNrT3V0c2lkZShlbCwgaGFuZGxlcikge1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY2xpY2tpbmcgcmVmJ3MgZWxlbWVudCBvciBkZXNjZW5kZW50IGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmICghZWwgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFuZGxlcihlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByb290ID0gZWwuZ2V0Um9vdE5vZGUoKTtcclxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcclxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RlbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2hhbmRsZXIsIGVsXSk7XHJcbn1cclxuZXhwb3J0cy51c2VPbkNsaWNrT3V0c2lkZSA9IHVzZU9uQ2xpY2tPdXRzaWRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcclxudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XHJcbmZ1bmN0aW9uIEJhc2UoKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XHJcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiAwLjI1cmVtOyAvKiA0cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwOiAwLjVyZW07IC8qIDhweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAycmVtOyAvKiAzMnB4ICovXFxuXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDAuODc1cmVtOyAvKiAxNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQ6IDFyZW07IC8qIDE2cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWc6IDEuMjVyZW07IC8qIDIwcHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDEuNXJlbTsgLyogMjRweCAqL1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0yOiAjMjIyMjIyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZmc6ICNjY2NjY2M7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmx1ZTogIzAwYWFmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLW1hZ2VudGE6ICNhYTg4ZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGU6ICNmZmZmZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1jeWFuOiAjYmJlY2ZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtcmVkOiAjZmY4ODg4O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC5tb25vIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgyIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDJyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDMge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDUge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiAwLjI1cmVtOyAvKiA0cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwOiAwLjVyZW07IC8qIDhweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAycmVtOyAvKiAzMnB4ICovXFxuXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDAuODc1cmVtOyAvKiAxNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQ6IDFyZW07IC8qIDE2cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWc6IDEuMjVyZW07IC8qIDIwcHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDEuNXJlbTsgLyogMjRweCAqL1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0yOiAjMjIyMjIyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZmc6ICNjY2NjY2M7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmx1ZTogIzAwYWFmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLW1hZ2VudGE6ICNhYTg4ZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGU6ICNmZmZmZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1jeWFuOiAjYmJlY2ZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtcmVkOiAjZmY4ODg4O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC5tb25vIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMi41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgyIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDJyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDMge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDUge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0pKSlcclxuICAgICAgICB9IH0pKTtcclxufVxyXG5leHBvcnRzLkJhc2UgPSBCYXNlO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0NvZGVGcmFtZS9zdHlsZXNcIik7XHJcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcclxudmFyIHN0eWxlc18yID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyL3N0eWxlc1wiKTtcclxudmFyIHN0eWxlc18zID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXNcIik7XHJcbnZhciBzdHlsZXNfNCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1Rlcm1pbmFsL3N0eWxlc1wiKTtcclxudmFyIFRvYXN0XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9Ub2FzdFwiKTtcclxudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvQnVpbGRFcnJvclwiKTtcclxudmFyIEVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9FcnJvcnNcIik7XHJcbnZhciBSdW50aW1lRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9jb250YWluZXIvUnVudGltZUVycm9yXCIpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxuZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCkge1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xyXG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICBcIl0pKSwgc3R5bGVzXzMuc3R5bGVzLCBUb2FzdF8xLnN0eWxlcywgRGlhbG9nXzEuc3R5bGVzLCBzdHlsZXNfMi5zdHlsZXMsIHN0eWxlc18xLnN0eWxlcywgc3R5bGVzXzQuc3R5bGVzLCBCdWlsZEVycm9yXzEuc3R5bGVzLCBFcnJvcnNfMS5zdHlsZXMsIFJ1bnRpbWVFcnJvcl8xLnN0eWxlcylcclxuICAgICAgICB9IH0pKTtcclxufVxyXG5leHBvcnRzLkNvbXBvbmVudFN0eWxlcyA9IENvbXBvbmVudFN0eWxlcztcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xyXG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcclxuZnVuY3Rpb24gQ3NzUmVzZXQoKSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XHJcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgYWxsOiBpbml0aWFsO1xcblxcbiAgICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBsdHI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICAqLFxcbiAgICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFydGljbGUsXFxuICAgICAgICAgIGFzaWRlLFxcbiAgICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgICBmaWd1cmUsXFxuICAgICAgICAgIGZvb3RlcixcXG4gICAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgICBoZ3JvdXAsXFxuICAgICAgICAgIG1haW4sXFxuICAgICAgICAgIG5hdixcXG4gICAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcXG4gICAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgICBmb250LXNpemU6IDFyZW07XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICAgICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGhyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEsXFxuICAgICAgICAgIGgyLFxcbiAgICAgICAgICBoMyxcXG4gICAgICAgICAgaDQsXFxuICAgICAgICAgIGg1LFxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcCB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFiYnJbdGl0bGVdLFxcbiAgICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sLFxcbiAgICAgICAgICB1bCxcXG4gICAgICAgICAgZGwge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCBvbCxcXG4gICAgICAgICAgdWwgdWwsXFxuICAgICAgICAgIG9sIHVsLFxcbiAgICAgICAgICB1bCBvbCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkdCB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYixcXG4gICAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDgwJTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIsXFxuICAgICAgICAgIHN1cCB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIge1xcbiAgICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGEge1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwNTZiMztcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOm5vdChbaHJlZl0pIHtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByZSxcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAga2JkLFxcbiAgICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWd1cmUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdmcge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG4gICAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoIHtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxhYmVsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LFxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCxcXG4gICAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICAgIHRleHRhcmVhIHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdyYWRpbyddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWVsZHNldCB7XFxuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZWdlbmQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByb2dyZXNzIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbiAgICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgICBmb250OiBpbmhlcml0O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG91dHB1dCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN1bW1hcnkge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIGFsbDogaW5pdGlhbDtcXG5cXG4gICAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8qIVxcbiAgICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUaGUgQm9vdHN0cmFwIEF1dGhvcnNcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgICAqIEZvcmtlZCBmcm9tIE5vcm1hbGl6ZS5jc3MsIGxpY2Vuc2VkIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kKVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgKixcXG4gICAgICAgICAgKjo6YmVmb3JlLFxcbiAgICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgICBhc2lkZSxcXG4gICAgICAgICAgZmlnY2FwdGlvbixcXG4gICAgICAgICAgZmlndXJlLFxcbiAgICAgICAgICBmb290ZXIsXFxuICAgICAgICAgIGhlYWRlcixcXG4gICAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgICBtYWluLFxcbiAgICAgICAgICBuYXYsXFxuICAgICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcbiAgICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgICAnTm90byBDb2xvciBFbW9qaSc7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBociB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAgICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgICAgYWJicltkYXRhLW9yaWdpbmFsLXRpdGxlXSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRyZXNzIHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCxcXG4gICAgICAgICAgdWwsXFxuICAgICAgICAgIGRsIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2wgb2wsXFxuICAgICAgICAgIHVsIHVsLFxcbiAgICAgICAgICBvbCB1bCxcXG4gICAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZHQge1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGQge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBibG9ja3F1b3RlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGIsXFxuICAgICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViIHtcXG4gICAgICAgICAgICBib3R0b206IC0wLjI1ZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VwIHtcXG4gICAgICAgICAgICB0b3A6IC0wLjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwN2JmZjtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGE6bm90KFtocmVmXSk6aG92ZXIge1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUsXFxuICAgICAgICAgIGNvZGUsXFxuICAgICAgICAgIGtiZCxcXG4gICAgICAgICAgc2FtcCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJlIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGFibGUge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aCB7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24ge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOmZvY3VzIHtcXG4gICAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dCxcXG4gICAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgICBzZWxlY3QsXFxuICAgICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIGlucHV0IHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J10sXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBib3JkZXI6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcXG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRlbXBsYXRlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFtoaWRkZW5dIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSkpKVxyXG4gICAgICAgIH0gfSkpO1xyXG59XHJcbmV4cG9ydHMuQ3NzUmVzZXQgPSBDc3NSZXNldDtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzE7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdlbGVtZW50L2Rpc2FibGVkJyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgLy8gYWNjZXB0IHRydXRoeS9mYWxzeSB2YWx1ZXNcclxuICBkaXNhYmxlZFN0YXRlID0gQm9vbGVhbihkaXNhYmxlZFN0YXRlKTtcclxuICB2YXIgY3VycmVudFN0YXRlID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpO1xyXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gdmFsdWUgdG8gc2V0LCB3ZSdyZSBydW5uaW5nIGFzIGEgZ2V0dGVyXHJcbiAgdmFyIHJ1bm5pbmdBc0dldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcblxyXG4gIGlmICgoMCwgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgaWYgKHJ1bm5pbmdBc0dldHRlcikge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3JtIGVsZW1lbnRzIGtub3cgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgd2hpY2ggd2Ugc2hhbGwgdXNlIGluc3RlYWQgb2Ygb3VyIHBvb3IgbWFuJ3MgY29weSBvZiBpdFxyXG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRpc2FibGVkU3RhdGU7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmIChydW5uaW5nQXNHZXR0ZXIpIHtcclxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoY3VycmVudFN0YXRlID09PSBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgICAvLyBubyB1cGRhdGUgbmVjZXNzYXJ5XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIHNldEVsZW1lbnREaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkID0gcmVxdWlyZSgnLi4vaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcpO1xyXG5cclxudmFyIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZCk7XHJcblxyXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZScpO1xyXG5cclxudmFyIF90b2dnbGVBdHRyaWJ1dGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlKTtcclxuXHJcbnZhciBfdG9nZ2xlQXR0cmlidXRlVmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RvZ2dsZS1hdHRyaWJ1dGUtdmFsdWUnKTtcclxuXHJcbnZhciBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlVmFsdWUpO1xyXG5cclxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuLi91dGlsL2xvZ2dlcicpO1xyXG5cclxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcbi8qXHJcbiAgVXRpbGl0eSB0byBtYWtlIGFueSBlbGVtZW50IGluZXJ0IChkaXNhYmxlZCkuIEluZXJ0IG1lYW5zIHRoZSBlbGVtZW50cyBjYW5ub3QgYmUgaW50ZXJhY3RlZFxyXG4gIHdpdGggYW5kIHRoZXkgY2Fubm90IGJlIGZvY3VzZWQgdmlhIHNjcmlwdCwgcG9pbnRlciBvciBrZXlib2FyZCAtIGFuZCB0aHVzIG5vdCByZWNlaXZlIGZvY3VzLlxyXG5cclxuICBFbGVtZW50cyBtYWRlIGluZXJ0IChkaXNhYmxlZCkgYnkgdGhpcyB1dGlsaXR5IGFyZSBnaXZlbiB0aGUgYXR0cmlidXRlIFtkYXRhLWFsbHktZGlzYWJsZWQ9XCJ0cnVlXCJdLlxyXG5cclxuICAtLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgaW5lcnQgYXR0cmlidXRlIHdhcyBbcmVtb3ZlZF0oaHR0cHM6Ly9odG1sNS5vcmcvci84NTM2KSBbdHdlZXQgYnkgc3RldmVdKGh0dHBzOi8vdHdpdHRlci5jb20vc3RldmVmYXVsa25lci9zdGF0dXMvNDQzMDc1OTAwMjAxMjU5MDA4KVxyXG4gIGJ1dCBkZWZpbml0aW9uIG9mIFtpbmVydCBzdWJ0cmVlc10oaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VkaXRpbmcuaHRtbCNpbmVydC1zdWJ0cmVlcykgcmVtYWlucy5cclxuXHJcbiAgW2ltcGxlbWVudGF0aW9uIGlkZWEgYnkgVmFzaWxpc10oaHR0cHM6Ly9jb2RlcGVuLmlvL3Zhc2lsaXN2Zy9wZW4vc2Nvd0kpXHJcbiAgW2luZXJ0IGF0dHJpYnV0ZSBwb2x5ZmlsbCBieSBHb29nbGVDaHJvbWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvaW5lcnQtcG9seWZpbGwpXHJcblxyXG4gIFtHZWNrbyBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIxNTA0KVxyXG4gIFtDaHJvbWl1bSBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI2OTg0NilcclxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjQxNjk5KVxyXG4gIFtXZWJLaXQgQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEwOTUyKVxyXG4qL1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZWRGb2N1cygpIHtcclxuICBfbG9nZ2VyMi5kZWZhdWx0Lndhcm4oJ3RyeWluZyB0byBmb2N1cyBpbmVydCBlbGVtZW50JywgdGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVUYWJpbmRleChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcclxuICAgIHZhciB0YWJJbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMi5kZWZhdWx0KSh7XHJcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgIGF0dHJpYnV0ZTogJ3RhYmluZGV4JyxcclxuICAgICAgdGVtcG9yYXJ5VmFsdWU6ICctMScsXHJcbiAgICAgIHNhdmVWYWx1ZTogdGFiSW5kZXggIT09IG51bGwgPyB0YWJJbmRleCA6ICcnXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xyXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICBhdHRyaWJ1dGU6ICd0YWJpbmRleCdcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGlzYWJsZVZpZGVvQ29udHJvbHMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlMi5kZWZhdWx0KSh7XHJcbiAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgYXR0cmlidXRlOiAnY29udHJvbHMnLFxyXG4gICAgcmVtb3ZlOiBkaXNhYmxlZFN0YXRlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVTdmdGb2N1c2FibGUoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gICgwLCBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKHtcclxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICBhdHRyaWJ1dGU6ICdmb2N1c2FibGUnLFxyXG4gICAgdGVtcG9yYXJ5VmFsdWU6IGRpc2FibGVkU3RhdGUgPyAnZmFsc2UnIDogdW5kZWZpbmVkXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVTdmdMaW5rKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZTIuZGVmYXVsdCkoe1xyXG4gICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgIGF0dHJpYnV0ZTogJ3hsaW5rOmhyZWYnLFxyXG4gICAgcmVtb3ZlOiBkaXNhYmxlZFN0YXRlXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEFyaWFEaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XHJcbiAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xyXG4gICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgIGF0dHJpYnV0ZTogJ2FyaWEtZGlzYWJsZWQnLFxyXG4gICAgdGVtcG9yYXJ5VmFsdWU6IGRpc2FibGVkU3RhdGUgPyAndHJ1ZScgOiB1bmRlZmluZWRcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xyXG4gICAgLy8gbWFrZSBzdXJlIG5vIHNjcmlwdCBjYW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgIGVsZW1lbnQuZm9jdXMgPSBkaXNhYmxlZEZvY3VzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGZvY3VzIGZ1bmN0aW9uIGZyb20gcHJvdG90eXBlXHJcbiAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2FibGVQb2ludGVyRXZlbnRzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcclxuICBpZiAoZGlzYWJsZWRTdGF0ZSkge1xyXG4gICAgLy8gcmVtZW1iZXIgcHJldmlvdXMgcG9pbnRlciBldmVudHMgc3RhdHVzIHNvIHdlIGNhbiByZXN0b3JlIGl0XHJcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyB8fCAnJztcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJywgcG9pbnRlckV2ZW50cyk7XHJcbiAgICAvLyBtYWtlIHN1cmUgbm8gcG9pbnRlciBpbnRlcmFjdGlvbiBjYW4gYWNjZXNzIHRoZSBlbGVtZW50XHJcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHJlc3RvcmUgdG8gcHJldmlvdXMgcG9pbnRlciBpbnRlcmFjdGlvbiBzdGF0dXNcclxuICAgIHZhciBfcG9pbnRlckV2ZW50cyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJyk7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydC1wb2ludGVyLWV2ZW50cycpO1xyXG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gX3BvaW50ZXJFdmVudHM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRFbGVtZW50RGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xyXG4gIHNldEFyaWFEaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICBkaXNhYmxlVGFiaW5kZXgoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XHJcbiAgZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gIGRpc2FibGVQb2ludGVyRXZlbnRzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG5cclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nIHx8IG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XHJcbiAgICAvLyBCbGluayBhbmQgR2Vja28gbGVhdmUgPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gaW4gZG9jdW1lbnQgZm9jdXMgbmF2aWdhdGlvbiBzZXF1ZW5jZVxyXG4gICAgLy8gQmxpbmsgbGVhdmVzIDxhdWRpbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IGluIGRvY3VtZW50IGZvY3VzIG5hdmlnYXRpb24gc2VxdWVuY2VcclxuICAgIGRpc2FibGVWaWRlb0NvbnRyb2xzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJyB8fCBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGtub3dzIGZvY3VzYWJsZT1cImZhbHNlXCIgaW5zdGVhZCBvZiB0YWJpbmRleD1cIi0xXCJcclxuICAgICAgZGlzYWJsZVN2Z0ZvY3VzYWJsZShlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcclxuICAgIH0gZWxzZSBpZiAoIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgbm9kZU5hbWUgPT09ICdhJykge1xyXG4gICAgICAvLyBGaXJlZm94IG5laXRoZXIga25vd3MgZm9jdXNhYmxlPVwiZmFsc2VcIiBub3IgdGFiaW5kZXg9XCItMVwiXHJcbiAgICAgIGRpc2FibGVTdmdMaW5rKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbGx5LWRpc2FibGVkJyk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzYWJsZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIC8vIEVkZ2UxMywgRWRnZTE0OiBmb3JlaWduT2JqZWN0IGZvY3VzIGhhY2tcclxuICAvLyBodHRwczovL2pzYmluLmNvbS9rdW5laGludWdpL2VkaXQ/aHRtbCxqcyxvdXRwdXRcclxuICAvLyBodHRwczovL2pzYmluLmNvbS9mYWphZ2kvMy9lZGl0P2h0bWwsanMsb3V0cHV0XHJcbiAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XHJcbiAgaWYgKCFpc1N2Z0VsZW1lbnQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGluamVjdCBhbmQgZm9jdXMgYW4gPGlucHV0PiBlbGVtZW50IGludG8gdGhlIFNWRyBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcclxuICB2YXIgZm9yZWlnbk9iamVjdCA9IG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCk7XHJcbiAgZWxlbWVudC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcclxuICB2YXIgaW5wdXQgPSBmb3JlaWduT2JqZWN0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgaW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgLy8gdXBvbiBkaXNhYmxpbmcgdGhlIGFjdGl2ZUVsZW1lbnQsIElFIGFuZCBFZGdlXHJcbiAgLy8gd2lsbCBub3Qgc2hpZnQgZm9jdXMgdG8gPGJvZHk+IGxpa2UgYWxsIHRoZSBvdGhlclxyXG4gIC8vIGJyb3dzZXJzLCBidXQgaW5zdGVhZCBmaW5kIHRoZSBmaXJzdCBmb2N1c2FibGVcclxuICAvLyBhbmNlc3RvciBhbmQgc2hpZnQgZm9jdXMgdG8gdGhhdFxyXG4gIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuXHJcbiAgLy8gY2xlYW4gdXBcclxuICBlbGVtZW50LnJlbW92ZUNoaWxkKGZvcmVpZ25PYmplY3QpO1xyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKSB7XHJcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgZnJhZ21lbnQuaW5uZXJIVE1MID0gJzxzdmc+PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCI+XFxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPlxcbiAgPC9mb3JlaWduT2JqZWN0Pjwvc3ZnPic7XHJcblxyXG4gIHJldHVybiBmcmFnbWVudC5maXJzdENoaWxkLmZpcnN0Q2hpbGQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy5zdmctZm9yZWlnbi1vYmplY3QtaGFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XHJcblxyXG4gIHZhciBsaXN0ID0gW107XHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnZ2V0L3BhcmVudHMnLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICB3aGlsZSAoZWxlbWVudCkge1xyXG4gICAgbGlzdC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgLy8gSUUgZG9lcyBrbm93IHN1cHBvcnQgcGFyZW50RWxlbWVudCBvbiBTVkdFbGVtZW50XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGlzdDtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vLyBbZWxlbSwgZWxlbS5wYXJlbnQsIGVsZW0ucGFyZW50LnBhcmVudCwg4oCmLCBodG1sXVxyXG4vLyB3aWxsIG5vdCBjb250YWluIHRoZSBzaGFkb3dSb290IChET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSBhbmQgc2hhZG93SG9zdFxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnZ2V0L3NoYWRvdy1ob3N0JyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgLy8gd2FsayB1cCB0byB0aGUgcm9vdFxyXG4gIHZhciBjb250YWluZXIgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoZWxlbWVudCkge1xyXG4gICAgY29udGFpbmVyID0gZWxlbWVudDtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5ub2RlVHlwZVxyXG4gIC8vIE5PVEU6IEZpcmVmb3ggMzQgZG9lcyBub3QgZXhwb3NlIFNoYWRvd1Jvb3QuaG9zdCAoYnV0IDM3IGRvZXMpXHJcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gY29udGFpbmVyLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgY29udGFpbmVyLmhvc3QpIHtcclxuICAgIC8vIHRoZSByb290IGlzIGF0dGFjaGVkIHRvIGEgZnJhZ21lbnQgbm9kZSB0aGF0IGhhcyBhIGhvc3RcclxuICAgIHJldHVybiBjb250YWluZXIuaG9zdDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LWhvc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL2FjdGl2ZS1lbGVtZW50JyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gIGlmIChfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgc2hhZG93SG9zdCA9ICgwLCBfc2hhZG93SG9zdDIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG4gIGlmIChzaGFkb3dIb3N0ICYmIHNoYWRvd0hvc3Quc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3NoYWRvd0hvc3QgPSByZXF1aXJlKCcuLi9nZXQvc2hhZG93LWhvc3QnKTtcclxuXHJcbnZhciBfc2hhZG93SG9zdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0KTtcclxuXHJcbnZhciBfZ2V0RG9jdW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1kb2N1bWVudCcpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IGlzIHRoZSBhY3RpdmVFbGVtZW50IHdpdGhpbiBpdHMgY29udGV4dCwgaS5lLiBpdHMgZG9jdW1lbnQgaUZyYW1lIG9yIFNoYWRvd0hvc3RcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3RpdmUtZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvZGlzYWJsZWQnLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpKSB7XHJcbiAgICAvLyB0cmVhdCBhbGx5J3MgZWxlbWVudC9kaXNhYmxlZCBsaWtlIHRoZSBET00gbmF0aXZlIGVsZW1lbnQuZGlzYWJsZWRcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoMCwgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgLy8gbm9uLWZvcm0gZWxlbWVudHMgZG8gbm90IHN1cHBvcnQgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVsZW1lbnQuZGlzYWJsZWQpIHtcclxuICAgIC8vIHRoZSBlbGVtZW50IGl0c2VsZiBpcyBkaXNhYmxlZFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyZW50cyA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG4gIGlmIChwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZpZWxkc2V0KSkge1xyXG4gICAgLy8gYSBwYXJlbnRhbCA8ZmllbGRzZXQ+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXN1cHBvcnRzLmZvY3VzRm9ybURpc2FibGVkICYmIHBhcmVudHMuc29tZShpc0Rpc2FibGVkRm9ybSkpIHtcclxuICAgIC8vIGEgcGFyZW50YWwgPGZvcm0+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9wYXJlbnRzID0gcmVxdWlyZSgnLi4vZ2V0L3BhcmVudHMnKTtcclxuXHJcbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcclxuXHJcbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQnKTtcclxuXHJcbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGRpc2FibGVkIChpLmUuIG5vdCBlZGl0YWJsZSlcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbmZ1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlbGVtZW50KSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0JyAmJiBlbGVtZW50LmRpc2FibGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Rpc2FibGVkRm9ybShlbGVtZW50KSB7XHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2Zvcm0nICYmIGVsZW1lbnQuZGlzYWJsZWQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XHJcblxyXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9lbGVtZW50TWF0Y2hlcyA9IHJlcXVpcmUoJy4uL3V0aWwvZWxlbWVudC1tYXRjaGVzJyk7XHJcblxyXG52YXIgX2VsZW1lbnRNYXRjaGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VsZW1lbnRNYXRjaGVzKTtcclxuXHJcbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcclxuXHJcbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcclxuXHJcbnZhciBfdmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4vdmFsaWQtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfdmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZFRhYmluZGV4KTtcclxuXHJcbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzLmNhbiBiZSBmb2N1c2VkIGJ5IHNjcmlwdCByZWdhcmRsZXNzXHJcbi8vIG9mIHRoZSBlbGVtZW50IGFjdHVhbGx5IGJlaW5nIGZvY3VzYWJsZSBhdCB0aGUgdGltZSBvZiBleGVjdXRpb25cclxuLy8gaS5lLiA8aW5wdXQgZGlzYWJsZWQ+IGlzIGNvbmlzZGVyZWQgZm9jdXMtcmVsZXZhbnQsIGJ1dCBub3QgZm9jdXNhYmxlXHJcblxyXG5mdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXHJcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XHJcbiAgICBmbGV4Ym94OiBmYWxzZSxcclxuICAgIHNjcm9sbGFibGU6IGZhbHNlLFxyXG4gICAgc2hhZG93OiBmYWxzZVxyXG4gIH0gOiBfcmVmJGV4Y2VwdDtcclxuXHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvZm9jdXMtcmVsZXZhbnQnLFxyXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxyXG4gICAgY29udGV4dDogY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICBpZiAoIWV4Y2VwdC5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XHJcbiAgICAvLyBhIFNoYWRvd0RPTSBob3N0IHJlY2VpdmVzIGZvY3VzIHdoZW4gdGhlIGZvY3VzIG1vdmVzIHRvIGl0cyBjb250ZW50XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicpIHtcclxuICAgIC8vIGlucHV0W3R5cGU9XCJoaWRkZW5cIl0gc3VwcG9ydHMuY2Fubm90IGJlIGZvY3VzZWRcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xlZ2VuZCcgJiYgc3VwcG9ydHMuZm9jdXNSZWRpcmVjdExlZ2VuZCkge1xyXG4gICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcclxuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdvYmplY3QnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xyXG4gICAgLy8gb2JqZWN0W3VzZW1hcF0gaXMgbm90IGZvY3VzYWJsZSBpbiBhbnkgYnJvd3NlclxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIHN2Z1R5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xyXG4gICAgaWYgKCFzdXBwb3J0cy5mb2N1c09iamVjdFN2ZyAmJiBzdmdUeXBlID09PSAnaW1hZ2Uvc3ZnK3htbCcpIHtcclxuICAgICAgLy8gb2JqZWN0W3R5cGU9XCJpbWFnZS9zdmcreG1sXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmICghc3VwcG9ydHMuZm9jdXNPYmplY3RTd2YgJiYgc3ZnVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJykge1xyXG4gICAgICAvLyBvYmplY3RbdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnIHx8IG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2VtYmVkJyB8fCBub2RlTmFtZSA9PT0gJ2tleWdlbicpIHtcclxuICAgIC8vIGVtYmVkIGlzIGNvbnNpZGVyZWQgZm9jdXMtcmVsZXZhbnQgYnV0IG5vdCBmb2N1c2FibGVcclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcclxuICAgIC8vIGFsc28gc2VlIENTUyBwcm9wZXJ0eSB1c2VyLW1vZGlmeSBiZWxvd1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdhdWRpbycgJiYgKHN1cHBvcnRzLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJyAmJiAoc3VwcG9ydHMuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3VtbWFyeSAmJiBub2RlTmFtZSA9PT0gJ3N1bW1hcnknKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciB2YWxpZFRhYmluZGV4ID0gKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcclxuICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcclxuICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XHJcbiAgICByZXR1cm4gdmFsaWRUYWJpbmRleCAmJiBzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4IHx8IHN1cHBvcnRzLmZvY3VzUmVkaXJlY3RJbWdVc2VtYXA7XHJcbiAgfVxyXG5cclxuICBpZiAoc3VwcG9ydHMuZm9jdXNUYWJsZSAmJiAobm9kZU5hbWUgPT09ICd0YWJsZScgfHwgbm9kZU5hbWUgPT09ICd0ZCcpKSB7XHJcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChzdXBwb3J0cy5mb2N1c0ZpZWxkc2V0ICYmIG5vZGVOYW1lID09PSAnZmllbGRzZXQnKSB7XHJcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBpc1N2Z0VsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3N2Zyc7XHJcbiAgdmFyIGlzU3ZnQ29udGVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50O1xyXG4gIHZhciBmb2N1c2FibGVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJyk7XHJcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiB0YWJpbmRleCAhPT0gbnVsbCAmJiAhc3VwcG9ydHMuZm9jdXNTdmdVc2VUYWJpbmRleCkge1xyXG4gICAgLy8gPHVzZT4gY2Fubm90IGJlIG1hZGUgZm9jdXNhYmxlIGJ5IGFkZGluZyBhIHRhYmluZGV4IGF0dHJpYnV0ZSBhbnl3aGVyZSBidXQgQmxpbmsgYW5kIFdlYktpdFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnZm9yZWlnbm9iamVjdCcpIHtcclxuICAgIC8vIDx1c2U+IGNhbiBvbmx5IGJlIG1hZGUgZm9jdXNhYmxlIGluIEJsaW5rIGFuZCBXZWJLaXRcclxuICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiBzdXBwb3J0cy5mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDtcclxuICB9XHJcblxyXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICgoaXNTdmdFbGVtZW50IHx8IGlzU3ZnQ29udGVudCkgJiYgZWxlbWVudC5mb2N1cyAmJiAhc3VwcG9ydHMuZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlICYmIHRhYmluZGV4IDwgMCkge1xyXG4gICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcclxuICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XHJcbiAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU3ZnRWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHZhbGlkVGFiaW5kZXggfHwgc3VwcG9ydHMuZm9jdXNTdmcgfHwgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZVxyXG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcclxuICAgIHx8IEJvb2xlYW4oc3VwcG9ydHMuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ3RydWUnKTtcclxuICB9XHJcblxyXG4gIGlmIChpc1N2Z0NvbnRlbnQpIHtcclxuICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIHZhbGlkVGFiaW5kZXgpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXHJcbiAgICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgPT09ICd0cnVlJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXHJcbiAgaWYgKHZhbGlkVGFiaW5kZXgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XHJcbiAgaWYgKCgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKHN0eWxlKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoc3VwcG9ydHMuZm9jdXNJbWdJc21hcCAmJiBub2RlTmFtZSA9PT0gJ2ltZycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2lzbWFwJykpIHtcclxuICAgIC8vIElFMTAtMTEgY29uc2lkZXJzIHRoZSA8aW1nPiBpbiA8YSBocmVmPjxpbWcgaXNtYXA+IGZvY3VzYWJsZVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMFxyXG4gICAgdmFyIGhhc0xpbmtQYXJlbnQgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogZWxlbWVudCB9KS5zb21lKGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgcGFyZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGhhc0xpbmtQYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBzdXBwb3J0cy5mb2N1c1Njcm9sbENvbnRhaW5lcikge1xyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KSB7XHJcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXMgd2lsbCBjb25zaWRlciB0aGUgc2Nyb2xsYWJsZSBhcmVhIGZvY3VzYWJsZVxyXG4gICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIDxkaXY+IG9yIGEgPHNwYW4+IGFuZCBpdCBpcyBpbiBmYWN0IHNjcm9sbGFibGUsXHJcbiAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIENTUyBvdmVyZmxvdyBwcm9wZXJ0eVxyXG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKGVsZW1lbnQsIG5vZGVOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwpKHN0eWxlKSkge1xyXG4gICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHByb3BlciBvdmVyZmxvdyBzZXR0aW5nLCBJRSBkb2VzIG5vdCBuZWNlc3NhcmlseVxyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb3ZlcmZsb3dcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmIHN1cHBvcnRzLmZvY3VzRmxleGJveENvbnRhaW5lciAmJiAoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShzdHlsZSkpIHtcclxuICAgIC8vIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGFyZW50KSB7XHJcbiAgICB2YXIgcGFyZW50Tm9kZU5hbWUgPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTY3JvbGxCb2R5ICYmICgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShwYXJlbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpKSB7XHJcbiAgICAgIC8vIHNjcm9sbGFibGUgYm9kaWVzIGFyZSBmb2N1c2FibGUgSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCkge1xyXG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE5PVEU6IGVsZW1lbnRzIG1hcmtlZCBhcyBpbmVydCBhcmUgbm90IGZvY3VzYWJsZSxcclxuICAvLyBidXQgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZXhwb3NlZCB0byB0aGUgRE9NXHJcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNpbmVydFxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gIHZhciBpc0ZvY3VzUmVsZXZhbnQgPSBmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFJ1bGVzKHtcclxuICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgZXhjZXB0OiBleGNlcHRcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlzRm9jdXNSZWxldmFudC5ydWxlcyA9IGlzRm9jdXNSZWxldmFudFJ1bGVzO1xyXG4gIHJldHVybiBpc0ZvY3VzUmVsZXZhbnQ7XHJcbn07XHJcblxyXG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXHJcbnZhciBpc0ZvY3VzUmVsZXZhbnQgPSBpc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQoe30pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZvY3VzUmVsZXZhbnQ7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWxldmFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZm9jdXNSZWxldmFudCA9IHJlcXVpcmUoJy4vZm9jdXMtcmVsZXZhbnQnKTtcclxuXHJcbnZhciBfZm9jdXNSZWxldmFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlbGV2YW50KTtcclxuXHJcbnZhciBfdmFsaWRBcmVhID0gcmVxdWlyZSgnLi92YWxpZC1hcmVhJyk7XHJcblxyXG52YXIgX3ZhbGlkQXJlYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZEFyZWEpO1xyXG5cclxudmFyIF92aXNpYmxlID0gcmVxdWlyZSgnLi92aXNpYmxlJyk7XHJcblxyXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XHJcblxyXG52YXIgX2Rpc2FibGVkID0gcmVxdWlyZSgnLi9kaXNhYmxlZCcpO1xyXG5cclxudmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XHJcblxyXG52YXIgX29ubHlUYWJiYWJsZSA9IHJlcXVpcmUoJy4vb25seS10YWJiYWJsZScpO1xyXG5cclxudmFyIF9vbmx5VGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seVRhYmJhYmxlKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xyXG4vLyBkZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZFxyXG5cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNmb2N1cy1tYW5hZ2VtZW50XHJcblxyXG4vLyBOT1RFOiBUaGUgZm9sbG93aW5nIGtub3duIGlzc3VlcyBleGlzdDpcclxuLy8gICBHZWNrbzogYHN2ZyBhW3hsaW5rfGhyZWZdYCBpcyBub3QgaWRlbnRpZmllZCBhcyBmb2N1c2FibGUgKGJlY2F1c2UgU1ZHRWxlbWVudC5wcm90b3R5cGUuZm9jdXMgaXMgbWlzc2luZylcclxuLy8gICBCbGluaywgV2ViS2l0OiBTVkdFbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBtYWRlIGZvY3VzYWJsZSBieSBhZGRpbmcgYSBmb2N1cyBldmVudCBsaXN0ZW5lciBhcmUgbm90IGlkZW50aWZpZWQgYXMgZm9jdXNhYmxlXHJcblxyXG5mdW5jdGlvbiBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpIHtcclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xyXG4gICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxyXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvODJcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIF90YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCAmJiBfdGFiaW5kZXggPT09IG51bGwpIHtcclxuICAgIC8vIFNoYWRvd0RPTSBob3N0IGVsZW1lbnRzICptYXkqIHJlY2VpdmUgZm9jdXNcclxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIG5vdCBjb25zaWRlcmVkIGZvY3VhYmxlXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2xhYmVsJykge1xyXG4gICAgLy8gPGxhYmVsIHRhYmluZGV4PVwiMFwiPiBpcyBvbmx5IHRhYmJhYmxlIGluIEZpcmVmb3gsIG5vdCBzY3JpcHQtZm9jdXNhYmxlXHJcbiAgICAvLyB0aGVyZSdzIG5vIHdheSB0byBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIG90aGVyIHRoYW4gYnkgYWRkaW5nIGEgdGFiaW5kZXgsXHJcbiAgICAvLyBhbmQgZm9jdXMgYmVoYXZpb3Igb2YgdGhlIGxhYmVsIGVsZW1lbnQgc2VlbXMgaGFyZC13aXJlZCB0byBpZ25vcmUgdGFiaW5kZXhcclxuICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgR2Vja28sIEJsaW5rIGFuZCBXZWJLaXQpXHJcbiAgICByZXR1cm4gIXN1cHBvcnRzLmZvY3VzTGFiZWxUYWJpbmRleCB8fCBfdGFiaW5kZXggPT09IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnKSB7XHJcbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlICYmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBub2RlTmFtZSA9PT0gJ3N2ZycpKSB7XHJcbiAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciB1bmRlcnN0YW5kcyB0aGUgZm9jdXNhYmxlIGF0dHJpYnV0ZSBpbnRyb2R1Y2VkIGluIFNWRyBUaW55IDEuMlxyXG4gICAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb2N1c2FibGUnKTtcclxuICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAnZmFsc2UnO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcclxuICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcclxuICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XHJcbiAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsIHx8ICFzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4O1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgIC8vIGFsbCA8YXJlYT5zIGFyZSBjb25zaWRlcmVkIHJlbGV2YW50LFxyXG4gICAgLy8gYnV0IG9ubHkgdGhlIHZhbGlkIDxhcmVhPnMgYXJlIGZvY3VzYWJsZVxyXG4gICAgcmV0dXJuICEoMCwgX3ZhbGlkQXJlYTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxyXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xyXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICBvbmx5VGFiYmFibGU6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgX2lzT25seVRhYmJhYmxlID0gX29ubHlUYWJiYWJsZTIuZGVmYXVsdC5ydWxlcy5leGNlcHQoe1xyXG4gICAgb25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDogdHJ1ZSxcclxuICAgIHZpc2libGU6IGV4Y2VwdC52aXNpYmxlXHJcbiAgfSk7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL2ZvY3VzYWJsZScsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBmb2N1c1JlbGV2YW50ID0gX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQucnVsZXMoe1xyXG4gICAgY29udGV4dDogZWxlbWVudCxcclxuICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgfSk7XHJcblxyXG4gIGlmICghZm9jdXNSZWxldmFudCB8fCBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5kaXNhYmxlZCAmJiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQub25seVRhYmJhYmxlICYmIF9pc09ubHlUYWJiYWJsZShlbGVtZW50KSkge1xyXG4gICAgLy8gc29tZSBlbGVtZW50cyBtYXkgYmUga2V5Ym9hcmQgZm9jdXNhYmxlLCBidXQgbm90IHNjcmlwdCBmb2N1c2FibGVcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCByZW5kZXJlZCwgY2Fubm90IGJlIGZvY3VzZWRcclxuICBpZiAoIWV4Y2VwdC52aXNpYmxlKSB7XHJcbiAgICB2YXIgdmlzaWJpbGl0eU9wdGlvbnMgPSB7XHJcbiAgICAgIGNvbnRleHQ6IGVsZW1lbnQsXHJcbiAgICAgIGV4Y2VwdDoge31cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzSW5IaWRkZW5JZnJhbWUpIHtcclxuICAgICAgLy8gV2ViS2l0IGFuZCBCbGluayBjYW4gZm9jdXMgY29udGVudCBpbiBoaWRkZW4gPGlmcmFtZT4gYW5kIDxvYmplY3Q+XHJcbiAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5icm93c2luZ0NvbnRleHQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdXBwb3J0cy5mb2N1c09iamVjdFN2Z0hpZGRlbikge1xyXG4gICAgICAvLyBCbGluayBhbGxvd3MgZm9jdXNpbmcgdGhlIG9iamVjdCBlbGVtZW50LCBldmVuIGlmIGl0IGhhcyB2aXNpYmlsaXR5OiBoaWRkZW47XHJcbiAgICAgIC8vIEBicm93c2VyLWlzc3VlIEJsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODYxOTFcclxuICAgICAgdmFyIF9ub2RlTmFtZTIgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmIChfbm9kZU5hbWUyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghX3Zpc2libGUyLmRlZmF1bHQucnVsZXModmlzaWJpbGl0eU9wdGlvbnMpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGZyYW1lRWxlbWVudCkge1xyXG4gICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKF9ub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgIXN1cHBvcnRzLmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KSB7XHJcbiAgICAgIGlmICghZnJhbWVFbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFmcmFtZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgLy8gV2ViS2l0IGNhbiBub3QgZm9jdXMgY29udGVudCBpbiA8b2JqZWN0PiBpZiBpdCBkb2Vzbid0IGhhdmUgZGltZW5zaW9uc1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiAhZnJhbWVFbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXHJcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG5cclxuICB2YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7XHJcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpc0ZvY3VzYWJsZS5ydWxlcyA9IGlzRm9jdXNhYmxlUnVsZXM7XHJcbiAgcmV0dXJuIGlzRm9jdXNhYmxlO1xyXG59O1xyXG5cclxuLy8gcHJvdmlkZSBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xyXG52YXIgaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRm9jdXNhYmxlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmlzVXNlck1vZGlmeVdyaXRhYmxlID0gaXNVc2VyTW9kaWZ5V3JpdGFibGU7XHJcbmV4cG9ydHMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwgPSBoYXNDc3NPdmVyZmxvd1Njcm9sbDtcclxuZXhwb3J0cy5oYXNDc3NEaXNwbGF5RmxleCA9IGhhc0Nzc0Rpc3BsYXlGbGV4O1xyXG5leHBvcnRzLmlzU2Nyb2xsYWJsZUNvbnRhaW5lciA9IGlzU2Nyb2xsYWJsZUNvbnRhaW5lcjtcclxuXHJcbi8vIHRoaXMgaXMgYSBzaGFyZWQgdXRpbGl0eSBmaWxlIGZvciBmb2N1cy1yZWxldmFudC5qcyBhbmQgdGFiYmFibGUuanNcclxuLy8gc2VwYXJhdGUgdGVzdGluZyBvZiB0aGlzIGZpbGUncyBmdW5jdGlvbnMgaXMgbm90IG5lY2Vzc2FyeSxcclxuLy8gYXMgdGhleSdyZSBpbXBsaWNpdGx5IHRlc3RlZCBieSB3YXkgb2YgdGhlIGNvbnN1bWVyc1xyXG5cclxuZnVuY3Rpb24gaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpIHtcclxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9XRC1jc3MzLXVzZXJpbnQtMTk5OTA5MTYjdXNlci1tb2RpZnlcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE3XHJcbiAgdmFyIHVzZXJNb2RpZnkgPSBzdHlsZS53ZWJraXRVc2VyTW9kaWZ5IHx8ICcnO1xyXG4gIHJldHVybiBCb29sZWFuKHVzZXJNb2RpZnkgJiYgdXNlck1vZGlmeS5pbmRleE9mKCd3cml0ZScpICE9PSAtMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKHN0eWxlKSB7XHJcbiAgcmV0dXJuIFtzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpLCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy14JyksIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKV0uc29tZShmdW5jdGlvbiAob3ZlcmZsb3cpIHtcclxuICAgIHJldHVybiBvdmVyZmxvdyA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93ID09PSAnc2Nyb2xsJztcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzQ3NzRGlzcGxheUZsZXgoc3R5bGUpIHtcclxuICByZXR1cm4gc3R5bGUuZGlzcGxheS5pbmRleE9mKCdmbGV4JykgPiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpIHtcclxuICBpZiAobm9kZU5hbWUgIT09ICdkaXYnICYmIG5vZGVOYW1lICE9PSAnc3BhbicpIHtcclxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGFkdmFuY2VzIHNjcm9sbGFibGUgY29udGFpbmVycyBhbmQgYm9kaWVzIHRvIGZvY3VzYWJsZVxyXG4gICAgLy8gb25seSBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgPGRpdj4gb3IgPHNwYW4+IC0gdGhpcyBkb2VzICpub3QqXHJcbiAgICAvLyBoYXBwZW4gZm9yIDxzZWN0aW9uPiwgPGFydGljbGU+LCDigKZcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChwYXJlbnROb2RlTmFtZSAmJiBwYXJlbnROb2RlTmFtZSAhPT0gJ2RpdicgJiYgcGFyZW50Tm9kZU5hbWUgIT09ICdzcGFuJyAmJiAhaGFzQ3NzT3ZlcmZsb3dTY3JvbGwocGFyZW50U3R5bGUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fCBlbGVtZW50Lm9mZnNldFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy51dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcblxyXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xyXG4gICAgICBkZWxldGUgZGlzYWJsZWRFbGVtZW50cy5maWVsZHNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNGb3JtRGlzYWJsZWQpIHtcclxuICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oJyArIE9iamVjdC5rZXlzKGRpc2FibGVkRWxlbWVudHMpLmpvaW4oJ3wnKSArICcpJCcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcclxuICAgIGxhYmVsOiAnaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICByZXR1cm4gQm9vbGVhbihkaXNhYmxlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSk7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIERldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxyXG52YXIgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSB2b2lkIDA7XHJcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xyXG4gIGlucHV0OiB0cnVlLFxyXG4gIHNlbGVjdDogdHJ1ZSxcclxuICB0ZXh0YXJlYTogdHJ1ZSxcclxuICBidXR0b246IHRydWUsXHJcbiAgZmllbGRzZXQ6IHRydWUsXHJcbiAgZm9ybTogdHJ1ZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3Zpc2libGUgPSByZXF1aXJlKCcuL3Zpc2libGUnKTtcclxuXHJcbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXHJcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XHJcbiAgICBvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OiBmYWxzZSxcclxuICAgIHZpc2libGU6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy9vbmx5LXRhYmJhYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgaWYgKCFleGNlcHQudmlzaWJsZSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQub25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dCAmJiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5UUklERU5UIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5FREdFKSkge1xyXG4gICAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcclxuICAgICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcclxuICAgICAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcclxuICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgdmFyIHRhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnbGFiZWwnICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgLy8gRmlyZWZveCBjYW5ub3QgZm9jdXMsIGJ1dCB0YWIgdG86IGxhYmVsW3RhYmluZGV4PTBdXHJcbiAgICByZXR1cm4gdGFiaW5kZXggIT09IG51bGwgJiYgdGFiaW5kZXggPj0gMDtcclxuICB9XHJcblxyXG4gIC8vIFNWRyBFbGVtZW50cyB3ZXJlIGtleWJvYXJkIGZvY3VzYWJsZSBidXQgbm90IHNjcmlwdCBmb2N1c2FibGUgYmVmb3JlIEZpcmVmb3ggNTEuXHJcbiAgLy8gRmlyZWZveCA1MSBhZGRlZCB0aGUgZm9jdXMgbWFuYWdlbWVudCBET00gQVBJICguZm9jdXMgYW5kIC5ibHVyKSB0byBTVkdFbGVtZW50LFxyXG4gIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Nzg2NTRcclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50ICYmICFlbGVtZW50LmZvY3VzKSB7XHJcbiAgICBpZiAobm9kZU5hbWUgPT09ICdhJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICAgIC8vIGFueSBmb2N1c2FibGUgY2hpbGQgb2YgPHN2Zz4gY2Fubm90IGJlIGZvY3VzZWQsIGJ1dCB0YWJiZWQgdG9cclxuICAgICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgdmFyIGlzT25seVRhYmJhYmxlID0gZnVuY3Rpb24gaXNPbmx5VGFiYmFibGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzT25seVRhYmJhYmxlUnVsZXMoe1xyXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICBleGNlcHQ6IGV4Y2VwdFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgaXNPbmx5VGFiYmFibGUucnVsZXMgPSBpc09ubHlUYWJiYWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc09ubHlUYWJiYWJsZTtcclxufTtcclxuXHJcbi8vIHByb3ZpZGUgaXNPbmx5VGFiYmFibGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xyXG52YXIgaXNPbmx5VGFiYmFibGUgPSBpc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGlzT25seVRhYmJhYmxlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25seS10YWJiYWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xyXG5cclxudmFyIF92aXNpYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Zpc2libGUpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZWxlbWVudE1hdGNoZXMgPSByZXF1aXJlKCcuLi91dGlsL2VsZW1lbnQtbWF0Y2hlcycpO1xyXG5cclxudmFyIF9lbGVtZW50TWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVtZW50TWF0Y2hlcyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlbGV2YW50Jyk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWxldmFudCk7XHJcblxyXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBkZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZCBieSBrZXlib2FyZCAoaS5lLiBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCdzIHNlcXVlbnRpYWwgZm9jdXMgbmF2aWdhdGlvbiBvcmRlcilcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbi8vIEludGVybmV0IEV4cGxvcmVyIDExIGNvbnNpZGVycyBmaWVsZHNldCwgdGFibGUsIHRkIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxyXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMSBjb25zaWRlcnMgYm9keSB0byBoYXZlIFt0YWJpbmRleD0wXSwgYnV0IGRvZXMgbm90IGFsbG93IHRhYmJpbmcgdG8gaXRcclxudmFyIGZvY3VzYWJsZUVsZW1lbnRzUGF0dGVybiA9IC9eKGZpZWxkc2V0fHRhYmxlfHRkfGJvZHkpJC87XHJcblxyXG5mdW5jdGlvbiBpc1RhYmJhYmxlUnVsZXMoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxyXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xyXG4gICAgZmxleGJveDogZmFsc2UsXHJcbiAgICBzY3JvbGxhYmxlOiBmYWxzZSxcclxuICAgIHNoYWRvdzogZmFsc2UsXHJcbiAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcclxuICB9IDogX3JlZiRleGNlcHQ7XHJcblxyXG4gIGlmICghc3VwcG9ydHMpIHtcclxuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcclxuICB9XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ2lzL3RhYmJhYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQU5EUk9JRCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID4gNDIpIHtcclxuICAgIC8vIEV4dGVybmFsIGtleWJvYXJkIHN1cHBvcnQgd29ya2VkIGZpbmUgaW4gQ0hyb21lIDQyLCBidXQgc3RvcHBlZCB3b3JraW5nIGluIENocm9tZSA0NS5cclxuICAgIC8vIFRoZSBvbi1zY3JlZW4ga2V5Ym9hcmQgZG9lcyBub3QgcHJvdmlkZSBhIHdheSB0byBmb2N1cyB0aGUgbmV4dCBpbnB1dCBlbGVtZW50IChsaWtlIGlPUyBkb2VzKS5cclxuICAgIC8vIFRoYXQgbGVhdmVzIHVzIHdpdGggbm8gb3B0aW9uIHRvIGFkdmFuY2UgZm9jdXMgYnkga2V5Ym9hcmQsIGVyZ28gbm90aGluZyBpcyB0YWJiYWJsZSAoa2V5Ym9hcmQgZm9jdXNhYmxlKS5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKGZyYW1lRWxlbWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLklPUykge1xyXG4gICAgICAvLyBpT1Mgb25seSBkb2VzIG5vdCBjb25zaWRlciBhbnl0aGluZyBmcm9tIGFub3RoZXIgYnJvd3NpbmcgY29udGV4dCBrZXlib2FyZCBmb2N1c2FibGVcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxyXG4gICAgLy8gdGFiYmFibGUgZGVtb3Rpb24gb250byBlbGVtZW50cyBvZiB0aGVpciBicm93c2luZyBjb250ZXh0c1xyXG4gICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUKSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShmcmFtZUVsZW1lbnQpKSB7XHJcbiAgICAgIC8vIEJsaW5rIGFuZCBXZWJLaXQgY29uc2lkZXIgZWxlbWVudHMgaW4gaGlkZGVuIGJyb3dzaW5nIGNvbnRleHRzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2Via2l0IGFuZCBCbGluayBkb24ndCBjb25zaWRlciBhbnl0aGluZyBpbiA8b2JqZWN0PiB0YWJiYWJsZVxyXG4gICAgLy8gQmxpbmsgZml4ZWQgdGhhdCBmaXhlZCBpbiBDaHJvbWUgNTQsIE9wZXJhIDQxXHJcbiAgICB2YXIgZnJhbWVOb2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKGZyYW1lTm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhciBpc0ZpeGVkQmxpbmsgPSBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ0Nocm9tZScgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+PSA1NCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQubmFtZSA9PT0gJ09wZXJhJyAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDQxO1xyXG5cclxuICAgICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LICYmICFpc0ZpeGVkQmxpbmspIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcclxuICB2YXIgdGFiaW5kZXggPSBfdGFiaW5kZXggPT09IG51bGwgPyBudWxsIDogX3RhYmluZGV4ID49IDA7XHJcblxyXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID49IDE0ICYmIGZyYW1lRWxlbWVudCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCAmJiBfdGFiaW5kZXggPCAwKSB7XHJcbiAgICAvLyBFZGdlIDE0KyBjb25zaWRlcnMgPGEgeGxpbms6aHJlZj1cIuKAplwiIHRhYmluZGV4PVwiLTFcIj4ga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBpbiBhIG5lc3RlZCBicm93c2luZyBjb250ZXh0XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lID0gdGFiaW5kZXggIT09IGZhbHNlO1xyXG4gIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4ID0gX3RhYmluZGV4ICE9PSBudWxsICYmIF90YWJpbmRleCA+PSAwO1xyXG5cclxuICAvLyBOT1RFOiBGaXJlZm94IDMxIGNvbnNpZGVycyBbY29udGVudGVkaXRhYmxlXSB0byBoYXZlIFt0YWJpbmRleD0tMV0sIGJ1dCBhbGxvd3MgdGFiYmluZyB0byBpdFxyXG4gIC8vIGZpeGVkIGluIEZpcmVmb3ggNDAgdGhlIGxhdGVzdCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExODU2NTdcclxuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XHJcbiAgICAvLyB0YWJiaW5nIGNhbiBzdGlsbCBiZSBkaXNhYmxlZCBieSBleHBsaWNpdGx5IHByb3ZpZGluZyBbdGFiaW5kZXg9XCItMVwiXVxyXG4gICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpICYmIHRhYmluZGV4ICE9PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSU9TKSB7XHJcbiAgICAvLyBpT1Mgb25seSBjb25zaWRlcnMgYSBoYW5kIGZ1bGwgb2YgZWxlbWVudHMgdGFiYmFibGUgKGtleWJvYXJkIGZvY3VzYWJsZSlcclxuICAgIC8vIHRoaXMgaG9sZHMgdHJ1ZSBldmVuIHdpdGggZXh0ZXJuYWwga2V5Ym9hcmRzXHJcbiAgICB2YXIgcG90ZW50aWFsbHlUYWJiYWJsZSA9IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ3Bhc3N3b3JkJyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xyXG5cclxuICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xyXG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcclxuICAgICAgcG90ZW50aWFsbHlUYWJiYWJsZSA9ICgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKHN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiBfdGFiaW5kZXggIT09IG51bGwpIHtcclxuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQubWFqb3JWZXJzaW9uID09PSA5KSB7XHJcbiAgICAgIC8vIEluIENocm9tZSBhbmQgU2FmYXJpIDkgdGhlIDx1c2U+IGVsZW1lbnQgaXMga2V5Ym9hcmQgZm9jdXNhYmxlIGV2ZW4gZm9yIHRhYmluZGV4PVwiLTFcIlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICgoMCwgX2VsZW1lbnRNYXRjaGVzMi5kZWZhdWx0KShlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XHJcbiAgICBpZiAoaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xyXG4gICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGhhbmRsZSB0aGUgdGFiSW5kZXggcHJvcGVydHkgcHJvcGVybHlcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQuZm9jdXMgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSkge1xyXG4gICAgICAvLyBGaXJlZm94IDUxIGFuZCA1MiB0cmVhdCBhbnkgbmF0aXZlbHkgdGFiYmFibGUgU1ZHIGVsZW1lbnQgd2l0aFxyXG4gICAgICAvLyB0YWJpbmRleD1cIi0xXCIgYXMgdGFiYmFibGUgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBhcyBpbmVydFxyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSkge1xyXG4gICAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJykge1xyXG4gICAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmcpIHtcclxuICAgICAgICAvLyBvbGRlciBJbnRlcm5ldCBFeHBsb3JlcnMgY29uc2lkZXIgPHN2Zz4ga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGF2ZSBmb2NzYWJsZT1cImZhbHNlXCIsIGJ1dCB0aGVuIHRoZXkgd291bGRuJ3RcclxuICAgICAgICAvLyBiZSBmb2N1c2FibGUgYW5kIHRodXMgbm90IGV2ZW4gcmVhY2ggdGhpcyBmaWx0ZXJcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxyXG4gICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpIHx8IGhhc1RhYmJhYmxlVGFiaW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XHJcbiAgICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIGhhc1RhYmJhYmxlVGFiaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxyXG4gICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZWxlbWVudC50YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihleGNlcHQub25seVRhYmJhYmxlKTtcclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xyXG4gICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciB0aGUgPGF1ZGlvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LKSB7XHJcbiAgICAgIC8vIEluIENocm9tZSA8YXVkaW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xyXG4gICAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcclxuICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSB0aGUgPHZpZGVvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgICAgLy8gSW4gQ2hyb21lIGFuZCBGaXJlZm94IDx2aWRlbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IHJlbWFpbnMga2V5Ym9hcmQgZm9jdXNhYmxlXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUKSB7XHJcbiAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxlbWJlZD4gYW5kIDxvYmplY3Q+IGFyZSBuZXZlciBrZXlib2FyZCBmb2N1c2FibGUsIGV2ZW4gd2l0aCB0YWJpbmRleD1cIjBcIiBzZXRcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAnaWZyYW1lJykge1xyXG4gICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXHJcbiAgICAvLyBJbiBXZWJLaXQsIEJsaW5rIGFuZCBHZWNrbyBpZnJhbWVzIG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gY29udGVudC5cclxuICAgIC8vIFNpbmNlIHdlIGNhbid0IHJlbGlhYmx5IGludmVzdGlnYXRlIGlmcmFtZSBkb2N1bWVudHMgYmVjYXVzZSBvZiB0aGVcclxuICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgIC8vIEZpcmVmb3ggY29uc2lkZXJzIHNjcm9sbGFibGUgY29udGFpbmVycyBrZXlib2FyZCBmb2N1c2FibGUsXHJcbiAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBpcyAtMVxyXG4gICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgaWYgKCgwLCBfaXMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwpKF9zdHlsZSkpIHtcclxuICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcclxuICAgIC8vIElFIGFuZCBFZGdlIGRlZ3JhZGUgPGFyZWE+IHRvIHNjcmlwdCBmb2N1c2FibGUsIGlmIHRoZSBpbWFnZVxyXG4gICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxyXG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcclxuICAgICAgdmFyIGltZyA9ICgwLCBfaW1hZ2VNYXAuZ2V0SW1hZ2VPZkFyZWEpKGVsZW1lbnQpO1xyXG4gICAgICBpZiAoaW1nICYmICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoaW1nKSA8IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3N0eWxlMiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgaWYgKCgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKF9zdHlsZTIpKSB7XHJcbiAgICAgIC8vIHByZXZlbnQgYmVpbmcgc3dhbGxvd2VkIGJ5IHRoZSBvdmVyemVhbG91cyBpc1Njcm9sbGFibGVDb250YWluZXIoKSBiZWxvd1xyXG4gICAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXhjZXB0LmZsZXhib3ggJiYgKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkoX3N0eWxlMikpIHtcclxuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3goZWxlbWVudCkgJiYgaXNUYWJiYWJsZVdpdGhvdXRGbGV4Ym94KGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxyXG4gICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgMFxyXG4gICAgaWYgKCgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShlbGVtZW50LCBub2RlTmFtZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB2YXIgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQsIG51bGwpO1xyXG4gICAgICAvLyBJRSBjb25zaWRlcnMgc2Nyb2xsYWJsZSBib2RpZXMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxyXG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKHBhcmVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTEsXHJcbiAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHRhYkluZGV4IHByb3BlcnR5IHN1Z2dlc3RzIG90aGVyd2lzZVxyXG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XHJcbiAgICAgICAgLy8gdmFsdWUgb2YgdGFiaW5kZXggdGFrZXMgcHJlY2VkZW5jZVxyXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNmb2N1c190YWJpbmRleFxyXG4gIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc1RhYmJhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG5cclxuICB2YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzVGFiYmFibGVSdWxlcyh7XHJcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgIGV4Y2VwdDogZXhjZXB0XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpc1RhYmJhYmxlLnJ1bGVzID0gaXNUYWJiYWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc1RhYmJhYmxlO1xyXG59O1xyXG5cclxudmFyIGlzRm9jdXNSZWxldmFudFdpdGhvdXRGbGV4Ym94ID0gX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHsgZmxleGJveDogdHJ1ZSB9KTtcclxudmFyIGlzVGFiYmFibGVXaXRob3V0RmxleGJveCA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoeyBmbGV4Ym94OiB0cnVlIH0pO1xyXG5cclxuLy8gcHJvdmlkZSBpc1RhYmJhYmxlKGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcclxudmFyIGlzVGFiYmFibGUgPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gaXNUYWJiYWJsZTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmJhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICBpZiAoIXN1cHBvcnRzKSB7XHJcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92YWxpZC1hcmVhJyxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcclxuICBpZiAoIXN1cHBvcnRzLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4KSB7XHJcbiAgICAvLyBCbGluayBhbmQgV2ViS2l0IGRvIG5vdCBjb25zaWRlciA8YXJlYSB0YWJpbmRleD1cIi0xXCIgaHJlZj1cIiN2b2lkXCI+IGZvY3VzYWJsZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIGltZyA9ICgwLCBfaW1hZ2VNYXAuZ2V0SW1hZ2VPZkFyZWEpKGVsZW1lbnQpO1xyXG4gIGlmICghaW1nIHx8ICEoMCwgX3Zpc2libGUyLmRlZmF1bHQpKGltZykpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEZpcmVmb3ggb25seSBhbGxvd3MgZnVsbHkgbG9hZGVkIGltYWdlcyB0byByZWZlcmVuY2UgaW1hZ2UgbWFwc1xyXG4gIC8vIGh0dHBzOi8vc3RlcmVvY2hyby5tZS9pZGVhcy9kZXRlY3RpbmctYnJva2VuLWltYWdlcy1qc1xyXG4gIGlmICghc3VwcG9ydHMuZm9jdXNCcm9rZW5JbWFnZU1hcCAmJiAoIWltZy5jb21wbGV0ZSB8fCAhaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHwgaW1nLm9mZnNldEhlaWdodCA8PSAwKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRmlyZWZveCBzdXBwb3J0cy5jYW4gZm9jdXMgYXJlYSBlbGVtZW50cyBldmVuIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbiBocmVmIGF0dHJpYnV0ZVxyXG4gIGlmICghc3VwcG9ydHMuZm9jdXNBcmVhV2l0aG91dEhyZWYgJiYgIWVsZW1lbnQuaHJlZikge1xyXG4gICAgLy8gSW50ZXJuZXQgZXhwbG9yZXIgc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgd2l0aG91dCBocmVmIGlmIGVpdGhlclxyXG4gICAgLy8gdGhlIGFyZWEgZWxlbWVudCBvciB0aGUgaW1hZ2UgZWxlbWVudCBoYXMgYSB0YWJpbmRleCBhdHRyaWJ1dGVcclxuICAgIHJldHVybiBzdXBwb3J0cy5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCB8fCBzdXBwb3J0cy5mb2N1c0FyZWFJbWdUYWJpbmRleCAmJiBpbWcuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxyXG4gIHZhciBjaGlsZE9mSW50ZXJhY3RpdmUgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogaW1nIH0pLnNsaWNlKDEpLnNvbWUoZnVuY3Rpb24gKF9lbGVtZW50KSB7XHJcbiAgICB2YXIgbmFtZSA9IF9lbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2J1dHRvbicgfHwgbmFtZSA9PT0gJ2EnO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoY2hpbGRPZkludGVyYWN0aXZlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XHJcblxyXG52YXIgX3Zpc2libGUgPSByZXF1aXJlKCcuL3Zpc2libGUnKTtcclxuXHJcbnZhciBfdmlzaWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpYmxlKTtcclxuXHJcbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XHJcblxyXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XHJcblxyXG52YXIgX2ltYWdlTWFwID0gcmVxdWlyZSgnLi4vdXRpbC9pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcclxuXHJcbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvbWFwXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvY29yZS5qcyNMODgtTDEwN1xyXG5cclxuLy8gZGV0ZXJtaW5lIGlmIGFuIDxhcmVhPiBlbGVtZW50IGlzIGJlaW5nIHByb3Blcmx5IHVzZWQgYnkgYW5kIDxpbWc+IHZpYSBhIDxtYXA+XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWQtYXJlYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHZhbGlkSW50ZWdlclBhdHRlcm4gPSBzdXBwb3J0cy5mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzID8gdmFsaWRJbnRlZ2VyUGF0dGVybldpdGhUcmFpbGluZyA6IHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nO1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92YWxpZC10YWJpbmRleCcsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIC8vIEVkZ2UgMTQgaGFzIGEgY2FwaXRhbGl6YXRpb24gcHJvYmxlbSBvbiBTVkcgZWxlbWVudHMsXHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzkyODIwNTgvXHJcbiAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XHJcbiAgdmFyIGhhc1RhYkluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XHJcblxyXG4gIGlmICghaGFzVGFiaW5kZXggJiYgIWhhc1RhYkluZGV4KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBvbGRlciBGaXJlZm94IGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkb24ndCBzdXBwb3J0IHRhYmluZGV4IG9uIFNWRyBlbGVtZW50c1xyXG4gIHZhciBpc1N2Z0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnO1xyXG4gIGlmIChpc1N2Z0VsZW1lbnQgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcclxuICBpZiAoc3VwcG9ydHMuZm9jdXNJbnZhbGlkVGFiaW5kZXgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gYW4gZWxlbWVudCBtYXRjaGVzIHRoZSB0YWJpbmRleCBzZWxlY3RvciBldmVuIGlmIGl0cyB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgdmFyIHRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4Jyk7XHJcbiAgLy8gSUUxMSBwYXJzZXMgdGFiaW5kZXg9XCJcIiBhcyB0aGUgdmFsdWUgXCItMzI3NjhcIlxyXG4gIC8vIEBicm93c2VyLWlzc3VlIFRyaWRlbnQgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xMDcyOTY1XHJcbiAgaWYgKHRhYmluZGV4ID09PSAnLTMyNzY4Jykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJvb2xlYW4odGFiaW5kZXggJiYgdmFsaWRJbnRlZ2VyUGF0dGVybi50ZXN0KHRhYmluZGV4KSk7XHJcbn07XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xyXG5cclxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50J3MgdGFiaW5kZXggYXR0cmlidXRlIGhhcyBhIHZhbGlkIHZhbHVlXHJcblxyXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XHJcblxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNydWxlcy1mb3ItcGFyc2luZy1pbnRlZ2Vyc1xyXG4vLyBOT1RFOiBhbGwgYnJvd3NlcnMgYWdyZWUgdG8gYWxsb3cgdHJhaWxpbmcgc3BhY2VzIGFzIHdlbGxcclxudmFyIHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XStcXHMqJC87XHJcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XSsuKiQvO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9hcnJheUZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL3V0aWwvYXJyYXktZmluZC1pbmRleCcpO1xyXG5cclxudmFyIF9hcnJheUZpbmRJbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheUZpbmRJbmRleCk7XHJcblxyXG52YXIgX3BhcmVudHMgPSByZXF1aXJlKCcuLi9nZXQvcGFyZW50cycpO1xyXG5cclxudmFyIF9wYXJlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmVudHMpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZ2V0RnJhbWVFbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZnJhbWUtZWxlbWVudCcpO1xyXG5cclxudmFyIF9nZXRGcmFtZUVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RnJhbWVFbGVtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvcmVuZGVyaW5nLmh0bWwjYmVpbmctcmVuZGVyZWRcclxuLy8gPGFyZWE+IGlzIG5vdCByZW5kZXJlZCwgYnV0IHdlICpjb25zaWRlciogaXQgdmlzaWJsZSB0byBzaW1wbGZpeSB0aGlzIGZ1bmN0aW9uJ3MgdXNhZ2VcclxuXHJcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIHJlbmRlcmVkXHJcbi8vIE5PVEU6IHRoYXQgZG9lcyBub3QgbWVhbiBhbiBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCBzZWUgdXRpbC92aXNpYmxlLWFyZWFcclxuXHJcbnZhciBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybiA9IC9eKGFyZWEpJC87XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3REaXNwbGF5ZWQoX3BhdGgpIHtcclxuICByZXR1cm4gX3BhdGguc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgLy8gZGlzcGxheTpub25lIGlzIG5vdCB2aXNpYmxlIChvcHRpbWl6ZWQgYXdheSBhdCBsYXlvdXQpXHJcbiAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAnZGlzcGxheScpID09PSAnbm9uZSc7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vdFZpc2libGUoX3BhdGgpIHtcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0wxMDktTDExNFxyXG4gIC8vIE5PVEU6IGEgbmVzdGVkIGVsZW1lbnQgY2FuIHJldmVyc2UgdmlzaWJpbGl0eTpoaWRkZW58Y29sbGFwc2UgYnkgZXhwbGljaXRseSBzZXR0aW5nIHZpc2liaWxpdHk6dmlzaWJsZVxyXG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgY2FuIGJlIFtcIlwiLCBcInZpc2libGVcIiwgXCJoaWRkZW5cIiwgXCJjb2xsYXBzZVwiXVxyXG4gIHZhciBoaWRkZW4gPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciB2aXNpYmlsaXR5ID0gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpO1xyXG4gICAgcmV0dXJuIHZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8IHZpc2liaWxpdHkgPT09ICdjb2xsYXBzZSc7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChoaWRkZW4gPT09IC0xKSB7XHJcbiAgICAvLyB0aGVyZSBpcyBubyBoaWRkZW4gZWxlbWVudFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHZpc2libGUgPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsICd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJztcclxuICB9KTtcclxuXHJcbiAgaWYgKHZpc2libGUgPT09IC0xKSB7XHJcbiAgICAvLyB0aGVyZSBpcyBubyB2aXNpYmxlIGVsZW1lbnQgKGJ1dCBhIGhpZGRlbiBlbGVtZW50KVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoaGlkZGVuIDwgdmlzaWJsZSkge1xyXG4gICAgLy8gdGhlcmUgaXMgYSBoaWRkZW4gZWxlbWVudCBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgZmlyc3QgdmlzaWJsZSBlbGVtZW50XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIHRoZXJlIG1heSBiZSBhIGhpZGRlbiBlbGVtZW50LCBidXQgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyB2aXNpYmxlXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpIHtcclxuICB2YXIgb2Zmc2V0ID0gMTtcclxuICBpZiAoX3BhdGhbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1bW1hcnknKSB7XHJcbiAgICBvZmZzZXQgPSAyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9wYXRoLnNsaWNlKG9mZnNldCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgLy8gXCJjb250ZW50IGNoaWxkcmVuXCIgb2YgYSBjbG9zZWQgZGV0YWlscyBlbGVtZW50IGFyZSBub3QgdmlzaWJsZVxyXG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RldGFpbHMnICYmIGVsZW1lbnQub3BlbiA9PT0gZmFsc2U7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmlzaWJsZVJ1bGVzKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcclxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcclxuICAgICAgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcclxuICAgIG5vdFJlbmRlcmVkOiBmYWxzZSxcclxuICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxyXG4gICAgY3NzVmlzaWJpbGl0eTogZmFsc2UsXHJcbiAgICBkZXRhaWxzRWxlbWVudDogZmFsc2UsXHJcbiAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXHJcbiAgfSA6IF9yZWYkZXhjZXB0O1xyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdpcy92aXNpYmxlJyxcclxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmICghZXhjZXB0Lm5vdFJlbmRlcmVkICYmIG5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBfcGF0aCA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xyXG5cclxuICAvLyBpbiBJbnRlcm5ldCBFeHBsb3JlciA8YXVkaW8+IGhhcyBhIGRlZmF1bHQgZGlzcGxheTogbm9uZSwgd2hlcmUgb3RoZXJzIGhhdmUgZGlzcGxheTogaW5saW5lXHJcbiAgLy8gYnV0IElFIGFsbG93cyBmb2N1c2luZyA8YXVkaW8gc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj4sIGJ1dCBub3QgPGRpdiBkaXNwbGF5Om5vbmU+PGF1ZGlvPlxyXG4gIC8vIHRoaXMgaXMgaXJyZWxldmFudCB0byBvdGhlciBicm93c2VycywgYXMgdGhlIGNvbnRyb2xzIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCB0byBtYWtlIDxhdWRpbz4gZm9jdXNhYmxlXHJcbiAgdmFyIGlzQXVkaW9XaXRob3V0Q29udHJvbHMgPSBub2RlTmFtZSA9PT0gJ2F1ZGlvJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XHJcbiAgaWYgKCFleGNlcHQuY3NzRGlzcGxheSAmJiBub3REaXNwbGF5ZWQoaXNBdWRpb1dpdGhvdXRDb250cm9scyA/IF9wYXRoLnNsaWNlKDEpIDogX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5jc3NWaXNpYmlsaXR5ICYmIG5vdFZpc2libGUoX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5kZXRhaWxzRWxlbWVudCAmJiBjb2xsYXBzZWRQYXJlbnQoX3BhdGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV4Y2VwdC5icm93c2luZ0NvbnRleHQpIHtcclxuICAgIC8vIGVsZW1lbnRzIHdpdGhpbiBhIGJyb3dzaW5nIGNvbnRleHQgYXJlIGFmZmVjdGVkIGJ5IHRoZVxyXG4gICAgLy8gYnJvd3NpbmcgY29udGV4dCBob3N0IGVsZW1lbnQncyB2aXNpYmlsaXR5IGFuZCB0YWJpbmRleFxyXG4gICAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICAgIHZhciBfaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KGV4Y2VwdCk7XHJcbiAgICBpZiAoZnJhbWVFbGVtZW50ICYmICFfaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xyXG5pc1Zpc2libGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gIHZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGlzVmlzaWJsZVJ1bGVzKHtcclxuICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgZXhjZXB0OiBleGNlcHRcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlzVmlzaWJsZS5ydWxlcyA9IGlzVmlzaWJsZVJ1bGVzO1xyXG4gIHJldHVybiBpc1Zpc2libGU7XHJcbn07XHJcblxyXG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXHJcbnZhciBpc1Zpc2libGUgPSBpc1Zpc2libGVSdWxlcy5leGNlcHQoe30pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBpc1Zpc2libGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuLypcclxuICBVdGlsaXR5IHRvIG1ha2UgYSBzdWItdHJlZSBvZiB0aGUgRE9NIGluZXJ0LiBJbmVydCBtZWFucyB0aGUgZWxlbWVudHMgY2Fubm90IGJlIGludGVyYWN0ZWRcclxuICB3aXRoIGFuZCB0aGV5IGNhbm5vdCBiZSBmb2N1c2VkIHZpYSBzY3JpcHQsIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXHJcblxyXG4gIGluZXJ0IGF0dHJpYnV0ZSB3YXMgW3JlbW92ZWRdKGh0dHBzOi8vaHRtbDUub3JnL3IvODUzNikgW3R3ZWV0IGJ5IHN0ZXZlXShodHRwczovL3R3aXR0ZXIuY29tL3N0ZXZlZmF1bGtuZXIvc3RhdHVzLzQ0MzA3NTkwMDIwMTI1OTAwOClcclxuICBidXQgZGVmaW5pdGlvbiBvZiBbaW5lcnQgc3VidHJlZXNdKGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lZGl0aW5nLmh0bWwjaW5lcnQtc3VidHJlZXMpIHJlbWFpbnMuXHJcblxyXG4gIFtpbXBsZW1lbnRhdGlvbiBpZGVhIGJ5IFZhc2lsaXNdKGh0dHBzOi8vY29kZXBlbi5pby92YXNpbGlzdmcvcGVuL3Njb3dJKVxyXG4gIFtpbmVydCBhdHRyaWJ1dGUgcG9seWZpbGwgYnkgR29vZ2xlQ2hyb21lXShodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL2luZXJ0LXBvbHlmaWxsKVxyXG5cclxuICBbR2Vja28gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMTUwNClcclxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNjk4NDYpXHJcbiAgW0Nocm9taXVtIEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI0MTY5OSlcclxuICBbV2ViS2l0IEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMDk1MilcclxuKi9cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZjIuY29udGV4dCxcclxuICAgICAgZmlsdGVyID0gX3JlZjIuZmlsdGVyO1xyXG5cclxuICB2YXIgc2VydmljZSA9IG5ldyBJbmVydFN1YnRyZWUoeyBjb250ZXh0OiBjb250ZXh0LCBmaWx0ZXI6IGZpbHRlciB9KTtcclxuICByZXR1cm4geyBkaXNlbmdhZ2U6IHNlcnZpY2UuZGlzZW5nYWdlIH07XHJcbn07XHJcblxyXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcclxuXHJcbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi4vcXVlcnkvZm9jdXNhYmxlJyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF9kaXNhYmxlZCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvZGlzYWJsZWQnKTtcclxuXHJcbnZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xyXG5cclxudmFyIF9zaGFkb3dNdXRhdGlvbnMgPSByZXF1aXJlKCcuLi9vYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnKTtcclxuXHJcbnZhciBfc2hhZG93TXV0YXRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRvd011dGF0aW9ucyk7XHJcblxyXG52YXIgX2NvbXBhcmVQb3NpdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcGFyZS1wb3NpdGlvbicpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBtYWtlRWxlbWVudEluZXJ0KGVsZW1lbnQpIHtcclxuICByZXR1cm4gKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVuZG9FbGVtZW50SW5lcnQoZWxlbWVudCkge1xyXG4gIHJldHVybiAoMCwgX2Rpc2FibGVkMi5kZWZhdWx0KShlbGVtZW50LCBmYWxzZSk7XHJcbn1cclxuXHJcbnZhciBvYnNlcnZlckNvbmZpZyA9IHtcclxuICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gIGNoaWxkTGlzdDogdHJ1ZSxcclxuICBzdWJ0cmVlOiB0cnVlLFxyXG4gIGF0dHJpYnV0ZUZpbHRlcjogWyd0YWJpbmRleCcsICdkaXNhYmxlZCcsICdkYXRhLWFsbHktZGlzYWJsZWQnXVxyXG59O1xyXG5cclxudmFyIEluZXJ0U3VidHJlZSA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBJbmVydFN1YnRyZWUoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICAgIGZpbHRlciA9IF9yZWYuZmlsdGVyO1xyXG5cclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFN1YnRyZWUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRleHQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpWzBdO1xyXG4gICAgdGhpcy5fZmlsdGVyID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKGZpbHRlcik7XHJcbiAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZSA9IFtdO1xyXG5cclxuICAgIHRoaXMuZGlzZW5nYWdlID0gdGhpcy5kaXNlbmdhZ2UuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuaGFuZGxlTXV0YXRpb24gPSB0aGlzLmhhbmRsZU11dGF0aW9uLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnJlbmRlckluZXJ0ID0gdGhpcy5yZW5kZXJJbmVydC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5maWx0ZXJFbGVtZW50cyA9IHRoaXMuZmlsdGVyRWxlbWVudHMuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuZmlsdGVyUGFyZW50RWxlbWVudHMgPSB0aGlzLmZpbHRlclBhcmVudEVsZW1lbnRzLmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIGZvY3VzYWJsZSA9ICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICAgIGNvbnRleHQ6IHRoaXMuX2NvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVDb250ZXh0OiB0cnVlLFxyXG4gICAgICBzdHJhdGVneTogJ2FsbCdcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucmVuZGVySW5lcnQoZm9jdXNhYmxlKTtcclxuXHJcbiAgICB0aGlzLnNoYWRvd09ic2VydmVyID0gKDAsIF9zaGFkb3dNdXRhdGlvbnMyLmRlZmF1bHQpKHtcclxuICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcclxuICAgICAgY29uZmlnOiBvYnNlcnZlckNvbmZpZyxcclxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG11dGF0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5oYW5kbGVNdXRhdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKEluZXJ0U3VidHJlZSwgW3tcclxuICAgIGtleTogJ2Rpc2VuZ2FnZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzZW5nYWdlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVuZG9FbGVtZW50SW5lcnQodGhpcy5fY29udGV4dCk7XHJcbiAgICAgIHRoaXMuX2luZXJ0RWxlbWVudENhY2hlLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdW5kb0VsZW1lbnRJbmVydChlbGVtZW50KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2ZpbHRlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xyXG4gICAgICB0aGlzLnNoYWRvd09ic2VydmVyICYmIHRoaXMuc2hhZG93T2JzZXJ2ZXIuZGlzZW5nYWdlKCk7XHJcbiAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2xpc3RRdWVyeUZvY3VzYWJsZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdFF1ZXJ5Rm9jdXNhYmxlKGxpc3QpIHtcclxuICAgICAgcmV0dXJuIGxpc3RcclxuICAgICAgLy8gZmluZCBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZ2l2ZW4gY29udGV4dHNcclxuICAgICAgLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50LCBpbmNsdWRlQ29udGV4dDogdHJ1ZSwgc3RyYXRlZ3k6ICdhbGwnIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAvLyBmbGF0dGVuIG5lc3RlZCBhcnJheXNcclxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcclxuICAgICAgICByZXR1cm4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpO1xyXG4gICAgICB9LCBbXSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAncmVuZGVySW5lcnQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckluZXJ0KGVsZW1lbnRzKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgICAgdmFyIG1ha2VJbmVydCA9IGZ1bmN0aW9uIG1ha2VJbmVydChlbGVtZW50KSB7XHJcbiAgICAgICAgX3RoaXMyLl9pbmVydEVsZW1lbnRDYWNoZS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIG1ha2VFbGVtZW50SW5lcnQoZWxlbWVudCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBlbGVtZW50cy5maWx0ZXIodGhpcy5maWx0ZXJFbGVtZW50cykuZmlsdGVyKHRoaXMuZmlsdGVyUGFyZW50RWxlbWVudHMpXHJcbiAgICAgIC8vIGlnbm9yZSBlbGVtZW50cyB0aGF0IGFscmVhZHkgYXJlIGRpc2FibGVkXHJcbiAgICAgIC8vIHNvIHdlIGRvbid0IGVuYWJsZSB0aGVtIG9uIGRpc2VuZ2FnZSgpXHJcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gISgwLCBfZGlzYWJsZWQyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gICAgICB9KS5mb3JFYWNoKG1ha2VJbmVydCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnZmlsdGVyRWxlbWVudHMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlckVsZW1lbnRzKGVsZW1lbnQpIHtcclxuICAgICAgLy8gaWdub3JlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZXhlbXB0ZWQgc3ViLXRyZWVzXHJcbiAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9ICgwLCBfY29tcGFyZVBvc2l0aW9uLmdldFBhcmVudENvbXBhcmF0b3IpKHsgZWxlbWVudDogZWxlbWVudCwgaW5jbHVkZVNlbGY6IHRydWUgfSk7XHJcbiAgICAgIHJldHVybiAhdGhpcy5fZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2ZpbHRlclBhcmVudEVsZW1lbnRzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJQYXJlbnRFbGVtZW50cyhlbGVtZW50KSB7XHJcbiAgICAgIC8vIGlnbm9yZSBhbmNlc3RvcnMgb2YgdGhlIGV4ZW1wdGVkIHN1Yi10cmVlc1xyXG4gICAgICB2YXIgaXNQYXJlbnRPZkVsZW1lbnQgPSAoMCwgX2NvbXBhcmVQb3NpdGlvbi5nZXRQYXJlbnRDb21wYXJhdG9yKSh7IHBhcmVudDogZWxlbWVudCB9KTtcclxuICAgICAgcmV0dXJuICF0aGlzLl9maWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnaGFuZGxlTXV0YXRpb24nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xyXG4gICAgICAgIHZhciBhZGRlZEVsZW1lbnRzID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghYWRkZWRFbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhZGRlZEZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5saXN0UXVlcnlGb2N1c2FibGUoYWRkZWRFbGVtZW50cyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJJbmVydChhZGRlZEZvY3VzYWJsZUVsZW1lbnRzKTtcclxuICAgICAgfSBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckluZXJ0KFttdXRhdGlvbi50YXJnZXRdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIEluZXJ0U3VidHJlZTtcclxufSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcclxuXHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBzdXJlIHRoZSBzdXBwb3J0cyB0ZXN0cyBhcmUgcnVuIGJlZm9yZSBpbnRlcmNlcHRpbmcgdGhlIFRhYiBrZXksXHJcbiAgLy8gb3IgSUUxMCBhbmQgSUUxMSB3aWxsIGZhaWwgdG8gcHJvY2VzcyB0aGUgZmlyc3QgVGFiIGtleSBldmVudC4gTm90XHJcbiAgLy8gbGltaXRpbmcgdGhpcyB3YXJtLXVwIHRvIElFIGJlY2F1c2UgaXQgbWF5IGJlIGEgcHJvYmxlbSBlbHNld2hlcmUsIHRvby5cclxuICAoMCwgX3RhYnNlcXVlbmNlMi5kZWZhdWx0KSgpO1xyXG5cclxuICByZXR1cm4gKDAsIF9rZXkyLmRlZmF1bHQpKHtcclxuICAgIC8vIFNhZmFyaSBvbiBPU1ggbWF5IHJlcXVpcmUgQUxUK1RBQiB0byByZWFjaCBsaW5rcyxcclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE0NlxyXG4gICAgJz9hbHQrP3NoaWZ0K3RhYic6IGZ1bmN0aW9uIGFsdFNoaWZ0VGFiKGV2ZW50KSB7XHJcbiAgICAgIC8vIHdlJ3JlIGNvbXBsZXRlbHkgdGFraW5nIG92ZXIgdGhlIFRhYiBrZXkgaGFuZGxpbmdcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIHZhciBzZXF1ZW5jZSA9ICgwLCBfdGFic2VxdWVuY2UyLmRlZmF1bHQpKHtcclxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGJhY2t3YXJkID0gZXZlbnQuc2hpZnRLZXk7XHJcbiAgICAgIHZhciBmaXJzdCA9IHNlcXVlbmNlWzBdO1xyXG4gICAgICB2YXIgbGFzdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgLy8gd3JhcCBhcm91bmQgZmlyc3QgdG8gbGFzdCwgbGFzdCB0byBmaXJzdFxyXG4gICAgICB2YXIgc291cmNlID0gYmFja3dhcmQgPyBmaXJzdCA6IGxhc3Q7XHJcbiAgICAgIHZhciB0YXJnZXQgPSBiYWNrd2FyZCA/IGxhc3QgOiBmaXJzdDtcclxuICAgICAgaWYgKCgwLCBfYWN0aXZlRWxlbWVudDIuZGVmYXVsdCkoc291cmNlKSkge1xyXG4gICAgICAgIHRhcmdldC5mb2N1cygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBjdXJyZW50IHBvc2l0aW9uIGluIHRhYnNlcXVlbmNlXHJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB2b2lkIDA7XHJcbiAgICAgIHZhciBmb3VuZCA9IHNlcXVlbmNlLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKCEoMCwgX2FjdGl2ZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgLy8gcmVkaXJlY3QgdG8gZmlyc3QgYXMgd2UncmUgbm90IGluIG91ciB0YWJzZXF1ZW5jZVxyXG4gICAgICAgIGZpcnN0LmZvY3VzKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzaGlmdCBmb2N1cyB0byBwcmV2aW91cy9uZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlXHJcbiAgICAgIHZhciBvZmZzZXQgPSBiYWNrd2FyZCA/IC0xIDogMTtcclxuICAgICAgc2VxdWVuY2VbY3VycmVudEluZGV4ICsgb2Zmc2V0XS5mb2N1cygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxudmFyIF9hY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaXMvYWN0aXZlLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfYWN0aXZlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hY3RpdmVFbGVtZW50KTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2UgPSByZXF1aXJlKCcuLi9xdWVyeS90YWJzZXF1ZW5jZScpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZSk7XHJcblxyXG52YXIgX2tleSA9IHJlcXVpcmUoJy4uL3doZW4va2V5Jyk7XHJcblxyXG52YXIgX2tleTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWItZm9jdXMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBjb2RlcyBtb3N0bHkgY2xvbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tlaXRoYW11cy9qd2VydHkvYmxvYi9tYXN0ZXIvandlcnR5LmpzXHJcbi8vIGRlbGliZXJhdGVseSBub3QgZXhwb3NpbmcgY2hhcmFjdGVycyBsaWtlIDwsLi0jKiBiZWNhdXNlIHRoZXkgdmFyeSAqd2lsZGx5KlxyXG4vLyBhY3Jvc3Mga2V5Ym9hcmQgbGF5b3V0cyBhbmQgbWF5IGNhdXNlIHZhcmlvdXMgcHJvYmxlbXNcclxuLy8gKGUuZy4gXCIqXCIgaXMgXCJTaGlmdCArXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxyXG4vLyAoZS5nLiBcIkBcIiBpcyBcIkFsdCBMXCIgb24gYSBHZXJtYW4gTWFjIGtleWJvYXJkKVxyXG5cclxudmFyIGtleWNvZGUgPSB7XHJcbiAgLy8gRWxlbWVudCBGb2N1c1xyXG4gIHRhYjogOSxcclxuXHJcbiAgLy8gTmF2aWdhdGlvblxyXG4gIGxlZnQ6IDM3LFxyXG4gIHVwOiAzOCxcclxuICByaWdodDogMzksXHJcbiAgZG93bjogNDAsXHJcbiAgcGFnZVVwOiAzMyxcclxuICAncGFnZS11cCc6IDMzLFxyXG4gIHBhZ2VEb3duOiAzNCxcclxuICAncGFnZS1kb3duJzogMzQsXHJcbiAgZW5kOiAzNSxcclxuICBob21lOiAzNixcclxuXHJcbiAgLy8gQWN0aW9uXHJcbiAgZW50ZXI6IDEzLFxyXG4gIGVzY2FwZTogMjcsXHJcbiAgc3BhY2U6IDMyLFxyXG5cclxuICAvLyBNb2RpZmllclxyXG4gIHNoaWZ0OiAxNixcclxuICBjYXBzTG9jazogMjAsXHJcbiAgJ2NhcHMtbG9jayc6IDIwLFxyXG4gIGN0cmw6IDE3LFxyXG4gIGFsdDogMTgsXHJcbiAgbWV0YTogOTEsXHJcbiAgLy8gaW4gZmlyZWZveDogMjI0XHJcbiAgLy8gb24gbWFjIChjaHJvbWUpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTNcclxuICAvLyBvbiB3aW4gKElFMTEpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTJcclxuICBwYXVzZTogMTksXHJcblxyXG4gIC8vIENvbnRlbnQgTWFuaXB1bGF0aW9uXHJcbiAgaW5zZXJ0OiA0NSxcclxuICAnZGVsZXRlJzogNDYsXHJcbiAgYmFja3NwYWNlOiA4LFxyXG5cclxuICAvLyB0aGUgc2FtZSBsb2dpY2FsIGtleSBtYXkgYmUgaWRlbnRpZmllZCB0aHJvdWdoIGRpZmZlcmVudCBrZXlDb2Rlc1xyXG4gIF9hbGlhczoge1xyXG4gICAgOTE6IFs5MiwgOTMsIDIyNF1cclxuICB9XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbiBrZXlzICgxMTIgLSAxMzcpXHJcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBGMTMrXHJcbmZvciAodmFyIG4gPSAxOyBuIDwgMjY7IG4rKykge1xyXG4gIGtleWNvZGVbJ2YnICsgbl0gPSBuICsgMTExO1xyXG59XHJcblxyXG4vLyBOdW1iZXIga2V5cyAoNDgtNTcsIG51bXBhZCA5Ni0xMDUpXHJcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBudW0tMCtcclxuZm9yICh2YXIgX24gPSAwOyBfbiA8IDEwOyBfbisrKSB7XHJcbiAgdmFyIGNvZGUgPSBfbiArIDQ4O1xyXG4gIHZhciBudW1Db2RlID0gX24gKyA5NjtcclxuICBrZXljb2RlW19uXSA9IGNvZGU7XHJcbiAga2V5Y29kZVsnbnVtLScgKyBfbl0gPSBudW1Db2RlO1xyXG4gIGtleWNvZGUuX2FsaWFzW2NvZGVdID0gW251bUNvZGVdO1xyXG59XHJcblxyXG4vLyBMYXRpbiBjaGFyYWN0ZXJzICg2NSAtIDkwKVxyXG5mb3IgKHZhciBfbjIgPSAwOyBfbjIgPCAyNjsgX24yKyspIHtcclxuICB2YXIgX2NvZGUgPSBfbjIgKyA2NTtcclxuICB2YXIgbmFtZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2NvZGUpLnRvTG93ZXJDYXNlKCk7XHJcbiAga2V5Y29kZVtuYW1lXSA9IF9jb2RlO1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBrZXljb2RlO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Y29kZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXHJcbiAgICAgIGNhbGxiYWNrID0gX3JlZjIuY2FsbGJhY2ssXHJcbiAgICAgIGNvbmZpZyA9IF9yZWYyLmNvbmZpZztcclxuXHJcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JzZXJ2ZS9zaGFkb3ctbXV0YXRpb25zIHJlcXVpcmVzIG9wdGlvbnMuY2FsbGJhY2sgdG8gYmUgYSBmdW5jdGlvbicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ic2VydmUvc2hhZG93LW11dGF0aW9ucyByZXF1aXJlcyBvcHRpb25zLmNvbmZpZyB0byBiZSBhbiBvYmplY3QnKTtcclxuICB9XHJcblxyXG4gIGlmICghd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgIC8vIG5vdCBzdXBwb3J0aW5nIElFMTAgdmlhIE11dGF0aW9uIEV2ZW50cywgYmVjYXVzZSB0aGV5J3JlIHRvbyBleHBlbnNpdmVcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0V2ZW50cy9NdXRhdGlvbl9ldmVudHNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpc2VuZ2FnZTogZnVuY3Rpb24gZGlzZW5nYWdlKCkge31cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xyXG4gICAgbGFiZWw6ICdvYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMnLFxyXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxyXG4gICAgZGVmYXVsdFRvRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgfSk7XHJcblxyXG4gIHZhciBzZXJ2aWNlID0gbmV3IFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoe1xyXG4gICAgY29udGV4dDogZWxlbWVudCxcclxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgIGNvbmZpZzogY29uZmlnXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkaXNlbmdhZ2U6IHNlcnZpY2UuZGlzZW5nYWdlXHJcbiAgfTtcclxufTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9zaGFkb3dIb3N0cyA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3NoYWRvdy1ob3N0cycpO1xyXG5cclxudmFyIF9zaGFkb3dIb3N0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0cyk7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgc2hhZG93T2JzZXJ2ZXJDb25maWcgPSB7XHJcbiAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gIHN1YnRyZWU6IHRydWVcclxufTtcclxuXHJcbnZhciBTaGFkb3dNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICAgIGNhbGxiYWNrID0gX3JlZi5jYWxsYmFjayxcclxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcclxuXHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhZG93TXV0YXRpb25PYnNlcnZlcik7XHJcblxyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgdGhpcy5kaXNlbmdhZ2UgPSB0aGlzLmRpc2VuZ2FnZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XHJcbiAgICB0aGlzLmhvc3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIG11dGF0aW9ucy5mb3JFYWNoKF90aGlzLmhhbmRsZUhvc3RNdXRhdGlvbiwgX3RoaXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vYnNlcnZlQ29udGV4dChjb250ZXh0KTtcclxuICAgIHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIsIFt7XHJcbiAgICBrZXk6ICdkaXNlbmdhZ2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2VuZ2FnZSgpIHtcclxuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciAmJiB0aGlzLmNsaWVudE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuaG9zdE9ic2VydmVyICYmIHRoaXMuaG9zdE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5ob3N0T2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ29ic2VydmVTaGFkb3dIb3N0cycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpIHtcclxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgaG9zdHMgPSAoMCwgX3NoYWRvd0hvc3RzMi5kZWZhdWx0KSh7XHJcbiAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGhvc3RzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMyLm9ic2VydmVDb250ZXh0KGVsZW1lbnQuc2hhZG93Um9vdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ29ic2VydmVDb250ZXh0JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYnNlcnZlQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIub2JzZXJ2ZShjb250ZXh0LCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuaG9zdE9ic2VydmVyLm9ic2VydmUoY29udGV4dCwgc2hhZG93T2JzZXJ2ZXJDb25maWcpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ2hhbmRsZUhvc3RNdXRhdGlvbicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSG9zdE11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlICE9PSAnY2hpbGRMaXN0Jykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFkZGVkRWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobXV0YXRpb24uYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xyXG4gICAgICB9KTtcclxuICAgICAgYWRkZWRFbGVtZW50cy5mb3JFYWNoKHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzLCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBTaGFkb3dNdXRhdGlvbk9ic2VydmVyO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LW11dGF0aW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCxcclxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgICAgX3JlZiRzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3ksXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZiRzdHJhdGVneSA9PT0gdW5kZWZpbmVkID8gJ3F1aWNrJyA6IF9yZWYkc3RyYXRlZ3k7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ3F1ZXJ5L2ZvY3VzYWJsZScsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBjb250ZXh0OiBlbGVtZW50LFxyXG4gICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxyXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxyXG4gIH07XHJcblxyXG4gIGlmIChzdHJhdGVneSA9PT0gJ3F1aWNrJykge1xyXG4gICAgcmV0dXJuICgwLCBfZm9jdXNhYmxlNC5kZWZhdWx0KShvcHRpb25zKTtcclxuICB9IGVsc2UgaWYgKHN0cmF0ZWd5ID09PSAnc3RyaWN0JyB8fCBzdHJhdGVneSA9PT0gJ2FsbCcpIHtcclxuICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdxdWVyeS9mb2N1c2FibGUgcmVxdWlyZXMgb3B0aW9uLnN0cmF0ZWd5IHRvIGJlIG9uZSBvZiBbXCJxdWlja1wiLCBcInN0cmljdFwiLCBcImFsbFwiXScpO1xyXG59O1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcclxuXHJcbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcclxuXHJcbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi9mb2N1c2FibGUuc3RyaWN0Jyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF9mb2N1c2FibGUzID0gcmVxdWlyZSgnLi9mb2N1c2FibGUucXVpY2snKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZTMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBxdWVyeUZvY3VzYWJsZVF1aWNrO1xyXG5cclxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9zZWxlY3Rvci9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTMgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZTMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVF1aWNrKCkge1xyXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcclxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcclxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxyXG4gICAgICBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlO1xyXG5cclxuICB2YXIgX3NlbGVjdG9yID0gKDAsIF9mb2N1c2FibGUyLmRlZmF1bHQpKCk7XHJcbiAgdmFyIGVsZW1lbnRzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKF9zZWxlY3Rvcik7XHJcbiAgLy8gdGhlIHNlbGVjdG9yIHBvdGVudGlhbGx5IG1hdGNoZXMgbW9yZSB0aGFuIHJlYWxseSBpcyBmb2N1c2FibGVcclxuXHJcbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGU0LmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcclxuICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxyXG4gIH0pO1xyXG5cclxuICB2YXIgcmVzdWx0ID0gW10uZmlsdGVyLmNhbGwoZWxlbWVudHMsIF9pc0ZvY3VzYWJsZSk7XHJcblxyXG4gIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXHJcbiAgaWYgKGluY2x1ZGVDb250ZXh0ICYmIF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xyXG4gICAgcmVzdWx0LnVuc2hpZnQoY29udGV4dCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUucXVpY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0O1xyXG5cclxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcclxuXHJcbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XHJcblxyXG52YXIgX2ZvY3VzUmVsZXZhbnQgPSByZXF1aXJlKCcuLi9pcy9mb2N1cy1yZWxldmFudCcpO1xyXG5cclxudmFyIF9mb2N1c1JlbGV2YW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVsZXZhbnQpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoY29uZGl0aW9uKSB7XHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlRmlsdGVyXHJcbiAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XHJcbiAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XHJcbiAgICAgIC8vIHJldHVybiBTaGFkb3dSb290IGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlbSBiZWluZyBmb2N1c2FibGUsXHJcbiAgICAgIC8vIHNvIHRoZXkgY2FuIGJlIHdhbGtlZCByZWN1cnNpdmVseSBsYXRlclxyXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25kaXRpb24obm9kZSkpIHtcclxuICAgICAgLy8gZmluZHMgZWxlbWVudHMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gZm91bmQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpXHJcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgfTtcclxuICAvLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cclxuICAvLyBzZWUgaHR0cDovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjA3LWZpbmRpbmctaHRtbC1jb21tZW50LW5vZGVzLWluLXRoZS1kb20tdXNpbmctdHJlZXdhbGtlci5odG1cclxuICBmaWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcclxuICByZXR1cm4gZmlsdGVyO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXHJcblxyXG52YXIgUG9zc2libHlGb2N1c2FibGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXIoX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQpO1xyXG5cclxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGVTdHJpY3QoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIF9pc0ZvY3VzYWJsZSA9IF9mb2N1c2FibGUyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcclxuICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxyXG4gIH0pO1xyXG5cclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoY29udGV4dCk7XHJcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVUcmVlV2Fsa2VyXHJcbiAgdmFyIHdhbGtlciA9IF9kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxyXG4gIC8vIHJvb3QgZWxlbWVudCB0byBzdGFydCBzZWFyY2ggaW5cclxuICBjb250ZXh0LFxyXG4gIC8vIGVsZW1lbnQgdHlwZSBmaWx0ZXJcclxuICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcclxuICAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcclxuICBzdHJhdGVneSA9PT0gJ2FsbCcgPyBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA6IGNyZWF0ZUZpbHRlcihfaXNGb2N1c2FibGUpLFxyXG4gIC8vIGRlcHJlY2F0ZWQsIGJ1dCBJRSByZXF1aXJlcyBpdFxyXG4gIGZhbHNlKTtcclxuXHJcbiAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICBpZiAod2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgaWYgKF9pc0ZvY3VzYWJsZSh3YWxrZXIuY3VycmVudE5vZGUpKSB7XHJcbiAgICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeUZvY3VzYWJsZVN0cmljdCh7XHJcbiAgICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QsXHJcbiAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICAgICAgfSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxyXG4gIGlmIChpbmNsdWRlQ29udGV4dCkge1xyXG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYWxsJykge1xyXG4gICAgICBpZiAoKDAsIF9mb2N1c1JlbGV2YW50Mi5kZWZhdWx0KShjb250ZXh0KSkge1xyXG4gICAgICAgIGxpc3QudW5zaGlmdChjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChfaXNGb2N1c2FibGUoY29udGV4dCkpIHtcclxuICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxpc3Q7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzYWJsZS5zdHJpY3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5U2hhZG93SG9zdHM7XHJcblxyXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xyXG5cclxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVGaWx0ZXJcclxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XHJcbiAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xyXG4gICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcclxuICB9XHJcblxyXG4gIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xyXG59O1xyXG4vLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cclxuLy8gc2VlIGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjYwNy1maW5kaW5nLWh0bWwtY29tbWVudC1ub2Rlcy1pbi10aGUtZG9tLXVzaW5nLXRyZWV3YWxrZXIuaHRtXHJcbmZpbHRlci5hY2NlcHROb2RlID0gZmlsdGVyO1xyXG5cclxuZnVuY3Rpb24gcXVlcnlTaGFkb3dIb3N0cygpIHtcclxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXHJcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XHJcblxyXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XHJcbiAgICBsYWJlbDogJ3F1ZXJ5L3NoYWRvdy1ob3N0cycsXHJcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXHJcbiAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHRcclxuICB9KTtcclxuXHJcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xyXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlVHJlZVdhbGtlclxyXG4gIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcclxuICAvLyByb290IGVsZW1lbnQgdG8gc3RhcnQgc2VhcmNoIGluXHJcbiAgZWxlbWVudCxcclxuICAvLyBlbGVtZW50IHR5cGUgZmlsdGVyXHJcbiAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXHJcbiAgLy8gY3VzdG9tIE5vZGVGaWx0ZXIgZmlsdGVyXHJcbiAgZmlsdGVyLFxyXG4gIC8vIGRlcHJlY2F0ZWQsIGJ1dCBJRSByZXF1aXJlcyBpdFxyXG4gIGZhbHNlKTtcclxuXHJcbiAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCkge1xyXG4gICAgLy8gVHJlZVdhbGtlciBkb2VzIG5vdCBydW4gdGhlIGZpbHRlciBvbiB0aGUgY29udGV4dCBlbGVtZW50XHJcbiAgICBsaXN0LnB1c2goZWxlbWVudCk7XHJcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlTaGFkb3dIb3N0cyh7XHJcbiAgICAgIGNvbnRleHQ6IGVsZW1lbnQuc2hhZG93Um9vdFxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcclxuICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeVNoYWRvd0hvc3RzKHtcclxuICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3RcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsaXN0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3ctaG9zdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgdmFyIF9pc1RhYmJhYmxlID0gX3RhYmJhYmxlMi5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7XHJcbiAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxyXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcclxuICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxyXG4gIH0pLmZpbHRlcihfaXNUYWJiYWJsZSk7XHJcbn07XHJcblxyXG52YXIgX2ZvY3VzYWJsZSA9IHJlcXVpcmUoJy4vZm9jdXNhYmxlJyk7XHJcblxyXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xyXG5cclxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4uL2lzL3RhYmJhYmxlJyk7XHJcblxyXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9QRi9hcmlhLXByYWN0aWNlcy8ja2V5Ym9hcmRcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiYmFibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxyXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXHJcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcclxuXHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9jb250ZXh0ID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKGNvbnRleHQpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB2YXIgZWxlbWVudHMgPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7XHJcbiAgICBjb250ZXh0OiBfY29udGV4dCxcclxuICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcclxuICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXHJcbiAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICB9KTtcclxuXHJcbiAgaWYgKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTkspIHtcclxuICAgIC8vIHNvcnQgdGFiaW5kZXggbG9jYWxpemVkIHRvIHNoYWRvdyBkb21cclxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzZcclxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTQuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0LCBzb3J0RWxlbWVudHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbGVtZW50cyA9IHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XHJcbiAgICAvLyBpZiB3ZSBpbmNsdWRlIHRoZSBjb250ZXh0IGl0c2VsZiwgaXQgaGFzIHRvIGJlIHRoZSBmaXJzdFxyXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgc2VxdWVuY2VcclxuICAgIGVsZW1lbnRzID0gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgX2NvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRzO1xyXG59O1xyXG5cclxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4vdGFiYmFibGUnKTtcclxuXHJcbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcclxuXHJcbnZhciBfbm9kZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVBcnJheSk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG52YXIgX3RhYnNlcXVlbmNlID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LWFyZWEnKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZTMgPSByZXF1aXJlKCcuL3RhYnNlcXVlbmNlLnNvcnQtc2hhZG93ZWQnKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2U0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UzKTtcclxuXHJcbnZhciBfdGFic2VxdWVuY2U1ID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX3RhYnNlcXVlbmNlNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlNSk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxyXG5cclxuZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgY29udGV4dCkge1xyXG4gIHZhciBwb3MgPSBlbGVtZW50cy5pbmRleE9mKGNvbnRleHQpO1xyXG4gIGlmIChwb3MgPiAwKSB7XHJcbiAgICB2YXIgdG1wID0gZWxlbWVudHMuc3BsaWNlKHBvcywgMSk7XHJcbiAgICByZXR1cm4gdG1wLmNvbmNhdChlbGVtZW50cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpIHtcclxuICBpZiAoc3VwcG9ydHMudGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbikge1xyXG4gICAgLy8gU29tZSBicm93c2VycyBzb3J0IDxhcmVhPiBpbiBET00gb3JkZXIsIHNvbWUgcGxhY2UgdGhlIDxhcmVhPnNcclxuICAgIC8vIHdoZXJlIHRoZSA8aW1nPiByZWZlcmVjaW5nIHRoZW0gd291bGQndmUgYmVlbiBpbiBET00gb3JkZXIuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzVcclxuICAgIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTIuZGVmYXVsdCkoZWxlbWVudHMsIF9jb250ZXh0KTtcclxuICB9XHJcblxyXG4gIGVsZW1lbnRzID0gKDAsIF90YWJzZXF1ZW5jZTYuZGVmYXVsdCkoZWxlbWVudHMpO1xyXG4gIHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuLy8gbW92ZSA8YXJlYT4gZWxlbWVudHMgdG8gdGhlIGxvY2F0aW9uIG9mIHRoZSA8aW1nPiBlbGVtZW50cyB0aGF0IHJlZmVyZW5jZSB0aGVtXHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGNvbnRleHQpIHtcclxuICAvLyBpbWFnZXMgLSB1bmxlc3MgdGhleSBhcmUgZm9jdXNhYmxlIHRoZW1zZWx2ZXMsIGxpa2VseSBub3RcclxuICAvLyBwYXJ0IG9mIHRoZSBlbGVtZW50cyBsaXN0LCBzbyB3ZSdsbCBoYXZlIHRvIGZpbmQgdGhlbSBhbmRcclxuICAvLyBzb3J0IHRoZW0gaW50byB0aGUgZWxlbWVudHMgbGlzdCBtYW51YWxseVxyXG4gIHZhciB1c2VtYXBzID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbdXNlbWFwXScpO1xyXG4gIHZhciBtYXBzID0gbmV3IE1hcHMoY29udGV4dCk7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXHJcbiAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxyXG4gIHZhciBfZWxlbWVudHMgPSBtYXBzLmV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKTtcclxuXHJcbiAgaWYgKCF1c2VtYXBzLmxlbmd0aCkge1xyXG4gICAgLy8gdGhlIGNvbnRleHQgZG9lcyBub3QgY29udGFpbiBhbnkgPGFyZWE+cyBzbyBubyBuZWVkXHJcbiAgICAvLyB0byByZXBsYWNlIGFueXRoaW5nLCBqdXN0IHJlbW92ZSBhbnkgbWFwc1xyXG4gICAgcmV0dXJuIF9lbGVtZW50cztcclxuICB9XHJcblxyXG4gIHJldHVybiAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcclxuICAgIGxpc3Q6IF9lbGVtZW50cyxcclxuICAgIGVsZW1lbnRzOiB1c2VtYXBzLFxyXG4gICAgcmVzb2x2ZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGltYWdlKSB7XHJcbiAgICAgIHZhciBuYW1lID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd1c2VtYXAnKS5zbGljZSgxKTtcclxuICAgICAgcmV0dXJuIG1hcHMuZ2V0QXJlYXNGb3IobmFtZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZSgnLi90YWJiYWJsZScpO1xyXG5cclxudmFyIF90YWJiYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJiYWJsZSk7XHJcblxyXG52YXIgX21lcmdlRG9tT3JkZXIgPSByZXF1aXJlKCcuLi91dGlsL21lcmdlLWRvbS1vcmRlcicpO1xyXG5cclxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbnZhciBfaW1hZ2VNYXAgPSByZXF1aXJlKCcuLi91dGlsL2ltYWdlLW1hcCcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgTWFwcyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBNYXBzKGNvbnRleHQpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBzKTtcclxuXHJcbiAgICB0aGlzLl9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGNvbnRleHQpO1xyXG4gICAgdGhpcy5tYXBzID0ge307XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoTWFwcywgW3tcclxuICAgIGtleTogJ2dldEFyZWFzRm9yJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcmVhc0ZvcihuYW1lKSB7XHJcbiAgICAgIGlmICghdGhpcy5tYXBzW25hbWVdKSB7XHJcbiAgICAgICAgLy8gdGhlIG1hcCBpcyBub3QgZGVmaW5lZCB3aXRoaW4gdGhlIGNvbnRleHQsIHNvIHdlXHJcbiAgICAgICAgLy8gaGF2ZSB0byBnbyBmaW5kIGl0IGVsc2V3aGVyZSBpbiB0aGUgZG9jdW1lbnRcclxuICAgICAgICB0aGlzLmFkZE1hcEJ5TmFtZShuYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMubWFwc1tuYW1lXTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdhZGRNYXBCeU5hbWUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcEJ5TmFtZShuYW1lKSB7XHJcbiAgICAgIHZhciBtYXAgPSAoMCwgX2ltYWdlTWFwLmdldE1hcEJ5TmFtZSkobmFtZSwgdGhpcy5fZG9jdW1lbnQpO1xyXG4gICAgICBpZiAoIW1hcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hcCwgdGhlIGltZ1t1c2VtYXBdIHdhc24ndCBkb2luZyBhbnl0aGluZyBhbnl3YXlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7IGNvbnRleHQ6IG1hcCB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdleHRyYWN0QXJlYXNGcm9tTGlzdCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEFyZWFzRnJvbUxpc3QoZWxlbWVudHMpIHtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCA8YXJlYT4gZWxlbWVudHMgZnJvbSB0aGUgZWxlbWVudHMgbGlzdCxcclxuICAgICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxyXG4gICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hcHNbbWFwLm5hbWVdKSB7XHJcbiAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBNYXBzO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC1hcmVhLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XHJcbiAgdmFyIHNoYWRvd3MgPSBuZXcgU2hhZG93cyhjb250ZXh0LCBzb3J0RWxlbWVudHMpO1xyXG4gIHZhciBfZWxlbWVudHMgPSBzaGFkb3dzLmV4dHJhY3RFbGVtZW50cyhlbGVtZW50cyk7XHJcblxyXG4gIGlmIChfZWxlbWVudHMubGVuZ3RoID09PSBlbGVtZW50cy5sZW5ndGgpIHtcclxuICAgIC8vIG5vIHNoYWRvd2VkIGNvbnRlbnQgZm91bmQsIG5vIG5lZWQgdG8gY29udGludWVcclxuICAgIHJldHVybiBzb3J0RWxlbWVudHMoZWxlbWVudHMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNoYWRvd3Muc29ydChfZWxlbWVudHMpO1xyXG59O1xyXG5cclxudmFyIF9zaGFkb3dIb3N0ID0gcmVxdWlyZSgnLi4vZ2V0L3NoYWRvdy1ob3N0Jyk7XHJcblxyXG52YXIgX3NoYWRvd0hvc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhZG93SG9zdCk7XHJcblxyXG52YXIgX21lcmdlRG9tT3JkZXIgPSByZXF1aXJlKCcuLi91dGlsL21lcmdlLWRvbS1vcmRlcicpO1xyXG5cclxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xyXG5cclxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xyXG5cclxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cykge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRvd3MpO1xyXG5cclxuICAgIC8vIGRvY3VtZW50IGNvbnRleHQgd2UncmUgd29ya2luZyB3aXRoXHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgLy8gY2FsbGJhY2sgdGhhdCBzb3J0cyBhbiBhcnJheSBvZiBlbGVtZW50c1xyXG4gICAgdGhpcy5zb3J0RWxlbWVudHMgPSBzb3J0RWxlbWVudHM7XHJcbiAgICAvLyByZWZlcmVuY2UgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggU2hhZG93SG9zdFxyXG4gICAgdGhpcy5ob3N0Q291bnRlciA9IDE7XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0cyBvZiBhIFNoYWRvd0hvc3RcclxuICAgIHRoaXMuaW5Ib3N0ID0ge307XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0IG9mIHRoZSBkb2N1bWVudFxyXG4gICAgdGhpcy5pbkRvY3VtZW50ID0gW107XHJcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBTaGFkb3dIb3N0c1xyXG4gICAgdGhpcy5ob3N0cyA9IHt9O1xyXG4gICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgdGFiYmFibGUgZWxlbWVudHMgb2YgYSBTaGFkb3dIb3N0XHJcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XHJcbiAgfVxyXG5cclxuICAvLyByZW1lbWJlciB3aGljaCBob3N0cyB3ZSBoYXZlIHRvIHNvcnQgd2l0aGluIGxhdGVyXHJcblxyXG5cclxuICBfY3JlYXRlQ2xhc3MoU2hhZG93cywgW3tcclxuICAgIGtleTogJ19yZWdpc3Rlckhvc3QnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3QoaG9zdCkge1xyXG4gICAgICBpZiAoaG9zdC5fc29ydGluZ0lkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtYWtlIHRoZSBTaGFkb3dIb3N0IGlkZW50aWZpYWJsZSAoc2VlIGNsZWFudXAoKSBmb3IgdW5kbylcclxuICAgICAgaG9zdC5fc29ydGluZ0lkID0gJ3NoYWRvdy0nICsgdGhpcy5ob3N0Q291bnRlcisrO1xyXG4gICAgICB0aGlzLmhvc3RzW2hvc3QuX3NvcnRpbmdJZF0gPSBob3N0O1xyXG5cclxuICAgICAgLy8gaG9zdHMgbWF5IGNvbnRhaW4gb3RoZXIgaG9zdHNcclxuICAgICAgdmFyIHBhcmVudEhvc3QgPSAoMCwgX3NoYWRvd0hvc3QyLmRlZmF1bHQpKHsgY29udGV4dDogaG9zdCB9KTtcclxuICAgICAgaWYgKHBhcmVudEhvc3QpIHtcclxuICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QocGFyZW50SG9zdCk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudEhvc3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5Eb2N1bWVudC5wdXNoKGhvc3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtZW1iZXIgd2hpY2ggaG9zdCBpcyB0aGUgY2hpbGQgb2Ygd2hpY2ggb3RoZXIgaG9zdFxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0UGFyZW50JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSkge1xyXG4gICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0ucHVzaChob3N0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZW1lbWJlciB3aGljaCBlbGVtZW50cyBhIGhvc3QgY29udGFpbnNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnX3JlZ2lzdGVyRWxlbWVudCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KSB7XHJcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSBzaGFkb3dlZCBlbGVtZW50cyBmcm9tIHRoZSBzZXF1ZW5jZSBhbmQgcmVnaXN0ZXJcclxuICAgIC8vIHRoZSBTaGFkb3dIb3N0cyB0aGV5IGJlbG9uZyB0byBzbyB3ZSBrbm93IHdoYXQgdG8gc29ydFxyXG4gICAgLy8gbGF0ZXIgb25cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnZXh0cmFjdEVsZW1lbnRzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0RWxlbWVudHMoZWxlbWVudHMpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBob3N0ID0gKDAsIF9zaGFkb3dIb3N0Mi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XHJcbiAgICAgICAgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdChob3N0KTtcclxuICAgICAgICB0aGlzLl9yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgaG9zdCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbmplY3QgaG9zdHMgaW50byB0aGUgc2VxdWVuY2UsIHNvcnQgZXZlcnl0aGluZyxcclxuICAgIC8vIGFuZCByZWNvdXJzaXZlbHkgcmVwbGFjZSBob3N0cyBieSBpdHMgZGVzY2VuZGFudHNcclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnc29ydCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChlbGVtZW50cykge1xyXG4gICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5faW5qZWN0SG9zdHMoZWxlbWVudHMpO1xyXG4gICAgICBfZWxlbWVudHMgPSB0aGlzLl9yZXBsYWNlSG9zdHMoX2VsZW1lbnRzKTtcclxuICAgICAgdGhpcy5fY2xlYW51cCgpO1xyXG4gICAgICByZXR1cm4gX2VsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1lcmdlIFNoYWRvd0hvc3RzIGludG8gdGhlIGVsZW1lbnQgbGlzdHMgb2Ygb3RoZXIgU2hhZG93SG9zdHNcclxuICAgIC8vIG9yIHRoZSBkb2N1bWVudCwgdGhlbiBzb3J0IHRoZSBpbmRpdmlkdWFsIGxpc3RzXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ19pbmplY3RIb3N0cycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luamVjdEhvc3RzKGVsZW1lbnRzKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goZnVuY3Rpb24gKF9zb3J0aW5nSWQpIHtcclxuICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdO1xyXG4gICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLmluSG9zdFtfc29ydGluZ0lkXTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSB0aGlzLmhvc3RzW19zb3J0aW5nSWRdLnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfc29ydGluZ0lkXSA9IHRoaXMuX21lcmdlKF9saXN0LCBfZWxlbWVudHMsIF9jb250ZXh0KTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZWxlbWVudHMsIHRoaXMuaW5Eb2N1bWVudCwgdGhpcy5jb250ZXh0KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfbWVyZ2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZShsaXN0LCBlbGVtZW50cywgY29udGV4dCkge1xyXG4gICAgICB2YXIgbWVyZ2VkID0gKDAsIF9tZXJnZURvbU9yZGVyMi5kZWZhdWx0KSh7XHJcbiAgICAgICAgbGlzdDogbGlzdCxcclxuICAgICAgICBlbGVtZW50czogZWxlbWVudHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5zb3J0RWxlbWVudHMobWVyZ2VkLCBjb250ZXh0KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVwbGFjZUhvc3RzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwbGFjZUhvc3RzKGVsZW1lbnRzKSB7XHJcbiAgICAgIHJldHVybiAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcclxuICAgICAgICBsaXN0OiBlbGVtZW50cyxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5pbkRvY3VtZW50LFxyXG4gICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfcmVzb2x2ZUhvc3RFbGVtZW50JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzb2x2ZUhvc3RFbGVtZW50KGhvc3QpIHtcclxuICAgICAgdmFyIG1lcmdlZCA9ICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xyXG4gICAgICAgIGxpc3Q6IHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5pbkhvc3RbaG9zdC5fc29ydGluZ0lkXSxcclxuICAgICAgICByZXNvbHZlRWxlbWVudDogdGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcylcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShob3N0KTtcclxuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPiAtMSkge1xyXG4gICAgICAgIHJldHVybiBbaG9zdF0uY29uY2F0KG1lcmdlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX2NsZWFudXAnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKCkge1xyXG4gICAgICAvLyByZW1vdmUgdGhvc2UgaWRlbnRpZmVycyB3ZSBwdXQgb24gdGhlIFNoYWRvd0hvc3QgdG8gYXZvaWQgdXNpbmcgTWFwKClcclxuICAgICAgT2JqZWN0LmtleXModGhpcy5ob3N0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdHNba2V5XS5fc29ydGluZ0lkO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBTaGFkb3dzO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC1zaGFkb3dlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC50YWJJbmRleFxyXG4gIC8vIGVsZW1lbnRzIHdpdGggdGFiSW5kZXggXCIwXCIgKGluY2x1ZGluZyB0YWJiYWJsZUVsZW1lbnRzIHdpdGhvdXQgdGFiSW5kZXgpIHNob3VsZCBiZSBuYXZpZ2F0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyLlxyXG4gIC8vIGVsZW1lbnRzIHdpdGggYSBwb3NpdGl2ZSB0YWJJbmRleDpcclxuICAvLyAgIEVsZW1lbnRzIHRoYXQgaGF2ZSBpZGVudGljYWwgdGFiSW5kZXhlcyBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cclxuICAvLyAgIE5hdmlnYXRpb24gcHJvY2VlZHMgZnJvbSB0aGUgbG93ZXN0IHRhYkluZGV4IHRvIHRoZSBoaWdoZXN0IHRhYkluZGV4LlxyXG5cclxuICAvLyBOT1RFOiBzb3J0IGltcGxlbWVudGF0aW9uIG1heSBiZSB1bnN0YWJsZSBhbmQgdGh1cyBtZXNzIHVwIERPTSBvcmRlcixcclxuICAvLyB0aGF0J3Mgd2h5IHdlIGJ1aWxkIGEgbWFwIHRoYXQncyBiZWluZyBzb3J0ZWQgaW5zdGVhZC4gSWYgd2Ugd2VyZSBhYmxlIHRvIHJlbHlcclxuICAvLyBvbiBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobSwgc29ydFRhYmluZGV4KCkgY291bGQgYmUgYXMgc2ltcGxlIGFzXHJcbiAgLy8gZWxlbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDsgfSk7XHJcbiAgLy8gYXQgdGhpcyB0aW1lIENocm9tZSBkb2VzIG5vdCB1c2UgYSBzdGFibGUgc29ydGluZyBhbGdvcml0aG1cclxuICAvLyBzZWUgaHR0cDovL2Jsb2cucm9kbmV5cmVobS5kZS9hcmNoaXZlcy8xNC1Tb3J0aW5nLVdlcmUtRG9pbmctSXQtV3JvbmcuaHRtbCNzdGFiaWxpdHlcclxuXHJcbiAgLy8gTk9URTogY29tcGFyZURvY3VtZW50UG9zaXRpb24gc2VlbWVkIGxpa2UgbW9yZSBvdmVyaGVhZCB0aGFuIGp1c3Qgc29ydGluZyB0aGlzIHdpdGggYnVja2V0c1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXHJcblxyXG4gIHZhciBtYXAgPSB7fTtcclxuICB2YXIgaW5kZXhlcyA9IFtdO1xyXG4gIHZhciBub3JtYWwgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIC8vIGluIFRyaWRlbnQgYW5kIEdlY2tvIFNWR0VsZW1lbnQgZG9lcyBub3Qga25vdyBhYm91dCB0aGUgdGFiSW5kZXggcHJvcGVydHlcclxuICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQudGFiSW5kZXg7XHJcbiAgICBpZiAodGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0YWJJbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXh0cmFjdCBlbGVtZW50cyB0aGF0IGRvbid0IG5lZWQgc29ydGluZ1xyXG4gICAgaWYgKHRhYkluZGV4IDw9IDAgfHwgdGFiSW5kZXggPT09IG51bGwgfHwgdGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1hcFt0YWJJbmRleF0pIHtcclxuICAgICAgLy8gY3JlYXRlIHNvcnRhYmxlIGJ1Y2tldCBmb3IgZG9tLW9yZGVyLXByZXNlcnZhdGlvbiBvZiBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHRhYkluZGV4XHJcbiAgICAgIG1hcFt0YWJJbmRleF0gPSBbXTtcclxuICAgICAgLy8gbWFpbnRhaW4gYSBsaXN0IG9mIHVuaXF1ZSB0YWJJbmRleGVzXHJcbiAgICAgIGluZGV4ZXMucHVzaCh0YWJJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc29ydCBlbGVtZW50IGludG8gdGhlIHByb3BlciBidWNrZXRcclxuICAgIG1hcFt0YWJJbmRleF0ucHVzaChlbGVtZW50KTtcclxuICAgIC8vIGVsZW1lbnQgbW92ZWQgdG8gc29ydGluZyBtYXAsIHNvIG5vdCBcIm5vcm1hbFwiIGFueW1vcmVcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9KTtcclxuXHJcbiAgLy8gc29ydCB0aGUgdGFiaW5kZXggYXNjZW5kaW5nLFxyXG4gIC8vIHRoZW4gcmVzb2x2ZSB0aGVtIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGJ1Y2tldHMsXHJcbiAgLy8gdGhlbiBmbGF0dGVuIHRoZSBhcnJheSBvZiBhcnJheXMgdG8gYW4gYXJyYXlcclxuICB2YXIgX2VsZW1lbnRzID0gaW5kZXhlcy5zb3J0KCkubWFwKGZ1bmN0aW9uICh0YWJJbmRleCkge1xyXG4gICAgcmV0dXJuIG1hcFt0YWJJbmRleF07XHJcbiAgfSkucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XHJcbiAgICByZXR1cm4gY3VycmVudC5jb25jYXQocHJldmlvdXMpO1xyXG4gIH0sIG5vcm1hbCk7XHJcblxyXG4gIHJldHVybiBfZWxlbWVudHM7XHJcbn07XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XHJcblxyXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCFzdXBwb3J0cykge1xyXG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBzZWxlY3RvcjtcclxuICB9XHJcblxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXHJcbiAgc2VsZWN0b3IgPSAnJ1xyXG4gIC8vIElFMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDx0YWJsZT4gYW5kIDx0ZD5cclxuICArIChzdXBwb3J0cy5mb2N1c1RhYmxlID8gJ3RhYmxlLCB0ZCwnIDogJycpXHJcbiAgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxyXG4gICsgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXQgPyAnZmllbGRzZXQsJyA6ICcnKVxyXG4gIC8vIE5hbWVzcGFjZSBwcm9ibGVtcyBvZiBbeGxpbms6aHJlZl0gZXhwbGFpbmVkIGluIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzA0Nzg4OC81MTUxMjRcclxuICAvLyBzdmcgYVsqfGhyZWZdIGRvZXMgbm90IG1hdGNoIGluIElFOSwgYnV0IHNpbmNlIHdlJ3JlIGZpbHRlcmluZ1xyXG4gIC8vIHRocm91Z2ggaXMvZm9jdXNhYmxlIHdlIGNhbiBpbmNsdWRlIGFsbCA8YT4gZnJvbSBTVkdcclxuICArICdzdmcgYSwnXHJcbiAgLy8gbWF5IGJlaGF2ZSBhcyAnc3ZnLCBzdmcgKiwnIGluIGNocm9tZSBhcyAqZXZlcnkqIHN2ZyBlbGVtZW50IHdpdGggYSBmb2N1cyBldmVudCBsaXN0ZW5lciBpcyBmb2N1c2FibGVcclxuICAvLyBuYXZpZ2F0aW9uYWwgZWxlbWVudHNcclxuICArICdhW2hyZWZdLCdcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLWFyZWEuanNcclxuICArICdhcmVhW2hyZWZdLCdcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL2Rpc2FibGVkLmpzXHJcbiAgKyAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwnXHJcbiAgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXHJcbiAgKyAnaWZyYW1lLCBvYmplY3QsIGVtYmVkLCdcclxuICAvLyBpbnRlcmFjdGl2ZSBjb250ZW50XHJcbiAgKyAna2V5Z2VuLCcgKyAoc3VwcG9ydHMuZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyA/ICdhdWRpbywnIDogJ2F1ZGlvW2NvbnRyb2xzXSwnKSArIChzdXBwb3J0cy5mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID8gJ3ZpZGVvLCcgOiAndmlkZW9bY29udHJvbHNdLCcpICsgKHN1cHBvcnRzLmZvY3VzU3VtbWFyeSA/ICdzdW1tYXJ5LCcgOiAnJylcclxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLXRhYmluZGV4LmpzXHJcbiAgKyAnW3RhYmluZGV4XSwnXHJcbiAgLy8gZWRpdGluZyBob3N0c1xyXG4gICsgJ1tjb250ZW50ZWRpdGFibGVdJztcclxuXHJcbiAgLy8gd2hlcmUgU2hhZG93RE9NIGlzIHN1cHBvcnRlZCwgd2UgYWxzbyB3YW50IHRoZSBzaGFkb3dlZCBmb2N1c2FibGUgZWxlbWVudHMgKHZpYSBcIj4+PlwiIG9yIFwiL2RlZXAvXCIpXHJcbiAgc2VsZWN0b3IgPSAoMCwgX3NlbGVjdEluU2hhZG93czIuZGVmYXVsdCkoc2VsZWN0b3IpO1xyXG5cclxuICByZXR1cm4gc2VsZWN0b3I7XHJcbn07XHJcblxyXG52YXIgX3NlbGVjdEluU2hhZG93cyA9IHJlcXVpcmUoJy4uL3V0aWwvc2VsZWN0LWluLXNoYWRvd3MnKTtcclxuXHJcbnZhciBfc2VsZWN0SW5TaGFkb3dzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdEluU2hhZG93cyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XHJcblxyXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTk9URTogdGhpcyBzZWxlY3RvciBNVVNUICpuZXZlciogYmUgdXNlZCBkaXJlY3RseSxcclxuLy8gYWx3YXlzIGdvIHRocm91Z2ggcXVlcnkvZm9jdXNhYmxlIG9yIGlzL2ZvY3VzYWJsZS5qc1xyXG4vLyB0aGVyZSBhcmUgdG9vIG1hbnkgZWRnZSBjYXNlcyB0aGF0IHRoZXkgY291bGQgYmUgY292ZXJlZCBpblxyXG4vLyBhIHNpbXBsZSBDU1Mgc2VsZWN0b3LigKZcclxuXHJcbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcclxuXHJcbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGNvbWJpbmF0b3IgPSB2b2lkIDA7XHJcblxyXG4gIC8vIHNlZSBodHRwczovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXNjb3BpbmctMS8jZGVlcC1jb21iaW5hdG9yXHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTExNzU3MlxyXG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcclxuICB0cnkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCA+Pj4gOmZpcnN0LWNoaWxkJyk7XHJcbiAgICBjb21iaW5hdG9yID0gJz4+Pic7XHJcbiAgfSBjYXRjaCAobm9BcnJvd0Fycm93QXJyb3cpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIG9sZCBzeW50YXggc3VwcG9ydGVkIGF0IGxlYXN0IHVwIHRvIENocm9tZSA0MVxyXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ2MDUxXHJcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZCcpO1xyXG4gICAgICBjb21iaW5hdG9yID0gJy9kZWVwLyc7XHJcbiAgICB9IGNhdGNoIChub0RlZXApIHtcclxuICAgICAgY29tYmluYXRvciA9ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbWJpbmF0b3I7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodGVzdHMpIHtcclxuICB2YXIgZGF0YSA9IGJlZm9yZSgpO1xyXG5cclxuICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gIE9iamVjdC5rZXlzKHRlc3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmVzdWx0c1trZXldID0gdGVzdChkYXRhLCB0ZXN0c1trZXldKTtcclxuICB9KTtcclxuXHJcbiAgYWZ0ZXIoZGF0YSk7XHJcbiAgcmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gYmVmb3JlKCkge1xyXG4gIHZhciBkYXRhID0ge1xyXG4gICAgLy8gcmVtZW1iZXIgd2hhdCBoYWQgZm9jdXMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XHJcbiAgICBhY3RpdmVFbGVtZW50OiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LFxyXG4gICAgLy8gcmVtZW1iZXIgc2Nyb2xsIHBvc2l0aW9ucyB0byByZXN0b3JlIGFmdGVyIHRlc3RcclxuICAgIHdpbmRvd1Njcm9sbFRvcDogd2luZG93LnNjcm9sbFRvcCxcclxuICAgIHdpbmRvd1Njcm9sbExlZnQ6IHdpbmRvdy5zY3JvbGxMZWZ0LFxyXG4gICAgYm9keVNjcm9sbFRvcDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXHJcbiAgICBib2R5U2Nyb2xsTGVmdDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XHJcbiAgfTtcclxuXHJcbiAgLy8gd3JhcCB0ZXN0cyBpbiBhbiBlbGVtZW50IGhpZGRlbiBmcm9tIHNjcmVlbiByZWFkZXJzIHRvIHByZXZlbnQgdGhlbVxyXG4gIC8vIGZyb20gYW5ub3VuY2luZyBmb2N1cywgd2hpY2ggY2FuIGJlIHF1aXRlIGlycml0YXRpbmcgdG8gdGhlIHVzZXJcclxuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAncG9zaXRpb246YWJzb2x1dGU7IHBvc2l0aW9uOmZpeGVkOyB0b3A6MDsgbGVmdDotMnB4OyB3aWR0aDoxcHg7IGhlaWdodDoxcHg7IG92ZXJmbG93OmhpZGRlbjsnKTtcclxuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XHJcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG5cclxuICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xyXG4gIHZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xyXG5cclxuICBfZG9jdW1lbnQub3BlbigpO1xyXG4gIF9kb2N1bWVudC5jbG9zZSgpO1xyXG4gIHZhciB3cmFwcGVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xyXG5cclxuICBkYXRhLmlmcmFtZSA9IGlmcmFtZTtcclxuICBkYXRhLndyYXBwZXIgPSB3cmFwcGVyO1xyXG4gIGRhdGEud2luZG93ID0gX3dpbmRvdztcclxuICBkYXRhLmRvY3VtZW50ID0gX2RvY3VtZW50O1xyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuLy8gb3B0aW9ucy5lbGVtZW50OlxyXG4vLyAge3N0cmluZ30gZWxlbWVudCBuYW1lXHJcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKHdyYXBwZXIsIGRvY3VtZW50KSB0byBnZW5lcmF0ZSBhbiBlbGVtZW50XHJcbi8vIG9wdGlvbnMubXV0YXRlOiAob3B0aW9uYWwpXHJcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKGVsZW1lbnQsIHdyYXBwZXIsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIGVsZW1lbnQgcHJpb3IgdG8gZm9jdXMtdGVzdC5cclxuLy8gICAgICAgICAgICAgQ2FuIHJldHVybiBET01FbGVtZW50IHRvIGRlZmluZSBmb2N1cyB0YXJnZXQgKGRlZmF1bHQ6IGVsZW1lbnQpXHJcbi8vIG9wdGlvbnMudmFsaWRhdGU6IChvcHRpb25hbClcclxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2soZWxlbWVudCwgZm9jdXNUYXJnZXQsIGRvY3VtZW50KSB0byBtYW5pcHVsYXRlIHRlc3QtcmVzdWx0XHJcbmZ1bmN0aW9uIHRlc3QoZGF0YSwgb3B0aW9ucykge1xyXG4gIC8vIG1ha2Ugc3VyZSB3ZSBvcGVyYXRlIG9uIGEgY2xlYW4gc2xhdGVcclxuICBkYXRhLndyYXBwZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgLy8gY3JlYXRlIGR1bW15IGVsZW1lbnQgdG8gdGVzdCBmb2N1c2FiaWxpdHkgb2ZcclxuICB2YXIgZWxlbWVudCA9IHR5cGVvZiBvcHRpb25zLmVsZW1lbnQgPT09ICdzdHJpbmcnID8gZGF0YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMuZWxlbWVudCkgOiBvcHRpb25zLmVsZW1lbnQoZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcclxuICAvLyBhbGxvdyBjYWxsYmFjayB0byBmdXJ0aGVyIHNwZWNpZnkgZHVtbXkgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGRlZmluZSBlbGVtZW50IHRvIGZvY3VzXHJcbiAgdmFyIGZvY3VzID0gb3B0aW9ucy5tdXRhdGUgJiYgb3B0aW9ucy5tdXRhdGUoZWxlbWVudCwgZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcclxuICBpZiAoIWZvY3VzICYmIGZvY3VzICE9PSBmYWxzZSkge1xyXG4gICAgZm9jdXMgPSBlbGVtZW50O1xyXG4gIH1cclxuICAvLyBlbGVtZW50IG5lZWRzIHRvIGJlIHBhcnQgb2YgdGhlIERPTSB0byBiZSBmb2N1c2FibGVcclxuICAhZWxlbWVudC5wYXJlbnROb2RlICYmIGRhdGEud3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICAvLyB0ZXN0IGlmIHRoZSBlbGVtZW50IHdpdGggaW52YWxpZCB0YWJpbmRleCBjYW4gYmUgZm9jdXNlZFxyXG4gIGZvY3VzICYmIGZvY3VzLmZvY3VzICYmIGZvY3VzLmZvY3VzKCk7XHJcbiAgLy8gdmFsaWRhdGUgdGVzdCdzIHJlc3VsdFxyXG4gIHJldHVybiBvcHRpb25zLnZhbGlkYXRlID8gb3B0aW9ucy52YWxpZGF0ZShlbGVtZW50LCBmb2N1cywgZGF0YS5kb2N1bWVudCkgOiBkYXRhLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZnRlcihkYXRhKSB7XHJcbiAgLy8gcmVzdG9yZSBmb2N1cyB0byB3aGF0IGl0IHdhcyBiZWZvcmUgdGVzdCBhbmQgY2xlYW51cFxyXG4gIGlmIChkYXRhLmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JRTEwKSB7XHJcbiAgICAgIC8vIElFMTAgZG9lcyBub3QgcmVkaXJlY3QgZm9jdXMgdG8gPGJvZHk+IHdoZW4gdGhlIGFjdGl2ZUVsZW1lbnQgaXMgcmVtb3ZlZFxyXG4gICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGEuYWN0aXZlRWxlbWVudCAmJiBkYXRhLmFjdGl2ZUVsZW1lbnQuZm9jdXMgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRhdGEuaWZyYW1lKTtcclxuXHJcbiAgLy8gcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cclxuICB3aW5kb3cuc2Nyb2xsVG9wID0gZGF0YS53aW5kb3dTY3JvbGxUb3A7XHJcbiAgd2luZG93LnNjcm9sbExlZnQgPSBkYXRhLndpbmRvd1Njcm9sbExlZnQ7XHJcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBkYXRhLmJvZHlTY3JvbGxUb3A7XHJcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID0gZGF0YS5ib2R5U2Nyb2xsTGVmdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdC1mb2N1cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXJlYS1pbWctdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XHJcblxyXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JyArICc8YXJlYSBocmVmPVwiI3ZvaWRcIiB0YWJpbmRleD1cIi0xXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIGFsdD1cIlwiIHNyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiPic7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcclxuICAgIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08pIHtcclxuICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxyXG4gICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZvY3VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgICBmb2N1cy5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1hcmVhLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XHJcblxyXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbiAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWFyZWEtd2l0aG91dC1ocmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9tcCA9IHJlcXVpcmUoJy4vbWVkaWEvbXAzJyk7XHJcblxyXG52YXIgX21wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21wKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgbmFtZTogJ2Nhbi1mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyxcclxuICBlbGVtZW50OiAnYXVkaW8nLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGludmFsaWQgbWVkaWEgZmlsZSBjYW4gdHJpZ2dlciB3YXJuaW5nIGluIGNvbnNvbGUsIGRhdGEtdXJpIHRvIHByZXZlbnQgSFRUUCByZXF1ZXN0XHJcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBfbXAyLmRlZmF1bHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJRTkgbWF5IHRocm93IFwiRXJyb3I6IE5vdCBpbXBsZW1lbnRlZFwiXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYuaW52YWxpZCcpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImJyb2tlbi1pbWFnZS1tYXAtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYnJva2VuLWltYWdlLW1hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7Jyk7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7XHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBmaWVsZHNldFt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUsIGJ1dCBCbGluayBhbmQgV2ViS2l0IGRpc2FncmVlXHJcbi8vIEBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxyXG4vLyBAYnJvd3Nlci1pc3N1ZSBDaHJvbWl1bSBodHRwczovL2NyYnVnLmNvbS80NTM4NDdcclxuLy8gQGJyb3dzZXItaXNzdWUgV2ViS2l0IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDEwODZcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1maWVsZHNldC1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPic7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtZmllbGRzZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdzcGFuJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1mbGV4Ym94LWNvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIGZvcm1bdGFiaW5kZXg9MF1bZGlzYWJsZWRdIHNob3VsZCBiZSBmb2N1c2FibGUgYXMgdGhlXHJcbi8vIHNwZWNpZmljYXRpb24gZG9lc24ndCBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIGZvcm0gZWxlbWVudFxyXG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN0aGUtZm9ybS1lbGVtZW50XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZm9ybScsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1mb3JtLWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XHJcbi8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjBcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLWlzbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnYScsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5ocmVmID0gJyN2b2lkJztcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxpbWcgaXNtYXAgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCIgYWx0PVwiXCI+JztcclxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy1pc21hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgJyArICdzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy11c2VtYXAtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KHdyYXBwZXIsIF9kb2N1bWVudCkge1xyXG4gICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuXHJcbiAgICAvLyBpZnJhbWUgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gYmVmb3JlIGFjY2Vzc2luZyB0aGUgY29udGVudFdpbmRvdyBpcyBwb3NzaWJsZVxyXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lJ3MgZGVmYXVsdCBkb2N1bWVudCAoPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+KVxyXG4gICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gICAgcmV0dXJuIGlmcmFtZTtcclxuICB9LFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGlmcmFtZSkge1xyXG4gICAgaWZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgIHZhciBpbnB1dCA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBpZnJhbWVEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgIHJldHVybiBpbnB1dDtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShpZnJhbWUpIHtcclxuICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gICAgdmFyIGZvY3VzID0gaWZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbi1oaWRkZW4taWZyYW1lLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIHJlc3VsdCA9ICFfcGxhdGZvcm0yLmRlZmF1bHQuaXMuV0VCS0lUO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIEZpcmVmb3ggYWxsb3dzICphbnkqIHZhbHVlIGFuZCB0cmVhdHMgaW52YWxpZCB2YWx1ZXMgbGlrZSB0YWJpbmRleD1cIi0xXCJcclxuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJ2ludmFsaWQtdmFsdWUnKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbnZhbGlkLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2xhYmVsJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICAvLyBmb3JjZSBsYXlvdXQgaW4gQ2hyb21lIDQ5LCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd29uJ3QgYmUgZm9jdXNhYmxlXHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4gICAgdmFyIHZhcmlhYmxlVG9QcmV2ZW50RGVhZENvZGVFbGltaW5hdGlvbiA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4gICAgZWxlbWVudC5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWxhYmVsLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9zdmcgPSByZXF1aXJlKCcuL21lZGlhL3N2ZycpO1xyXG5cclxudmFyIF9zdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ZnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBOb3RlOiBJRTEwIG9uIEJyb3dzZXJTdGFjayBkb2VzIG5vdCBsaWtlIHRoaXMgdGVzdFxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzUwJyk7XHJcbiAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9tZWRpYS9zdmcnKTtcclxuXHJcbnZhciBfc3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N2Zyk7XHJcblxyXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xyXG5cclxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLy8gTm90ZTogSUUxMCBvbiBCcm93c2VyU3RhY2sgZG9lcyBub3QgbGlrZSB0aGlzIHRlc3RcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBuYW1lOiAnY2FuLWZvY3VzLW9iamVjdC1zdmcnLFxyXG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzUwJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xyXG4gICAgICAvLyBGaXJlZm94IHNlZW1zIHRvIGJlIGhhbmRsaW5nIHRoZSBvYmplY3QgY3JlYXRpb24gYXN5bmNocm9ub3VzbHkgYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC5cclxuICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IEZpcmVmb3ggaXMgYWJsZSB0byBmb2N1cyBvYmplY3QgZWxlbWVudHMgcmVmZXJlbmNpbmcgU1ZHcywgd2Ugc2ltcGx5IGNoZWF0IGJ5IHNuaWZmaW5nIHRoZSB1c2VyIGFnZW50IHN0cmluZ1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIEV2ZXJ5IEVudmlyb25tZW50IGV4Y2VwdCBJRTkgY29uc2lkZXJzIFNXRiBvYmplY3RzIGZvY3VzYWJsZVxyXG52YXIgcmVzdWx0ID0gIV9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5JRTk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN3Zi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcclxuXHJcbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIiBhbHQ9XCJcIiAnICsgJ3NyYz1cIicgKyBfZ2lmMi5kZWZhdWx0ICsgJ1wiPic7XHJcblxyXG4gICAgLy8gZm9jdXMgdGhlIDxpbWc+LCBub3QgdGhlIDxkaXY+XHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XHJcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldDtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gc2VlIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7XHJcbiAgICAvLyB0YWtlIGNhcmUgb2YgZm9jdXMgaW4gdmFsaWRhdGUoKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XHJcbiAgICB2YXIgZm9jdXNhYmxlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIi0xXCJdJyk7XHJcbiAgICB2YXIgdGFiYmFibGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3RhYmluZGV4PVwiMFwiXScpO1xyXG5cclxuICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhpcyB0ZXN0IHRvIGZvY3VzIHRoZSA8ZmllbGRzZXQ+IGZpcnN0LCB3aGlsZSB0aGlzIGlzIG5vdCBuZWNlc3NhcnkgaW5cclxuICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XHJcbiAgICBlbGVtZW50LmZvY3VzKCk7XHJcblxyXG4gICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsZWdlbmQnKS5mb2N1cygpO1xyXG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c2FibGUgJiYgJ2ZvY3VzYWJsZScgfHwgX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhYmJhYmxlICYmICd0YWJiYWJsZScgfHwgJyc7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtcmVkaXJlY3QtbGVnZW5kLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWJvZHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7Jyk7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvOycpO1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWNvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkZXRhaWxzJyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3VtbWFyeT5mb288L3N1bW1hcnk+PHA+Y29udGVudDwvcD4nO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3VtbWFyeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IGZvY3VzYWJsZT1cInRydWVcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9zdmcgPSByZXF1aXJlKCcuL2hlbHBlci9zdmcnKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAnZGl2JyxcclxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKSgnPGZvcmVpZ25PYmplY3QgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIC8+PC9mb3JlaWduT2JqZWN0PicpO1xyXG4gICAgLy8gU2FmYXJpIDgncyBxdWVyc1NlbGVjdG9yKCkgY2FuJ3QgaWRlbnRpZnkgZm9yZWlnbk9iamVjdCwgYnV0IGdldEVsZW1lbnR5QnlUYWdOYW1lKCkgY2FuXHJcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdmb3JlaWduT2JqZWN0JykgfHwgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9yZWlnbk9iamVjdCcpWzBdO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxuXHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIEZpcmVmb3ggc2VlbXMgdG8gYmUgaGFuZGxpbmcgdGhlIFNWRy1kb2N1bWVudC1pbi1pZnJhbWUgY3JlYXRpb24gYXN5bmNocm9ub3VzbHlcclxuLy8gYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC4gVGh1cyB0aGUgdGVzdCBpcyBwb2ludGxlc3NcclxuLy8gYW5kIHdlIHJlc29ydCB0byBVQSBzbmlmZmluZyBvbmNlIGFnYWluLlxyXG4vLyBzZWUgaHR0cDovL2pzYmluLmNvbS92dW5hZG9ob2tvLzEvZWRpdD9qcyxjb25zb2xlLG91dHB1dFxyXG5cclxudmFyIHJlc3VsdCA9IEJvb2xlYW4oX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPICYmIHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLWluLWlmcmFtZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IHRhYmluZGV4PVwiLTFcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1uZWdhdGl2ZS10YWJpbmRleC1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKCc8dGV4dCB0YWJpbmRleD1cIjBcIj5hPC90ZXh0PicpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xyXG4gIH0sXHJcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKFsnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsICc8dXNlIHhsaW5rOmhyZWY9XCIjYWxseS10ZXN0LXRhcmdldFwiIHg9XCIwXCIgeT1cIjBcIiB0YWJpbmRleD1cIi0xXCIgLz4nXS5qb2luKCcnKSk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndXNlJyk7XHJcbiAgfSxcclxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLXVzZS10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZWxlbWVudDogJ2RpdicsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJycpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuZmlyc3RDaGlsZDtcclxuICB9LFxyXG4gIHZhbGlkYXRlOiBfc3ZnLnZhbGlkYXRlXHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXHJcbi8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICdkaXYnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICczeCcpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICBlbGVtZW50OiAndGFibGUnLFxyXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQsIHdyYXBwZXIsIF9kb2N1bWVudCkge1xyXG4gICAgLy8gSUU5IGhhcyBhIHByb2JsZW0gcmVwbGFjaW5nIFRCT0RZIGNvbnRlbnRzIHdpdGggaW5uZXJIVE1MLlxyXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwOTcwNTUvNTE1MTI0XHJcbiAgICAvLyBlbGVtZW50LmlubmVySFRNTCA9ICc8dHI+PHRkPmNlbGw8L3RkPjwvdHI+JztcclxuICAgIHZhciBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSAnPHRyPjx0ZD5jZWxsPC90ZD48L3RyPic7XHJcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10YWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfbXAgPSByZXF1aXJlKCcuL21lZGlhL21wNCcpO1xyXG5cclxudmFyIF9tcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tcCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gIGVsZW1lbnQ6ICd2aWRlbycsXHJcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gaW52YWxpZCBtZWRpYSBmaWxlIGNhbiB0cmlnZ2VyIHdhcm5pbmcgaW4gY29uc29sZSwgZGF0YS11cmkgdG8gcHJldmVudCBIVFRQIHJlcXVlc3RcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIF9tcDIuZGVmYXVsdCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcclxuICAgIH1cclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XHJcbmV4cG9ydHMuZm9jdXMgPSBmb2N1cztcclxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xyXG5cclxudmFyIF9mb2N1cyA9IHJlcXVpcmUoJy4uLy4uL2VsZW1lbnQvZm9jdXMuc3ZnLWZvcmVpZ24tb2JqZWN0LWhhY2snKTtcclxuXHJcbnZhciBfZm9jdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlKGVsZW1lbnQpIHtcclxuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPicgKyBlbGVtZW50ICsgJzwvc3ZnPic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3VzKGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudC5mb2N1cykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cy5jYWxsKGVsZW1lbnQpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgICgwLCBfZm9jdXMyLmRlZmF1bHQpKGVsZW1lbnQpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xyXG4gIGZvY3VzKGZvY3VzVGFyZ2V0KTtcclxuICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWic7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuaW52YWxpZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vZ2lmJyk7XHJcblxyXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9naWYyLmRlZmF1bHQ7XHJcbi8vIGV4cG9ydCBkZWZhdWx0ICdkYXRhOmF1ZGlvL21wMztiYXNlNjQsYXVkaW8tZm9jdXMtdGVzdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXAzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9naWYgPSByZXF1aXJlKCcuL2dpZicpO1xyXG5cclxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfZ2lmMi5kZWZhdWx0O1xyXG4vLyBleHBvcnQgZGVmYXVsdCAnZGF0YTp2aWRlby9tcDQ7YmFzZTY0LHZpZGVvLWZvY3VzLXRlc3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1wNC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIaHRiJyArICdHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUJwWkQwaWMzWm5JajQ4ZEdWNGRDQjRQU0l4TUNJZ2VUMGlNakFpSUdsa1BTSicgKyAnemRtY3RiR2x1YXkxMFpYaDBJajUwWlhoMFBDOTBaWGgwUGp3dmMzWm5QZz09JztcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKTtcclxuXHJcbnZhciBfdmVyc2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZXJzaW9uKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiByZWFkTG9jYWxTdG9yYWdlKGtleSkge1xyXG4gIC8vIGFsbG93IHJlYWRpbmcgZnJvbSBzdG9yYWdlIHRvIHJldHJpZXZlIHByZXZpb3VzIHN1cHBvcnQgcmVzdWx0c1xyXG4gIC8vIGV2ZW4gd2hpbGUgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXNcclxuICB2YXIgZGF0YSA9IHZvaWQgMDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGRhdGEgPSB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgZGF0YSA9IGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDoge307XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgZGF0YSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGE7XHJcbn0gLypcclxuICAgICAgRmFjaWxpdHkgdG8gY2FjaGUgdGVzdCByZXN1bHRzIGluIGxvY2FsU3RvcmFnZS5cclxuICBcclxuICAgICAgVVNBR0U6XHJcbiAgICAgICAgY2FjaGUuZ2V0KCdrZXknKTtcclxuICAgICAgICBjYWNoZS5zZXQoJ2tleScsICd2YWx1ZScpO1xyXG4gICAqL1xyXG5cclxuZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2Uoa2V5LCB2YWx1ZSkge1xyXG4gIGlmICghZG9jdW1lbnQuaGFzRm9jdXMoKSkge1xyXG4gICAgLy8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMgd2hlbiB0ZXN0cyBhcmUgZXhlY3V0ZWQsIGZvY3VzKCkgbWF5XHJcbiAgICAvLyBub3QgYmUgaGFuZGxlZCBwcm9wZXJseSBhbmQgZXZlbnRzIG1heSBub3QgYmUgZGlzcGF0Y2hlZCBpbW1lZGlhdGVseS5cclxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgZG9jdW1lbnQgaXMgcmVsb2FkZWQgd2hpbGUgRGV2ZWxvcGVyIFRvb2xzIGhhdmUgZm9jdXMuXHJcbiAgICB0cnkge1xyXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBpZ25vcmVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIGlnbm9yZVxyXG4gIH1cclxufVxyXG5cclxudmFyIHVzZXJBZ2VudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xyXG52YXIgY2FjaGVLZXkgPSAnYWxseS1zdXBwb3J0cy1jYWNoZSc7XHJcbnZhciBjYWNoZSA9IHJlYWRMb2NhbFN0b3JhZ2UoY2FjaGVLZXkpO1xyXG5cclxuLy8gdXBkYXRlIHRoZSBjYWNoZSBpZiBhbGx5IG9yIHRoZSB1c2VyIGFnZW50IGNoYW5nZWQgKG5ld2VyIHZlcnNpb24sIGV0YylcclxuaWYgKGNhY2hlLnVzZXJBZ2VudCAhPT0gdXNlckFnZW50IHx8IGNhY2hlLnZlcnNpb24gIT09IF92ZXJzaW9uMi5kZWZhdWx0KSB7XHJcbiAgY2FjaGUgPSB7fTtcclxufVxyXG5cclxuY2FjaGUudXNlckFnZW50ID0gdXNlckFnZW50O1xyXG5jYWNoZS52ZXJzaW9uID0gX3ZlcnNpb24yLmRlZmF1bHQ7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbiAgfSxcclxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcclxuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGNhY2hlW2tleV0gPSB2YWx1ZXNba2V5XTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhY2hlLnRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB3cml0ZUxvY2FsU3RvcmFnZShjYWNoZUtleSwgY2FjaGUpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1cHBvcnRzLWNhY2hlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmIChzdXBwb3J0c0NhY2hlKSB7XHJcbiAgICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcclxuICB9XHJcblxyXG4gIHN1cHBvcnRzQ2FjaGUgPSBfc3VwcG9ydHNDYWNoZTIuZGVmYXVsdC5nZXQoKTtcclxuICBpZiAoIXN1cHBvcnRzQ2FjaGUudGltZSkge1xyXG4gICAgX3N1cHBvcnRzQ2FjaGUyLmRlZmF1bHQuc2V0KGV4ZWN1dGVUZXN0cygpKTtcclxuICAgIHN1cHBvcnRzQ2FjaGUgPSBfc3VwcG9ydHNDYWNoZTIuZGVmYXVsdC5nZXQoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdXBwb3J0c0NhY2hlO1xyXG59O1xyXG5cclxudmFyIF9kZXRlY3RGb2N1cyA9IHJlcXVpcmUoJy4vZGV0ZWN0LWZvY3VzJyk7XHJcblxyXG52YXIgX2RldGVjdEZvY3VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdEZvY3VzKTtcclxuXHJcbnZhciBfc3VwcG9ydHNDYWNoZSA9IHJlcXVpcmUoJy4vc3VwcG9ydHMtY2FjaGUnKTtcclxuXHJcbnZhciBfc3VwcG9ydHNDYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0c0NhY2hlKTtcclxuXHJcbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvciA9IHJlcXVpcmUoJy4vY3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3InKTtcclxuXHJcbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhSW1nVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtaW1nLXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX2ZvY3VzQXJlYUltZ1RhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQXJlYUltZ1RhYmluZGV4KTtcclxuXHJcbnZhciBfZm9jdXNBcmVhVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBcmVhVGFiaW5kZXgpO1xyXG5cclxudmFyIF9mb2N1c0FyZWFXaXRob3V0SHJlZiA9IHJlcXVpcmUoJy4vZm9jdXMtYXJlYS13aXRob3V0LWhyZWYnKTtcclxuXHJcbnZhciBfZm9jdXNBcmVhV2l0aG91dEhyZWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBcmVhV2l0aG91dEhyZWYpO1xyXG5cclxudmFyIF9mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID0gcmVxdWlyZSgnLi9mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyk7XHJcblxyXG52YXIgX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyk7XHJcblxyXG52YXIgX2ZvY3VzQnJva2VuSW1hZ2VNYXAgPSByZXF1aXJlKCcuL2ZvY3VzLWJyb2tlbi1pbWFnZS1tYXAnKTtcclxuXHJcbnZhciBfZm9jdXNCcm9rZW5JbWFnZU1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0Jyb2tlbkltYWdlTWFwKTtcclxuXHJcbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCA9IHJlcXVpcmUoJy4vZm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3gnKTtcclxuXHJcbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldERpc2FibGVkID0gcmVxdWlyZSgnLi9mb2N1cy1maWVsZHNldC1kaXNhYmxlZCcpO1xyXG5cclxudmFyIF9mb2N1c0ZpZWxkc2V0RGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGaWVsZHNldERpc2FibGVkKTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldCA9IHJlcXVpcmUoJy4vZm9jdXMtZmllbGRzZXQnKTtcclxuXHJcbnZhciBfZm9jdXNGaWVsZHNldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ZpZWxkc2V0KTtcclxuXHJcbnZhciBfZm9jdXNGbGV4Ym94Q29udGFpbmVyID0gcmVxdWlyZSgnLi9mb2N1cy1mbGV4Ym94LWNvbnRhaW5lcicpO1xyXG5cclxudmFyIF9mb2N1c0ZsZXhib3hDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGbGV4Ym94Q29udGFpbmVyKTtcclxuXHJcbnZhciBfZm9jdXNGb3JtRGlzYWJsZWQgPSByZXF1aXJlKCcuL2ZvY3VzLWZvcm0tZGlzYWJsZWQnKTtcclxuXHJcbnZhciBfZm9jdXNGb3JtRGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGb3JtRGlzYWJsZWQpO1xyXG5cclxudmFyIF9mb2N1c0ltZ0lzbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1pbWctaXNtYXAnKTtcclxuXHJcbnZhciBfZm9jdXNJbWdJc21hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ltZ0lzbWFwKTtcclxuXHJcbnZhciBfZm9jdXNJbWdVc2VtYXBUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXgpO1xyXG5cclxudmFyIF9mb2N1c0luSGlkZGVuSWZyYW1lID0gcmVxdWlyZSgnLi9mb2N1cy1pbi1oaWRkZW4taWZyYW1lJyk7XHJcblxyXG52YXIgX2ZvY3VzSW5IaWRkZW5JZnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJbkhpZGRlbklmcmFtZSk7XHJcblxyXG52YXIgX2ZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0ID0gcmVxdWlyZSgnLi9mb2N1cy1pbi16ZXJvLWRpbWVuc2lvbi1vYmplY3QnKTtcclxuXHJcbnZhciBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QpO1xyXG5cclxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtaW52YWxpZC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ludmFsaWRUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzTGFiZWxUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtbGFiZWwtdGFiaW5kZXgnKTtcclxuXHJcbnZhciBfZm9jdXNMYWJlbFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzTGFiZWxUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbicpO1xyXG5cclxudmFyIF9mb2N1c09iamVjdFN2Z0hpZGRlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c09iamVjdFN2Z0hpZGRlbik7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnJyk7XHJcblxyXG52YXIgX2ZvY3VzT2JqZWN0U3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzT2JqZWN0U3ZnKTtcclxuXHJcbnZhciBfZm9jdXNPYmplY3RTd2YgPSByZXF1aXJlKCcuL2ZvY3VzLW9iamVjdC1zd2YnKTtcclxuXHJcbnZhciBfZm9jdXNPYmplY3RTd2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNPYmplY3RTd2YpO1xyXG5cclxudmFyIF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwJyk7XHJcblxyXG52YXIgX2ZvY3VzUmVkaXJlY3RJbWdVc2VtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcCk7XHJcblxyXG52YXIgX2ZvY3VzUmVkaXJlY3RMZWdlbmQgPSByZXF1aXJlKCcuL2ZvY3VzLXJlZGlyZWN0LWxlZ2VuZCcpO1xyXG5cclxudmFyIF9mb2N1c1JlZGlyZWN0TGVnZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVkaXJlY3RMZWdlbmQpO1xyXG5cclxudmFyIF9mb2N1c1Njcm9sbEJvZHkgPSByZXF1aXJlKCcuL2ZvY3VzLXNjcm9sbC1ib2R5Jyk7XHJcblxyXG52YXIgX2ZvY3VzU2Nyb2xsQm9keTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1Njcm9sbEJvZHkpO1xyXG5cclxudmFyIF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyA9IHJlcXVpcmUoJy4vZm9jdXMtc2Nyb2xsLWNvbnRhaW5lci13aXRob3V0LW92ZXJmbG93Jyk7XHJcblxyXG52YXIgX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KTtcclxuXHJcbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIgPSByZXF1aXJlKCcuL2ZvY3VzLXNjcm9sbC1jb250YWluZXInKTtcclxuXHJcbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTY3JvbGxDb250YWluZXIpO1xyXG5cclxudmFyIF9mb2N1c1N1bW1hcnkgPSByZXF1aXJlKCcuL2ZvY3VzLXN1bW1hcnknKTtcclxuXHJcbnZhciBfZm9jdXNTdW1tYXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3VtbWFyeSk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9jdXNhYmxlLWF0dHJpYnV0ZScpO1xyXG5cclxudmFyIF9mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy10YWJpbmRleC1hdHRyaWJ1dGUnKTtcclxuXHJcbnZhciBfZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKTtcclxuXHJcbnZhciBfZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctbmVnYXRpdmUtdGFiaW5kZXgtYXR0cmlidXRlJyk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpO1xyXG5cclxudmFyIF9mb2N1c1N2Z1VzZVRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctdXNlLXRhYmluZGV4Jyk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnVXNlVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmdVc2VUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9yZWlnbm9iamVjdC10YWJpbmRleCcpO1xyXG5cclxudmFyIF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCk7XHJcblxyXG52YXIgX2ZvY3VzU3ZnSW5JZnJhbWUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy1pbi1pZnJhbWUnKTtcclxuXHJcbnZhciBfZm9jdXNTdmdJbklmcmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0luSWZyYW1lKTtcclxuXHJcbnZhciBfZm9jdXNTdmcgPSByZXF1aXJlKCcuL2ZvY3VzLXN2ZycpO1xyXG5cclxudmFyIF9mb2N1c1N2ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Zyk7XHJcblxyXG52YXIgX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMgPSByZXF1aXJlKCcuL2ZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMnKTtcclxuXHJcbnZhciBfZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzKTtcclxuXHJcbnZhciBfZm9jdXNUYWJsZSA9IHJlcXVpcmUoJy4vZm9jdXMtdGFibGUnKTtcclxuXHJcbnZhciBfZm9jdXNUYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmxlKTtcclxuXHJcbnZhciBfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyA9IHJlcXVpcmUoJy4vZm9jdXMtdmlkZW8td2l0aG91dC1jb250cm9scycpO1xyXG5cclxudmFyIF9mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbicpO1xyXG5cclxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciB0ZXN0Q2FsbGJhY2tzID0ge1xyXG4gIGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3I6IF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0OiBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QyLmRlZmF1bHQsXHJcbiAgZm9jdXNPYmplY3RTd2Y6IF9mb2N1c09iamVjdFN3ZjIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0luSWZyYW1lOiBfZm9jdXNTdmdJbklmcmFtZTIuZGVmYXVsdCxcclxuICB0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uOiBfdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjIuZGVmYXVsdFxyXG59O1xyXG5cclxudmFyIHRlc3REZXNjcmlwdGlvbnMgPSB7XHJcbiAgZm9jdXNBcmVhSW1nVGFiaW5kZXg6IF9mb2N1c0FyZWFJbWdUYWJpbmRleDIuZGVmYXVsdCxcclxuICBmb2N1c0FyZWFUYWJpbmRleDogX2ZvY3VzQXJlYVRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzQXJlYVdpdGhvdXRIcmVmOiBfZm9jdXNBcmVhV2l0aG91dEhyZWYyLmRlZmF1bHQsXHJcbiAgZm9jdXNBdWRpb1dpdGhvdXRDb250cm9sczogX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMyLmRlZmF1bHQsXHJcbiAgZm9jdXNCcm9rZW5JbWFnZU1hcDogX2ZvY3VzQnJva2VuSW1hZ2VNYXAyLmRlZmF1bHQsXHJcbiAgZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDogX2ZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gyLmRlZmF1bHQsXHJcbiAgZm9jdXNGaWVsZHNldERpc2FibGVkOiBfZm9jdXNGaWVsZHNldERpc2FibGVkMi5kZWZhdWx0LFxyXG4gIGZvY3VzRmllbGRzZXQ6IF9mb2N1c0ZpZWxkc2V0Mi5kZWZhdWx0LFxyXG4gIGZvY3VzRmxleGJveENvbnRhaW5lcjogX2ZvY3VzRmxleGJveENvbnRhaW5lcjIuZGVmYXVsdCxcclxuICBmb2N1c0Zvcm1EaXNhYmxlZDogX2ZvY3VzRm9ybURpc2FibGVkMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW1nSXNtYXA6IF9mb2N1c0ltZ0lzbWFwMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXg6IF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzSW5IaWRkZW5JZnJhbWU6IF9mb2N1c0luSGlkZGVuSWZyYW1lMi5kZWZhdWx0LFxyXG4gIGZvY3VzSW52YWxpZFRhYmluZGV4OiBfZm9jdXNJbnZhbGlkVGFiaW5kZXgyLmRlZmF1bHQsXHJcbiAgZm9jdXNMYWJlbFRhYmluZGV4OiBfZm9jdXNMYWJlbFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzT2JqZWN0U3ZnOiBfZm9jdXNPYmplY3RTdmcyLmRlZmF1bHQsXHJcbiAgZm9jdXNPYmplY3RTdmdIaWRkZW46IF9mb2N1c09iamVjdFN2Z0hpZGRlbjIuZGVmYXVsdCxcclxuICBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwOiBfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDIuZGVmYXVsdCxcclxuICBmb2N1c1JlZGlyZWN0TGVnZW5kOiBfZm9jdXNSZWRpcmVjdExlZ2VuZDIuZGVmYXVsdCxcclxuICBmb2N1c1Njcm9sbEJvZHk6IF9mb2N1c1Njcm9sbEJvZHkyLmRlZmF1bHQsXHJcbiAgZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6IF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzIuZGVmYXVsdCxcclxuICBmb2N1c1Njcm9sbENvbnRhaW5lcjogX2ZvY3VzU2Nyb2xsQ29udGFpbmVyMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3VtbWFyeTogX2ZvY3VzU3VtbWFyeTIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTogX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGU6IF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlMi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTogX2ZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z1VzZVRhYmluZGV4OiBfZm9jdXNTdmdVc2VUYWJpbmRleDIuZGVmYXVsdCxcclxuICBmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDogX2ZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4Mi5kZWZhdWx0LFxyXG4gIGZvY3VzU3ZnOiBfZm9jdXNTdmcyLmRlZmF1bHQsXHJcbiAgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczogX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMyLmRlZmF1bHQsXHJcbiAgZm9jdXNUYWJsZTogX2ZvY3VzVGFibGUyLmRlZmF1bHQsXHJcbiAgZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczogX2ZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMyLmRlZmF1bHRcclxufTtcclxuXHJcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cygpIHtcclxuICB2YXIgcmVzdWx0cyA9ICgwLCBfZGV0ZWN0Rm9jdXMyLmRlZmF1bHQpKHRlc3REZXNjcmlwdGlvbnMpO1xyXG4gIE9iamVjdC5rZXlzKHRlc3RDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmVzdWx0c1trZXldID0gdGVzdENhbGxiYWNrc1trZXldKCk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG52YXIgc3VwcG9ydHNDYWNoZSA9IG51bGw7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VwcG9ydHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XHJcblxyXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBodHRwczovL2pzYmluLmNvbS92YWZhYmEvMy9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcclxudmFyIHJlc3VsdCA9IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBmaW5kSW5kZXg7XHJcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2spIHtcclxuICAvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgb3IgcG9seWZpbGxlZCBBcnJheSNmaW5kSW5kZXggZmlyc3RcclxuICBpZiAoYXJyYXkuZmluZEluZGV4KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gIC8vIHNob3J0Y3V0IGlmIHRoZSBhcnJheSBpcyBlbXB0eVxyXG4gIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8vIG90aGVyd2lzZSBsb29wIG92ZXIgYXJyYXlcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KSkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAtMTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1maW5kLWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldFBhcmVudENvbXBhcmF0b3IgPSBnZXRQYXJlbnRDb21wYXJhdG9yO1xyXG5cclxuLy8gTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpcyBhdmFpbGFibGUgc2luY2UgSUU5XHJcbi8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxyXG5cclxuLy8gY2FsbGJhY2sgcmV0dXJucyB0cnVlIHdoZW4gZWxlbWVudCBpcyBjb250YWluZWQgYnkgcGFyZW50IG9yIGlzIHRoZSBwYXJlbnQgc3VpdGVkIGZvciB1c2Ugd2l0aCBBcnJheS5zb21lKClcclxuLypcclxuICBVU0FHRTpcclxuICAgIHZhciBpc0NoaWxkT2YgPSBnZXRQYXJlbnRDb21wYXJhdG9yKHtwYXJlbnQ6IHNvbWVOb2RlfSk7XHJcbiAgICBsaXN0T2ZFbGVtZW50cy5zb21lKGlzQ2hpbGRPZilcclxuKi9cclxuXHJcbmZ1bmN0aW9uIGdldFBhcmVudENvbXBhcmF0b3IoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBwYXJlbnQgPSBfcmVmLnBhcmVudCxcclxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcclxuICAgICAgaW5jbHVkZVNlbGYgPSBfcmVmLmluY2x1ZGVTZWxmO1xyXG5cclxuICBpZiAocGFyZW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKG5vZGUpIHtcclxuICAgICAgcmV0dXJuIEJvb2xlYW4oaW5jbHVkZVNlbGYgJiYgbm9kZSA9PT0gcGFyZW50IHx8IHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihub2RlKSB7XHJcbiAgICAgIHJldHVybiBCb29sZWFuKGluY2x1ZGVTZWxmICYmIGVsZW1lbnQgPT09IG5vZGUgfHwgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50Jyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGFyZS1wb3NpdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXHJcbiAgICAgIF9yZWYkbGFiZWwgPSBfcmVmLmxhYmVsLFxyXG4gICAgICBsYWJlbCA9IF9yZWYkbGFiZWwgPT09IHVuZGVmaW5lZCA/ICdjb250ZXh0LXRvLWVsZW1lbnQnIDogX3JlZiRsYWJlbCxcclxuICAgICAgcmVzb2x2ZURvY3VtZW50ID0gX3JlZi5yZXNvbHZlRG9jdW1lbnQsXHJcbiAgICAgIGRlZmF1bHRUb0RvY3VtZW50ID0gX3JlZi5kZWZhdWx0VG9Eb2N1bWVudDtcclxuXHJcbiAgdmFyIGVsZW1lbnQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dClbMF07XHJcblxyXG4gIGlmIChyZXNvbHZlRG9jdW1lbnQgJiYgZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmICghZWxlbWVudCAmJiBkZWZhdWx0VG9Eb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICB9XHJcblxyXG4gIGlmICghZWxlbWVudCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsYWJlbCArICcgcmVxdWlyZXMgdmFsaWQgb3B0aW9ucy5jb250ZXh0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGxhYmVsICsgJyByZXF1aXJlcyBvcHRpb25zLmNvbnRleHQgdG8gYmUgYW4gRWxlbWVudCcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xyXG5cclxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC10by1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBlbGVtZW50TWF0Y2hlcztcclxuXHJcbi8vIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgbWF5IGJlIGF2YWlsYWJsZSBhdCBhIGRpZmZlcmVudCBuYW1lXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXNcclxuXHJcbnZhciBuYW1lcyA9IFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJ107XHJcbnZhciBuYW1lID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGZpbmRNZXRob2ROYW1lKGVsZW1lbnQpIHtcclxuICBuYW1lcy5zb21lKGZ1bmN0aW9uIChfbmFtZSkge1xyXG4gICAgaWYgKCFlbGVtZW50W19uYW1lXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbmFtZSA9IF9uYW1lO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgaWYgKCFuYW1lKSB7XHJcbiAgICBmaW5kTWV0aG9kTmFtZShlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBlbGVtZW50W25hbWVdKHNlbGVjdG9yKTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudC1tYXRjaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHRyeSB7XHJcbiAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT5cclxuICAgIHJldHVybiBub2RlLmNvbnRlbnREb2N1bWVudFxyXG4gICAgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XHJcbiAgICB8fCBub2RlLmNvbnRlbnRXaW5kb3cgJiYgbm9kZS5jb250ZW50V2luZG93LmRvY3VtZW50XHJcbiAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT4gdGhhdCBjb250YWluIFNWR1xyXG4gICAgfHwgbm9kZS5nZXRTVkdEb2N1bWVudCAmJiBub2RlLmdldFNWR0RvY3VtZW50KCkgfHwgbnVsbDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBTZWN1cml0eUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2NvbnRlbnREb2N1bWVudCcgcHJvcGVydHkgZnJvbSAnSFRNTE9iamVjdEVsZW1lbnQnXHJcbiAgICAvLyBhbHNvIElFIG1heSB0aHJvdyBtZW1iZXIgbm90IGZvdW5kIGV4Y2VwdGlvbiBlLmcuIG9uIDxvYmplY3QgdHlwZT1cImltYWdlL3BuZ1wiPlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWNvbnRlbnQtZG9jdW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgaWYgKCFub2RlKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgfVxyXG5cclxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9jdW1lbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEZyYW1lRWxlbWVudDtcclxuXHJcbnZhciBfZ2V0Q29udGVudERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtY29udGVudC1kb2N1bWVudCcpO1xyXG5cclxudmFyIF9nZXRDb250ZW50RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29udGVudERvY3VtZW50KTtcclxuXHJcbnZhciBfZ2V0V2luZG93ID0gcmVxdWlyZSgnLi9nZXQtd2luZG93Jyk7XHJcblxyXG52YXIgX2dldFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRXaW5kb3cpO1xyXG5cclxudmFyIF9zZWxlY3RJblNoYWRvd3MgPSByZXF1aXJlKCcuL3NlbGVjdC1pbi1zaGFkb3dzJyk7XHJcblxyXG52YXIgX3NlbGVjdEluU2hhZG93czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3RJblNoYWRvd3MpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcclxuXHJcbmZ1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpIHtcclxuICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICBzZWxlY3RvciA9ICgwLCBfc2VsZWN0SW5TaGFkb3dzMi5kZWZhdWx0KSgnb2JqZWN0LCBpZnJhbWUnKTtcclxuICB9XHJcblxyXG4gIGlmIChfd2luZG93Ll9mcmFtZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcclxuICB9XHJcblxyXG4gIF93aW5kb3cuX2ZyYW1lRWxlbWVudCA9IG51bGw7XHJcblxyXG4gIHZhciBwb3RlbnRpYWxIb3N0cyA9IF93aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG4gIFtdLnNvbWUuY2FsbChwb3RlbnRpYWxIb3N0cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldENvbnRlbnREb2N1bWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgICBpZiAoX2RvY3VtZW50ICE9PSBfd2luZG93LmRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBfd2luZG93Ll9mcmFtZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlbGVtZW50KSB7XHJcbiAgdmFyIF93aW5kb3cgPSAoMCwgX2dldFdpbmRvdzIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgaWYgKCFfd2luZG93LnBhcmVudCB8fCBfd2luZG93LnBhcmVudCA9PT0gX3dpbmRvdykge1xyXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gcGFyZW50IGJyb3dzaW5nIGNvbnRleHQsXHJcbiAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gZ2V0IGEgZnJhbWVFbGVtZW50IGVpdGhlciB3YXlcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2ZyYW1lRWxlbWVudFxyXG4gICAgLy8gZG9lcyBub3Qgd29yayB3aXRoaW4gPGVtYmVkPiBhbnl3aGVyZSwgYW5kIG5vdCB3aXRoaW4gaW4gPG9iamVjdD4gaW4gSUVcclxuICAgIHJldHVybiBfd2luZG93LmZyYW1lRWxlbWVudCB8fCBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChfd2luZG93KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1mcmFtZS1lbGVtZW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkobm9kZSk7XHJcbiAgcmV0dXJuIF9kb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XHJcbn07XHJcblxyXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtZG9jdW1lbnQnKTtcclxuXHJcbnZhciBfZ2V0RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RG9jdW1lbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd2luZG93LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmdldE1hcEJ5TmFtZSA9IGdldE1hcEJ5TmFtZTtcclxuZXhwb3J0cy5nZXRNYXBPZkltYWdlID0gZ2V0TWFwT2ZJbWFnZTtcclxuZXhwb3J0cy5nZXRJbWFnZU9mQXJlYSA9IGdldEltYWdlT2ZBcmVhO1xyXG5cclxudmFyIF9jc3MgPSByZXF1aXJlKCdjc3MuZXNjYXBlJyk7XHJcblxyXG52YXIgX2NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3MpO1xyXG5cclxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XHJcblxyXG52YXIgX2dldERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldERvY3VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBCeU5hbWUobmFtZSwgX2RvY3VtZW50KSB7XHJcbiAgLy8gYXBwYXJlbnRseSBnZXRFbGVtZW50c0J5TmFtZSgpIGFsc28gY29uc2lkZXJzIGlkIGF0dHJpYnV0ZSBpbiBJRSAmIG9wZXJhXHJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2dldEVsZW1lbnRzQnlOYW1lXHJcbiAgdmFyIG1hcCA9IF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYXBbbmFtZT1cIicgKyAoMCwgX2NzczIuZGVmYXVsdCkobmFtZSkgKyAnXCJdJyk7XHJcbiAgcmV0dXJuIG1hcCB8fCBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBPZkltYWdlKGVsZW1lbnQpIHtcclxuICB2YXIgdXNlbWFwID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VzZW1hcCcpO1xyXG4gIGlmICghdXNlbWFwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcclxuICByZXR1cm4gZ2V0TWFwQnlOYW1lKHVzZW1hcC5zbGljZSgxKSwgX2RvY3VtZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCkge1xyXG4gIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gIGlmICghbWFwLm5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdtYXAnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIE5PVEU6IGltYWdlIG1hcHMgY2FuIGFsc28gYmUgYXBwbGllZCB0byA8b2JqZWN0PiB3aXRoIGltYWdlIGNvbnRlbnQsXHJcbiAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XHJcblxyXG4gIC8vIEhUTUw1IHNwZWNpZmllcyBIVE1MTWFwRWxlbWVudC5pbWFnZXMgdG8gYmUgYW4gSFRNTENvbGxlY3Rpb24gb2YgYWxsXHJcbiAgLy8gPGltZz4gYW5kIDxvYmplY3Q+IHJlZmVyZW5jaW5nIHRoZSA8bWFwPiBlbGVtZW50LCBidXQgbm8gYnJvd3NlciBpbXBsZW1lbnRzIHRoaXNcclxuICAvLyAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtbWFwLWVsZW1lbnRcclxuICAvLyAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWFwRWxlbWVudFxyXG4gIC8vIHRoZSBpbWFnZSBtdXN0IGJlIHZhbGlkIGFuZCBsb2FkZWQgZm9yIHRoZSBtYXAgdG8gdGFrZSBlZmZlY3RcclxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XHJcbiAgcmV0dXJuIF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbWdbdXNlbWFwPVwiIycgKyAoMCwgX2NzczIuZGVmYXVsdCkobWFwLm5hbWUpICsgJ1wiXScpIHx8IG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtbWFwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XHJcbnZhciBfY29uc29sZSA9IHtcclxuICBsb2c6IG5vb3AsXHJcbiAgZGVidWc6IG5vb3AsXHJcbiAgaW5mbzogbm9vcCxcclxuICB3YXJuOiBub29wLFxyXG4gIGVycm9yOiBub29wXHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlIDogX2NvbnNvbGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICBsaXN0ID0gX3JlZi5saXN0LFxyXG4gICAgICBlbGVtZW50cyA9IF9yZWYuZWxlbWVudHMsXHJcbiAgICAgIHJlc29sdmVFbGVtZW50ID0gX3JlZi5yZXNvbHZlRWxlbWVudDtcclxuXHJcbiAgLy8gb3BlcmF0ZSBvbiBhIGNvcHkgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBhcnJheVxyXG4gIHZhciBfbGlzdCA9IGxpc3Quc2xpY2UoMCk7XHJcbiAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50cyB3ZSdyZSBpbmplY3RpbmcgYXJlIHByb3ZpZGVkIGluIERPTSBvcmRlclxyXG4gIHZhciBfZWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoZWxlbWVudHMpLnNsaWNlKDApO1xyXG4gICgwLCBfc29ydERvbU9yZGVyMi5kZWZhdWx0KShfZWxlbWVudHMpO1xyXG4gIC8vIGZpbmQgdGhlIG9mZnNldHMgd2l0aGluIHRoZSB0YXJnZXQgYXJyYXkgKGxpc3QpIGF0IHdoaWNoIHRvIGluamVjdFxyXG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBlbGVtZW50IChmcm9tIGVsZW1lbnRzKVxyXG4gIHZhciBpbnNlcnRpb25zID0gZmluZEluc2VydGlvbk9mZnNldHMoX2xpc3QsIF9lbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpO1xyXG4gIC8vIGFjdHVhbGx5IGluamVjdCB0aGUgZWxlbWVudHMgaW50byB0aGUgdGFyZ2V0IGFycmF5IGF0IHRoZSBpZGVudGlmaWVkIHBvc2l0aW9uc1xyXG4gIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKF9saXN0LCBpbnNlcnRpb25zKTtcclxuICByZXR1cm4gX2xpc3Q7XHJcbn07XHJcblxyXG52YXIgX2FycmF5RmluZEluZGV4ID0gcmVxdWlyZSgnLi4vdXRpbC9hcnJheS1maW5kLWluZGV4Jyk7XHJcblxyXG52YXIgX2FycmF5RmluZEluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5RmluZEluZGV4KTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9zb3J0RG9tT3JkZXIgPSByZXF1aXJlKCcuL3NvcnQtZG9tLW9yZGVyJyk7XHJcblxyXG52YXIgX3NvcnREb21PcmRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb3J0RG9tT3JkZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIHRhcmdldCkge1xyXG4gIC8vIGZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBjb21lcyBBRlRFUiB0aGUgdGFyZ2V0IGVsZW1lbnRcclxuICByZXR1cm4gKDAsIF9hcnJheUZpbmRJbmRleDIuZGVmYXVsdCkobGlzdCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcclxuICB9KTtcclxufVxyXG4vLyBzb3J0IGEgbGlzdCBvZiBlbGVtZW50cyBpbnRvIGFub3RoZXIgbGlzdCBvZiBlbGVtZW50cyBpbiBET00gb3JkZXJcclxuXHJcbi8qXHJcbiAgVVNBR0U6XHJcbiAgICBtZXJnZURvbU9yZGVyKHtcclxuICAgICAgLy8gRE9NIG9yZGVyZWQgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXNlIGFzIGJhc2Ugb2YgbWVyZ2VcclxuICAgICAgbGlzdDogW10sXHJcbiAgICAgIC8vIHVub3JkZXJlZCBhcnJheSBvZiBlbGVtZW50cyB0byBtZXJnZSBpbnRvIGJhc2UgbGlzdFxyXG4gICAgICBlbGVtZW50czogW10sXHJcbiAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlc29sdmUgYW4gZWxlbWVudFxyXG4gICAgICByZXNvbHZlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIC8vIHJldHVybiBudWxsIHRvIHNraXBcclxuICAgICAgICAvLyByZXR1cm4gZWxlbWVudCB0byByZXBsYWNlIGluc2VydGlvblxyXG4gICAgICAgIC8vIHJldHVybiBbZWxlbWVudDEsIGVsZW1lbnQyLCDigKZdIHRvIHJlcGxhY2UgaW5zZXJ0aW9uIHdpdGggbXVsdGlwbGUgZWxlbWVudHNcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgfSxcclxuICAgIH0pXHJcbiovXHJcblxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhsaXN0LCBlbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpIHtcclxuICAvLyBpbnN0ZWFkIG9mIG11dGF0aW5nIHRoZSBlbGVtZW50cyBsaXN0IGRpcmVjdGx5LCByZW1lbWJlciBwb3NpdGlvbiBhbmQgbWFwXHJcbiAgLy8gdG8gaW5qZWN0IGxhdGVyLCB3aGVuIHdlIGNhbiBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHlcclxuICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xyXG4gIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHZhciByZXBsYWNlID0gdHJ1ZTtcclxuICAgIHZhciBvZmZzZXQgPSBsaXN0LmluZGV4T2YoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgLy8gZWxlbWVudCBpcyBub3QgaW4gdGFyZ2V0IGxpc3RcclxuICAgICAgb2Zmc2V0ID0gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgZWxlbWVudCk7XHJcbiAgICAgIHJlcGxhY2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAvLyB0aGVyZSBpcyBubyBzdWNjZXNzb3IgaW4gdGhlIHRhYnNlcXVlbmNlLFxyXG4gICAgICAvLyBtZWFuaW5nIHRoZSBpbWFnZSBtdXN0IGJlIHRoZSBsYXN0IGVsZW1lbnRcclxuICAgICAgb2Zmc2V0ID0gbGlzdC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsb3cgdGhlIGNvbnN1bWVyIHRvIHJlcGxhY2UgdGhlIGluamVjdGVkIGVsZW1lbnRcclxuICAgIHZhciBpbmplY3Rpb25zID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKHJlc29sdmVFbGVtZW50ID8gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCkgOiBlbGVtZW50KTtcclxuICAgIGlmICghaW5qZWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgLy8gd2UgY2FuJ3QgaW5qZWN0IHplcm8gZWxlbWVudHNcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydGlvbnMucHVzaCh7XHJcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxyXG4gICAgICBlbGVtZW50czogaW5qZWN0aW9uc1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBpbnNlcnRpb25zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhsaXN0LCBpbnNlcnRpb25zKSB7XHJcbiAgLy8gcmVtZW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyB3ZSBoYXZlIGFscmVhZHkgaW5qZWN0ZWRcclxuICAvLyBzbyB3ZSBhY2NvdW50IGZvciB0aGUgY2F1c2VkIGluZGV4IG9mZnNldFxyXG4gIHZhciBpbnNlcnRlZCA9IDA7XHJcbiAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaW5zZXJ0IHRoZSBlbGVtZW50cyBpbiBzZXF1ZW5jZSxcclxuICAvLyBvdGhlcndpc2UgdGhlIG9mZnNldCBjb21wZW5zYXRpb24gd29uJ3Qgd29ya1xyXG4gIGluc2VydGlvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XHJcbiAgfSk7XHJcbiAgaW5zZXJ0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnNlcnRpb24pIHtcclxuICAgIC8vIGFycmF5LnNwbGljZSBoYXMgYW4gYW5ub3lpbmcgZnVuY3Rpb24gc2lnbmF0dXJlIDooXHJcbiAgICB2YXIgcmVtb3ZlID0gaW5zZXJ0aW9uLnJlcGxhY2UgPyAxIDogMDtcclxuICAgIHZhciBhcmdzID0gW2luc2VydGlvbi5vZmZzZXQgKyBpbnNlcnRlZCwgcmVtb3ZlXS5jb25jYXQoaW5zZXJ0aW9uLmVsZW1lbnRzKTtcclxuICAgIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xyXG4gICAgaW5zZXJ0ZWQgKz0gaW5zZXJ0aW9uLmVsZW1lbnRzLmxlbmd0aCAtIHJlbW92ZTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLWRvbS1vcmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gIGlmICghaW5wdXQpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgcmV0dXJuIGlucHV0O1xyXG4gIH1cclxuXHJcbiAgLy8gaW5zdGFuY2VvZiBOb2RlIC0gZG9lcyBub3Qgd29yayB3aXRoIGlmcmFtZXNcclxuICBpZiAoaW5wdXQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIFtpbnB1dF07XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGlucHV0KTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaW5wdXQsIDApO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCBpbnB1dCAnICsgU3RyaW5nKGlucHV0KSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaW5wdXQgbWF5IGJlIHVuZGVmaW5lZCwgc2VsZWN0b3ItdHJpbmcsIE5vZGUsIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiwgYXJyYXkgb2YgTm9kZXNcclxuLy8geWVzLCB0byBzb21lIGV4dGVudCB0aGlzIGlzIGEgYmFkIHJlcGxpY2Egb2YgalF1ZXJ5J3MgY29uc3RydWN0b3IgZnVuY3Rpb25cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS1hcnJheS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfcGxhdGZvcm0yID0gcmVxdWlyZSgncGxhdGZvcm0nKTtcclxuXHJcbnZhciBfcGxhdGZvcm0zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBkZWVwIGNsb25lIG9mIG9yaWdpbmFsIHBsYXRmb3JtXHJcbnZhciBwbGF0Zm9ybSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX3BsYXRmb3JtMy5kZWZhdWx0KSk7XHJcblxyXG4vLyBvcGVyYXRpbmcgc3lzdGVtXHJcblxyXG4vLyBzdWdhciBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3BsYXRmb3JtLmpzXHJcbi8vIG1ha2Ugc3VyZSB0byBBTFdBWVMgcmVmZXJlbmNlIHRoZSBsYXlvdXQgZW5naW5lLFxyXG4vLyBldmVuIGlmIGl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb25kaXRpb24sXHJcbi8vIGFzIHRoaXMgbWFrZXMgZ3JlcHBpbmcgZm9yIHRoaXMgc3R1ZmYgc2ltcGxlclxyXG5cclxudmFyIG9zID0gcGxhdGZvcm0ub3MuZmFtaWx5IHx8ICcnO1xyXG52YXIgQU5EUk9JRCA9IG9zID09PSAnQW5kcm9pZCc7XHJcbnZhciBXSU5ET1dTID0gb3Muc2xpY2UoMCwgNykgPT09ICdXaW5kb3dzJztcclxudmFyIE9TWCA9IG9zID09PSAnT1MgWCc7XHJcbnZhciBJT1MgPSBvcyA9PT0gJ2lPUyc7XHJcblxyXG4vLyBsYXlvdXRcclxudmFyIEJMSU5LID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnQmxpbmsnO1xyXG52YXIgR0VDS08gPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdHZWNrbyc7XHJcbnZhciBUUklERU5UID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnVHJpZGVudCc7XHJcbnZhciBFREdFID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnRWRnZUhUTUwnO1xyXG52YXIgV0VCS0lUID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnV2ViS2l0JztcclxuXHJcbi8vIGJyb3dzZXIgdmVyc2lvbiAobm90IGxheW91dCBlbmdpbmUgdmVyc2lvbiEpXHJcbnZhciB2ZXJzaW9uID0gcGFyc2VGbG9hdChwbGF0Zm9ybS52ZXJzaW9uKTtcclxudmFyIG1ham9yVmVyc2lvbiA9IE1hdGguZmxvb3IodmVyc2lvbik7XHJcbnBsYXRmb3JtLm1ham9yVmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcclxuXHJcbnBsYXRmb3JtLmlzID0ge1xyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1cclxuICBBTkRST0lEOiBBTkRST0lELFxyXG4gIFdJTkRPV1M6IFdJTkRPV1MsXHJcbiAgT1NYOiBPU1gsXHJcbiAgSU9TOiBJT1MsXHJcbiAgLy8gbGF5b3V0XHJcbiAgQkxJTks6IEJMSU5LLCAvLyBcIkNocm9tZVwiLCBcIkNocm9tZSBNb2JpbGVcIiwgXCJPcGVyYVwiXHJcbiAgR0VDS086IEdFQ0tPLCAvLyBcIkZpcmVmb3hcIlxyXG4gIFRSSURFTlQ6IFRSSURFTlQsIC8vIFwiSW50ZXJuZXQgRXhwbG9yZXJcIlxyXG4gIEVER0U6IEVER0UsIC8vIFwiTWljcm9zb2Z0IEVkZ2VcIlxyXG4gIFdFQktJVDogV0VCS0lULCAvLyBcIlNhZmFyaVwiXHJcbiAgLy8gSU5URVJORVQgRVhQTE9SRVJTXHJcbiAgSUU5OiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gOSxcclxuICBJRTEwOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTAsXHJcbiAgSUUxMTogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDExXHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBwbGF0Zm9ybTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgaWYgKHR5cGVvZiBzaGFkb3dQcmVmaXggIT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YXIgb3BlcmF0b3IgPSAoMCwgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IyLmRlZmF1bHQpKCk7XHJcbiAgICBpZiAob3BlcmF0b3IpIHtcclxuICAgICAgc2hhZG93UHJlZml4ID0gJywgaHRtbCAnICsgb3BlcmF0b3IgKyAnICc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXNoYWRvd1ByZWZpeCkge1xyXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNlbGVjdG9yICsgc2hhZG93UHJlZml4ICsgc2VsZWN0b3IucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJykuc3BsaXQoJywnKS5qb2luKHNoYWRvd1ByZWZpeCk7XHJcbn07XHJcblxyXG52YXIgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9jc3Mtc2hhZG93LXBpZXJjaW5nLWRlZXAtY29tYmluYXRvcicpO1xyXG5cclxudmFyIF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBzaGFkb3dQcmVmaXggPSB2b2lkIDA7XHJcbi8vIGNvbnZlcnQgYSBDU1Mgc2VsZWN0b3Igc28gdGhhdCBpdCBhbHNvIHBpZXJjZXMgU2hhZG93RE9NXHJcbi8vIHRha2VzIFwiLmEsICNiXCIgYW5kIHR1cm5zIGl0IGludG8gXCIuYSwgI2IsIGh0bWwgPj4+IC5hLCBodG1sID4+PiAjYlwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LWluLXNoYWRvd3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIHJldHVybiBlbGVtZW50cy5zb3J0KGNvbXBhcmVEb21Qb3NpdGlvbik7XHJcbn07XHJcblxyXG4vLyBzb3J0cyBhIGxpc3Qgb2YgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZWlyIG9yZGVyIGluIHRoZSBET01cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVEb21Qb3NpdGlvbihhLCBiKSB7XHJcbiAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA/IC0xIDogMTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC1kb20tb3JkZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIGlmICghKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxyXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xyXG4gIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4JztcclxuXHJcbiAgLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxyXG4gIHZhciB0YWJpbmRleCA9IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLCAxMCk7XHJcbiAgcmV0dXJuIGlzTmFOKHRhYmluZGV4KSA/IC0xIDogdGFiaW5kZXg7XHJcbn07XHJcblxyXG52YXIgX3ZhbGlkVGFiaW5kZXggPSByZXF1aXJlKCcuLi9pcy92YWxpZC10YWJpbmRleCcpO1xyXG5cclxudmFyIF92YWxpZFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkVGFiaW5kZXgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJpbmRleC12YWx1ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXHJcbiAgICAgIGF0dHJpYnV0ZSA9IF9yZWYuYXR0cmlidXRlLFxyXG4gICAgICB0ZW1wb3JhcnlWYWx1ZSA9IF9yZWYudGVtcG9yYXJ5VmFsdWUsXHJcbiAgICAgIHNhdmVWYWx1ZSA9IF9yZWYuc2F2ZVZhbHVlO1xyXG5cclxuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlID0gJ2RhdGEtY2FjaGVkLScgKyBhdHRyaWJ1dGU7XHJcblxyXG4gIGlmICh0ZW1wb3JhcnlWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgX3ZhbHVlID0gc2F2ZVZhbHVlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUsIF92YWx1ZSB8fCAnJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHRlbXBvcmFyeVZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcclxuICAgIGlmIChfdmFsdWUyID09PSAnJykge1xyXG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBfdmFsdWUyKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuLy8gaGVscGVyIHRvIHR1cm5cclxuLy8gIDxkaXYgc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxyXG4vLyBpbnRvXHJcbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwibmV3XCIgZGF0YS1jYWNoZWQtc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxyXG4vLyBhbmQgYmFja1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtYXR0cmlidXRlLXZhbHVlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcclxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGU7XHJcblxyXG4gIHZhciB0ZW1wb3JhcnlBdHRyaWJ1dGUgPSAnZGF0YS1jYWNoZWQtJyArIGF0dHJpYnV0ZTtcclxuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG5cclxuICBpZiAodGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPT09IG51bGwpIHtcclxuICAgIHZhciBfdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG4gICAgaWYgKF92YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBjYW4ndCByZW1vdmUgd2hhdCdzIG5vdCB0aGVyZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlLCBfdmFsdWUgfHwgJycpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIF92YWx1ZTIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcclxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgX3ZhbHVlMik7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcbi8vIGhlbHBlciB0byB0dXJuXHJcbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwib3JpZ2luYWxcIj5cclxuLy8gaW50b1xyXG4vLyAgPGRpdiBkYXRhLWNhY2hlZC1zb21lLWF0dHJpYnV0ZT1cIm9yaWdpbmFsXCI+XHJcbi8vIGFuZCBiYWNrXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG4vLyB0aGlzIGZpbGUgaXMgb3ZlcndyaXR0ZW4gYnkgYG5wbSBydW4gYnVpbGQ6cHJlYFxyXG52YXIgdmVyc2lvbiA9ICcxLjQuMSc7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnNpb247XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoX3RleHQpIHtcclxuICAgIHZhciB0b2tlbnMgPSBfdGV4dC5zcGxpdCgnKycpO1xyXG4gICAgdmFyIF9tb2RpZmllcnMgPSByZXNvbHZlTW9kaWZpZXJzKHRva2Vucy5zbGljZSgwLCAtMSkpO1xyXG4gICAgdmFyIF9rZXlDb2RlcyA9IHJlc29sdmVLZXkodG9rZW5zLnNsaWNlKC0xKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXlDb2RlczogX2tleUNvZGVzLFxyXG4gICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXHJcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBtYXRjaE1vZGlmaWVycy5iaW5kKG51bGwsIF9tb2RpZmllcnMpXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxudmFyIF9rZXljb2RlID0gcmVxdWlyZSgnLi4vbWFwL2tleWNvZGUnKTtcclxuXHJcbnZhciBfa2V5Y29kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXljb2RlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgbW9kaWZpZXIgPSB7XHJcbiAgYWx0OiAnYWx0S2V5JyxcclxuICBjdHJsOiAnY3RybEtleScsXHJcbiAgbWV0YTogJ21ldGFLZXknLFxyXG4gIHNoaWZ0OiAnc2hpZnRLZXknXHJcbn07XHJcbi8qXHJcbiAgZGVjb2RlcyBhIGtleSBiaW5kaW5nIHRva2VuIHRvIGEgSmF2YVNjcmlwdCBzdHJ1Y3R1cmVcclxuXHJcbiAgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzOlxyXG4gICAge1xyXG4gICAgICAvLyBrZXkgbmFtZSB0cmFuc2xhdGVkIHRvIGtleUNvZGUgKHBvc3NpYmx5IG1vcmUgdGhhbiBvbmUpXHJcbiAgICAgIGtleUNvZGVzOiBbPG51bWJlcj5dLFxyXG4gICAgICAvLyB0cmFuc2xhdGVkIG1vZGlmaWVyc1xyXG4gICAgICBtb2RpZmllcnM6IHtcclxuICAgICAgICBhbHRLZXk6IG51bGwsICAgLy8gaWdub3JlXHJcbiAgICAgICAgY3RyS2V5OiBmYWxzZSwgIC8vIGV4cGVjdCBub3QgcHJlc3NlZFxyXG4gICAgICAgIG1ldGFLZXk6IHRydWUsICAvLyBleHBlY3QgcHJlc3NlZFxyXG4gICAgICAgIHNoaWZ0S2V5OiB0cnVlLCAvLyBleHBlY3QgcHJlc3NlZFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBjYWxsYmFjayB0aGF0IHJldHVybnMgdHJ1ZSBpZiBldmVudCdzXHJcbiAgICAgIC8vIG1vZGlmaWVyIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIHN0YXRlXHJcbiAgICAgIG1hdGNoTW9kaWZpZXJzOiBmdW5jdGlvbihldmVudCl7fSxcclxuICAgIH1cclxuKi9cclxuXHJcbnZhciBtb2RpZmllclNlcXVlbmNlID0gT2JqZWN0LmtleXMobW9kaWZpZXIpLm1hcChmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBtb2RpZmllcltuYW1lXTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpIHtcclxuICB2YXIgdmFsdWUgPSBpZ25vcmVNb2RpZmllcnMgPyBudWxsIDogZmFsc2U7XHJcbiAgcmV0dXJuIHtcclxuICAgIGFsdEtleTogdmFsdWUsXHJcbiAgICBjdHJsS2V5OiB2YWx1ZSxcclxuICAgIG1ldGFLZXk6IHZhbHVlLFxyXG4gICAgc2hpZnRLZXk6IHZhbHVlXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcclxuICB2YXIgaWdub3JlTW9kaWZpZXJzID0gbW9kaWZpZXJzLmluZGV4T2YoJyonKSAhPT0gLTE7XHJcbiAgdmFyIGV4cGVjdGVkID0gY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMoaWdub3JlTW9kaWZpZXJzKTtcclxuXHJcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBpZiAodG9rZW4gPT09ICcqJykge1xyXG4gICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNvdmVyZWQgdGhlIGFsbC1pbiBvcGVyYXRvclxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2Ugd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxyXG4gICAgdmFyIHZhbHVlID0gdHJ1ZTtcclxuICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnNsaWNlKDAsIDEpO1xyXG4gICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcclxuICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBpZiB0aGUgbW9kaWZpZXIgaXMgcHJlc3NlZFxyXG4gICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcclxuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdGhlIG1vZGlmaWVyIHByZXNzZWRcclxuICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcclxuICAgICAgLy8gY29tcGVuc2F0ZSBmb3IgdGhlIG1vZGlmaWVyJ3Mgb3BlcmF0b3JcclxuICAgICAgdG9rZW4gPSB0b2tlbi5zbGljZSgxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gbW9kaWZpZXJbdG9rZW5dO1xyXG4gICAgaWYgKCFwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBtb2RpZmllciBcIicgKyB0b2tlbiArICdcIicpO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cGVjdGVkW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGV4cGVjdGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlS2V5KGtleSkge1xyXG4gIHZhciBjb2RlID0gX2tleWNvZGUyLmRlZmF1bHRba2V5XSB8fCBwYXJzZUludChrZXksIDEwKTtcclxuICBpZiAoIWNvZGUgfHwgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGNvZGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicgKyBrZXkgKyAnXCInKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBbY29kZV0uY29uY2F0KF9rZXljb2RlMi5kZWZhdWx0Ll9hbGlhc1tjb2RlXSB8fCBbXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGV4cGVjdGVkLCBldmVudCkge1xyXG4gIC8vIHJldHVybnMgdHJ1ZSBvbiBtYXRjaFxyXG4gIHJldHVybiAhbW9kaWZpZXJTZXF1ZW5jZS5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAvLyByZXR1cm5zIHRydWUgb24gbWlzbWF0Y2hcclxuICAgIHJldHVybiB0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09ICdib29sZWFuJyAmJiBCb29sZWFuKGV2ZW50W3Byb3BdKSAhPT0gZXhwZWN0ZWRbcHJvcF07XHJcbiAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuYmluZGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgdmFyIGJpbmRpbmdzID0ge307XHJcblxyXG4gIHZhciBjb250ZXh0ID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG1hcC5jb250ZXh0KVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgZGVsZXRlIG1hcC5jb250ZXh0O1xyXG4gIHZhciBmaWx0ZXIgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobWFwLmZpbHRlcik7XHJcbiAgZGVsZXRlIG1hcC5maWx0ZXI7XHJcblxyXG4gIHZhciBtYXBLZXlzID0gT2JqZWN0LmtleXMobWFwKTtcclxuICBpZiAoIW1hcEtleXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3aGVuL2tleSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgb3B0aW9uIGtleScpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uIHJlZ2lzdGVyQmluZGluZyhldmVudCkge1xyXG4gICAgZXZlbnQua2V5Q29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICBpZiAoIWJpbmRpbmdzW2NvZGVdKSB7XHJcbiAgICAgICAgYmluZGluZ3NbY29kZV0gPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYmluZGluZ3NbY29kZV0ucHVzaChldmVudCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBtYXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcclxuICAgIGlmICh0eXBlb2YgbWFwW3RleHRdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIG9wdGlvbltcIicgKyB0ZXh0ICsgJ1wiXSB0byBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gYWRkQ2FsbGJhY2soZXZlbnQpIHtcclxuICAgICAgZXZlbnQuY2FsbGJhY2sgPSBtYXBbdGV4dF07XHJcbiAgICAgIHJldHVybiBldmVudDtcclxuICAgIH07XHJcblxyXG4gICAgKDAsIF9rZXkyLmRlZmF1bHQpKHRleHQpLm1hcChhZGRDYWxsYmFjaykuZm9yRWFjaChyZWdpc3RlckJpbmRpbmcpO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCkge1xyXG4gICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcclxuICAgICAgdmFyIGlzUGFyZW50T2ZFbGVtZW50ID0gKDAsIF9jb21wYXJlUG9zaXRpb24uZ2V0UGFyZW50Q29tcGFyYXRvcikoeyBlbGVtZW50OiBldmVudC50YXJnZXQsIGluY2x1ZGVTZWxmOiB0cnVlIH0pO1xyXG4gICAgICBpZiAoZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XHJcbiAgICBpZiAoIWJpbmRpbmdzW2tleV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGJpbmRpbmdzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoX2V2ZW50KSB7XHJcbiAgICAgIGlmICghX2V2ZW50Lm1hdGNoTW9kaWZpZXJzKGV2ZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX2V2ZW50LmNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXZlbnQsIGRpc2VuZ2FnZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XHJcblxyXG4gIHZhciBkaXNlbmdhZ2UgPSBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XHJcbiAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHsgZGlzZW5nYWdlOiBkaXNlbmdhZ2UgfTtcclxufTtcclxuXHJcbnZhciBfa2V5ID0gcmVxdWlyZSgnLi9rZXkuYmluZGluZycpO1xyXG5cclxudmFyIF9rZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5KTtcclxuXHJcbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XHJcblxyXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xyXG5cclxudmFyIF9jb21wYXJlUG9zaXRpb24gPSByZXF1aXJlKCcuLi91dGlsL2NvbXBhcmUtcG9zaXRpb24nKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8vIEJ1ZyAyODY5MzMgLSBLZXkgZXZlbnRzIGluIHRoZSBhdXRvY29tcGxldGUgcG9wdXAgc2hvdWxkIGJlIGhpZGRlbiBmcm9tIHBhZ2Ugc2NyaXB0c1xyXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yODY5MzNcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gVGhpcyBmaWxlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQGRydWRydSAoaHR0cHM6Ly9naXRodWIuY29tL2RydWRydS9hbnNpX3VwKSwgTUlULCAyMDExXHJcblxyXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBBTlNJX0NPTE9SUyA9IFtbeyBjb2xvcjogXCIwLCAwLCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsYWNrXCIgfSwgeyBjb2xvcjogXCIxODcsIDAsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAxODcsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktZ3JlZW5cIiB9LCB7IGNvbG9yOiBcIjE4NywgMTg3LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLXllbGxvd1wiIH0sIHsgY29sb3I6IFwiMCwgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsdWVcIiB9LCB7IGNvbG9yOiBcIjE4NywgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLW1hZ2VudGFcIiB9LCB7IGNvbG9yOiBcIjAsIDE4NywgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWN5YW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwyNTUsMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLXdoaXRlXCIgfV0sIFt7IGNvbG9yOiBcIjg1LCA4NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsYWNrXCIgfSwgeyBjb2xvcjogXCIyNTUsIDg1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAyNTUsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWdyZWVuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXllbGxvd1wiIH0sIHsgY29sb3I6IFwiODUsIDg1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsdWVcIiB9LCB7IGNvbG9yOiBcIjI1NSwgODUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtbWFnZW50YVwiIH0sIHsgY29sb3I6IFwiODUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1jeWFuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC13aGl0ZVwiIH1dXTtcclxuXHJcbnZhciBBbnNlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgbnVsbCwgW3tcclxuICAgICAgICBrZXk6IFwiZXNjYXBlRm9ySHRtbFwiLFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXIuZXNjYXBlRm9ySHRtbFxyXG4gICAgICAgICAqIEVzY2FwZSB0aGUgaW5wdXQgSFRNTC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgZG9lcyB0aGUgbWluaW11bSBlc2NhcGluZyBvZiB0ZXh0IHRvIG1ha2UgaXQgY29tcGxpYW50IHdpdGggSFRNTC5cclxuICAgICAgICAgKiBJbiBwYXJ0aWN1bGFyLCB0aGUgJyYnLCc8JywgYW5kICc+JyBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUaGlzIHNob3VsZFxyXG4gICAgICAgICAqIGJlIHJ1biBwcmlvciB0byBgYW5zaVRvSHRtbGAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBBbnNlci5lc2NhcGVGb3JIdG1sXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dCAoY29udGFpbmluZyB0aGUgQU5TSSBzbmlwcGV0cykuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY2FwZWQgaHRtbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlRm9ySHRtbCh0eHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmVzY2FwZUZvckh0bWwodHh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuc2VyLmxpbmtpZnlcclxuICAgICAgICAgKiBBZGRzIHRoZSBsaW5rcyBpbiB0aGUgSFRNTC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGxpbmtzIGluIHRoZSB0ZXh0IHdpdGggYW5jaG9yIHRhZ3MgdGhhdCBkaXNwbGF5IHRoZVxyXG4gICAgICAgICAqIGxpbmsuIFRoZSBsaW5rcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcclxuICAgICAgICAgKiBzdXJyb3VuZGluZyBpdC4gQWxzbywgeW91IHNob3VsZCBhcHBseSB0aGlzIGFmdGVyIHlvdSBoYXZlIHJ1blxyXG4gICAgICAgICAqIGBhbnNpVG9IdG1sYCBvbiB0aGUgdGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmxpbmtpZnlcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIGNvbnRhaW5pbmcgdGhlIDxhPiB0YWdzICh1bmVzY2FwZWQpLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkubGlua2lmeSh0eHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXIuYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgQU5TSSB0ZXJtaW5hbCBlc2NhcGUgY29kZXMgd2l0aCBTUEFOIHRhZ3MgdGhhdCB3cmFwIHRoZVxyXG4gICAgICAgICAqIGNvbnRlbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIG9ubHkgaW50ZXJwcmV0cyBBTlNJIFNHUiAoU2VsZWN0IEdyYXBoaWMgUmVuZGl0aW9uKSBjb2Rlc1xyXG4gICAgICAgICAqIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIEhUTUwuXHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGN1cnNvciBtb3ZlbWVudCBjb2RlcyBhcmUgaWdub3JlZCBhbmQgaGlkZGVuIGZyb20gb3V0cHV0LlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHN0eWxlIHVzZXMgY29sb3JzIHRoYXQgYXJlIHZlcnkgY2xvc2UgdG8gdGhlIHByZXNjcmliZWRcclxuICAgICAgICAgKiBzdGFuZGFyZC4gVGhlIHN0YW5kYXJkIGFzc3VtZXMgdGhhdCB0aGUgdGV4dCB3aWxsIGhhdmUgYSBibGFja1xyXG4gICAgICAgICAqIGJhY2tncm91bmQuIFRoZXNlIGNvbG9ycyBhcmUgc2V0IGFzIGlubGluZSBzdHlsZXMgb24gdGhlIFNQQU4gdGFncy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNldCBgdXNlX2NsYXNzZXM6IHRydWVgIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBpbnN0ZWFkIHNldCBjbGFzc2VzIG9uIHRoZSBzcGFucyBzbyB0aGUgY29sb3JzIGNhbiBiZSBzZXQgdmlhXHJcbiAgICAgICAgICogQ1NTLiBUaGUgY2xhc3MgbmFtZXMgdXNlZCBhcmUgb2YgdGhlIGZvcm1hdCBgYW5zaS0qLWZnL2JnYCBhbmRcclxuICAgICAgICAgKiBgYW5zaS1icmlnaHQtKi1mZy9iZ2Agd2hlcmUgYCpgIGlzIHRoZSBjb2xvciBuYW1lLFxyXG4gICAgICAgICAqIGkuZSBibGFjay9yZWQvZ3JlZW4veWVsbG93L2JsdWUvbWFnZW50YS9jeWFuL3doaXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9IdG1sKHR4dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnNlci5hbnNpVG9Kc29uXHJcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEpTT04gb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSnNvblxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9Kc29uXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0pzb24odHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9Kc29uKHR4dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbnNlci5hbnNpVG9UZXh0XHJcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIHRleHQgb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvVGV4dFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRleHQgb3V0cHV0LlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwiYW5zaVRvVGV4dFwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvVGV4dCh0eHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5zZXJcclxuICAgICAgICAgKiBUaGUgYEFuc2VyYCBjbGFzcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIEFuc2VyXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge0Fuc2VyfVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH1dKTtcclxuXHJcbiAgICBmdW5jdGlvbiBBbnNlcigpIHtcclxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5zZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmZnID0gdGhpcy5iZyA9IHRoaXMuZmdfdHJ1ZWNvbG9yID0gdGhpcy5iZ190cnVlY29sb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnJpZ2h0ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldHVwUGFsZXR0ZVxyXG4gICAgICogU2V0cyB1cCB0aGUgcGFsZXR0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBzZXR1cFBhbGV0dGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICovXHJcblxyXG5cclxuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgW3tcclxuICAgICAgICBrZXk6IFwic2V0dXBQYWxldHRlXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwUGFsZXR0ZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMC4uMTUgOiBTeXN0ZW0gY29sb3JcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKEFOU0lfQ09MT1JTW2ldW2pdLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMTYuLjIzMSA6IFJHQiA2eDZ4NlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qYXNvbm0yMy8yODY4OTgxI2ZpbGUteHRlcm0tMjU2Y29sb3IteWFtbFxyXG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gWzAsIDk1LCAxMzUsIDE3NSwgMjE1LCAyNTVdO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KHIsIGcsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHNbcl0gKyBcIiwgXCIgKyBsZXZlbHNbZ10gKyBcIiwgXCIgKyBsZXZlbHNbYl07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciByID0gdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgZyA9IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgIGIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9yID0gMDsgX3IgPCA2OyArK19yKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDA7IF9nIDwgNjsgKytfZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMDsgX2IgPCA2OyArK19iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChmb3JtYXQoX3IsIF9nLCBfYikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5kZXggMjMyLi4yNTUgOiBHcmF5c2NhbGVcclxuICAgICAgICAgICAgdmFyIGxldmVsID0gODtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI0OyArK19pLCBsZXZlbCArPSAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChsZXZlbCwgbGV2ZWwsIGxldmVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGVzY2FwZUZvckh0bWxcclxuICAgICAgICAgKiBFc2NhcGVzIHRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgZXNjYXBlRm9ySHRtbFxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY3BhZWQgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJlc2NhcGVGb3JIdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVzY2FwZUZvckh0bWwodHh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvWyY8Pl0vZ20sIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT0gXCImXCIgPyBcIiZhbXA7XCIgOiBzdHIgPT0gXCI8XCIgPyBcIiZsdDtcIiA6IHN0ciA9PSBcIj5cIiA/IFwiJmd0O1wiIDogXCJcIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBsaW5raWZ5XHJcbiAgICAgICAgICogQWRkcyBIVE1MIGxpbmsgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBsaW5raWZ5XHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQgY29udGFpbmluZyBsaW5rIGVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHh0LnJlcGxhY2UoLyhodHRwcz86XFwvXFwvW15cXHNdKykvZ20sIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgc3RyICsgXCJcXFwiPlwiICsgc3RyICsgXCI8L2E+XCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYW5zaVRvSHRtbFxyXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb0h0bWxcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCBvdCB0aGUgYHByb2Nlc3NgIG1ldGhvZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGFuc2lUb0pzb25cclxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBhbnNpVG9Kc29uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgb3QgdGhlIGBwcm9jZXNzYCBtZXRob2QuXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEpTT04gb3V0cHV0LlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgIH0sIHtcclxuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9Kc29uKHR4dCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgb3B0aW9ucy5qc29uID0gdHJ1ZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5jbGVhckxpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYW5zaVRvVGV4dFxyXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb1RleHRcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICB9LCB7XHJcbiAgICAgICAga2V5OiBcImFuc2lUb1RleHRcIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvVGV4dCh0eHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIHt9LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcm9jZXNzXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBpbnB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBwYXNzZWQgdG8gYHByb2Nlc3NDaHVua2AgbWV0aG9kLCBleHRlbmRlZCB3aXRoOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxyXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJwcm9jZXNzXCIsXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModHh0LCBvcHRpb25zLCBtYXJrdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHJhd190ZXh0X2NodW5rcyA9IHR4dC5zcGxpdCgvXFwwMzNcXFsvKTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0X2NodW5rID0gcmF3X3RleHRfY2h1bmtzLnNoaWZ0KCk7IC8vIHRoZSBmaXJzdCBjaHVuayBpcyBub3QgdGhlIHJlc3VsdCBvZiB0aGUgc3BsaXRcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gL1xcci8udGVzdCh0eHQpOyAvLyBjaGVjayBmb3IgQ2FycmlhZ2UgUmV0dXJuXHJcbiAgICAgICAgICAgIHZhciBjb2xvcl9jaHVua3MgPSByYXdfdGV4dF9jaHVua3MubWFwKGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb2Nlc3NDaHVuayhjaHVuaywgb3B0aW9ucywgbWFya3VwKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHNlbGYucHJvY2Vzc0NodW5rSnNvbihcIlwiKTtcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdF9jaHVuaztcclxuICAgICAgICAgICAgICAgIGZpcnN0LmNsZWFyTGluZSA9IG9wdGlvbnMuY2xlYXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlX2VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzID0gY29sb3JfY2h1bmtzLmZpbHRlcihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWMuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yX2NodW5rcy51bnNoaWZ0KGZpcnN0X2NodW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcy5qb2luKFwiXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvY2Vzc0NodW5rSnNvblxyXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBpbnRvIGpzb24gb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rSnNvblxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxyXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2JqZWN0OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIC0gYGNvbnRlbnRgIChTdHJpbmcpOiBUaGUgdGV4dC5cclxuICAgICAgICAgKiAgLSBgZmdgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIGNvbG9yLlxyXG4gICAgICAgICAqICAtIGBiZ2AgKFN0cmluZ3xudWxsKTogVGhlIGJhY2tncm91bmQgY29sb3IuXHJcbiAgICAgICAgICogIC0gYGZnX3RydWVjb2xvcmAgKFN0cmluZ3xudWxsKTogVGhlIGZvcmVncm91bmQgdHJ1ZSBjb2xvciAoaWYgMTZtIGNvbG9yIGlzIGVuYWJsZWQpLlxyXG4gICAgICAgICAqICAtIGBiZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cclxuICAgICAgICAgKiAgLSBgY2xlYXJMaW5lYCAoQm9vbGVhbik6IGB0cnVlYCBpZiBhIGNhcnJpYWdlUmV0dXJuIFxcciB3YXMgZm91bnQgYXQgZW5kIG9mIGxpbmUuXHJcbiAgICAgICAgICogIC0gYHdhc19wcm9jZXNzZWRgIChCb2xlYW4pOiBgdHJ1ZWAgaWYgdGhlIGNvbG9ycyB3ZXJlIHByb2Nlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgICAgICogIC0gYGlzRW1wdHlgIChGdW5jdGlvbik6IEEgZnVuY3Rpb24gcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY29udGVudCBpcyBlbXB0eSwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuXHJcbiAgICB9LCB7XHJcbiAgICAgICAga2V5OiBcInByb2Nlc3NDaHVua0pzb25cIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFyZSB3ZSB1c2luZyBjbGFzc2VzIG9yIHN0eWxlcz9cclxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09IFwidW5kZWZpbmVkXCIgPyB7fSA6IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciB1c2VfY2xhc3NlcyA9IG9wdGlvbnMudXNlX2NsYXNzZXMgPSB0eXBlb2Ygb3B0aW9ucy51c2VfY2xhc3NlcyAhPSBcInVuZGVmaW5lZFwiICYmIG9wdGlvbnMudXNlX2NsYXNzZXM7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleSA9IHVzZV9jbGFzc2VzID8gXCJjbGFzc1wiIDogXCJjb2xvclwiO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICBmZzogbnVsbCxcclxuICAgICAgICAgICAgICAgIGJnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZmdfdHJ1ZWNvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYmdfdHJ1ZWNvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xlYXJMaW5lOiBvcHRpb25zLmNsZWFyTGluZSxcclxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICB3YXNfcHJvY2Vzc2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQuY29udGVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVhY2ggXCJjaHVua1wiIGlzIHRoZSB0ZXh0IGFmdGVyIHRoZSBDU0kgKEVTQyArIFwiW1wiKSBhbmQgYmVmb3JlIHRoZSBuZXh0IENTSS9FT0YuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFRoaXMgcmVnZXggbWF0Y2hlcyBmb3VyIGdyb3VwcyB3aXRoaW4gYSBjaHVuay5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGFuZCB0aGlyZCBncm91cHMgbWF0Y2ggY29kZSB0eXBlLlxyXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0ZWQgb25seSBTR1IgY29tbWFuZC4gSXQgaGFzIGVtcHR5IGZpcnN0IGdyb3VwIGFuZCBcIm1cIiBpbiB0aGlyZC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBncm91cCBtYXRjaGVzIGFsbCBvZiB0aGUgbnVtYmVyK3NlbWljb2xvbiBjb21tYW5kIHNlcXVlbmNlc1xyXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIFwibVwiIChvciBvdGhlciB0cmFpbGluZykgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGdyYXBoaWNzIG9yIFNHUiBjb21tYW5kcy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZ3JvdXAgaXMgdGhlIHRleHQgKGluY2x1ZGluZyBuZXdsaW5lcykgdGhhdCBpcyBjb2xvcmVkIGJ5XHJcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciBncm91cFwicyBjb21tYW5kcy5cclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKC9eKFshXFx4M2MtXFx4M2ZdKikoW1xcZDtdKikoW1xceDIwLVxceDJjXSpbXFx4NDAtXFx4N2VdKShbXFxzXFxTXSopL20pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgdmFyIG9yaWdfdHh0ID0gcmVzdWx0LmNvbnRlbnQgPSBtYXRjaGVzWzRdO1xyXG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgY3VycmVudGx5IHN1cHBvcnQgb25seSBcIlNHUlwiIChTZWxlY3QgR3JhcGhpYyBSZW5kaXRpb24pXHJcbiAgICAgICAgICAgIC8vIFNpbXBseSBpZ25vcmUgaWYgbm90IGEgU0dSIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzFdICE9PSBcIlwiIHx8IG1hdGNoZXNbM10gIT09IFwibVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1hcmt1cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChudW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW1fc3RyID0gbnVtcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pIHx8IG51bSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBzZWxmLmJnID0gc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJib2xkXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiZGltXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNvZGUgMiB0byBnZXQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJpdGFsaWNcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiYmxpbmtcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJyZXZlcnNlXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNvZGUgOSB0byBnZXQgc3RyaWtldGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInN0cmlrZXRocm91Z2hcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDM5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSA0OSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgY29sb3JcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDMwICYmIG51bSA8IDM4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IEFOU0lfQ09MT1JTWzBdW251bSAlIDEwXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgYnJpZ2h0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA5MCAmJiBudW0gPCA5OCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA0MCAmJiBudW0gPCA0OCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1swXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGJyaWdodCBjb2xvclxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMTAwICYmIG51bSA8IDEwOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAzOCB8fCBudW0gPT09IDQ4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGNvbG9yICgzOD1mZywgNDg9YmcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2ZvcmVncm91bmQgPSBudW0gPT09IDM4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1zLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gbnVtcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCI1XCIgJiYgbnVtcy5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFsZXR0ZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbGV0dGVfaW5kZXggPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbGV0dGVfaW5kZXggPj0gMCAmJiBwYWxldHRlX2luZGV4IDw9IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlX2NsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlBBTEVUVEVfQ09MT1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gdGhpcy5QQUxFVFRFX0NPTE9SU1twYWxldHRlX2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtsYXNzID0gcGFsZXR0ZV9pbmRleCA+PSAxNiA/IFwiYW5zaS1wYWxldHRlLVwiICsgcGFsZXR0ZV9pbmRleCA6IEFOU0lfQ09MT1JTW3BhbGV0dGVfaW5kZXggPiA3ID8gMSA6IDBdW3BhbGV0dGVfaW5kZXggJSA4XVtcImNsYXNzXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IGtsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGtsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiMlwiICYmIG51bXMubGVuZ3RoID49IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID49IDAgJiYgciA8PSAyNTUgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IFwiYW5zaS10cnVlY29sb3JcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmdfdHJ1ZWNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gXCJhbnNpLXRydWVjb2xvclwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZ190cnVlY29sb3IgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuZmcgPT09IG51bGwgJiYgc2VsZi5iZyA9PT0gbnVsbCAmJiBzZWxmLmRlY29yYXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmcgPSBzZWxmLmZnO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnID0gc2VsZi5iZztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5mZ190cnVlY29sb3IgPSBzZWxmLmZnX3RydWVjb2xvcjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5iZ190cnVlY29sb3IgPSBzZWxmLmJnX3RydWVjb2xvcjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWNvcmF0aW9uID0gc2VsZi5kZWNvcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lndhc19wcm9jZXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3NDaHVua1xyXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBvZiB0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmaWVsZHM6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXHJcbiAgICAgICAgICogIC0gYHVzZV9jbGFzc2VzYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgSFRNTCBjbGFzc2VzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIEhUTUwgb3V0cHV0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdHxTdHJpbmd9IFRoZSByZXN1bHQgKG9iamVjdCBpZiBganNvbmAgaXMgd2FudGVkIGJhY2sgb3Igc3RyaW5nIG90aGVyd2lzZSkuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgfSwge1xyXG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2h1bmtcIixcclxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rKHRleHQsIG9wdGlvbnMsIG1hcmt1cCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIHZhciBqc29uQ2h1bmsgPSB0aGlzLnByb2Nlc3NDaHVua0pzb24odGV4dCwgb3B0aW9ucywgbWFya3VwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmpzb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghanNvbkNodW5rLndhc19wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bmsuY29udGVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHVzZV9jbGFzc2VzID0gb3B0aW9ucy51c2VfY2xhc3NlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcl9kYXRhID0gZnVuY3Rpb24gcmVuZGVyX2RhdGEoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIF90aGlzMi5lc2NhcGVGb3JIdG1sKGRhdGFba2V5XSkgKyBcIlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggPiAwID8gXCIgXCIgKyBmcmFnbWVudHMuam9pbihcIiBcIikgOiBcIlwiO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGpzb25DaHVuay5mZyArIFwiLWZnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1mZ1wiXSA9IGpzb25DaHVuay5mZ190cnVlY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5mZ190cnVlY29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJjb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuZmcgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuYmcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChqc29uQ2h1bmsuYmcgKyBcIi1iZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkNodW5rLmJnX3RydWVjb2xvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW1wiYW5zaS10cnVlY29sb3ItYmdcIl0gPSBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuYmcgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYW5zaS1cIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwiYm9sZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJmb250LXdlaWdodDpib2xkXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJkaW1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwib3BhY2l0eTowLjVcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcIml0YWxpY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJmb250LXN0eWxlOml0YWxpY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmxpbmUgYW5kIGJsaW5rIGFyZSB0cmVhdGVkIGJlbGxvd1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJyZXZlcnNlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZpbHRlcjppbnZlcnQoMTAwJSlcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImhpZGRlblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ2aXNpYmlsaXR5OmhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwic3RyaWtldGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcInRleHQtZGVjb3JhdGlvbjpcIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwiXCIgKyBjbGFzc2VzLmpvaW4oXCIgXCIpICsgXCJcXFwiXCIgKyByZW5kZXJfZGF0YShkYXRhKSArIFwiPlwiICsganNvbkNodW5rLmNvbnRlbnQgKyBcIjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIHN0eWxlcy5qb2luKFwiO1wiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XSk7XHJcblxyXG4gICAgcmV0dXJuIEFuc2VyO1xyXG59KCk7XHJcblxyXG47XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFuc2VyOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xyXG5cdGNvbnN0IHBhdHRlcm4gPSBbXHJcblx0XHQnW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KScsXHJcblx0XHQnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXHJcblx0XS5qb2luKCd8Jyk7XHJcblxyXG5cdHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XHJcbn07XHJcbiIsIi8qISBodHRwczovL210aHMuYmUvY3NzZXNjYXBlIHYxLjUuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXHJcbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xyXG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0Jykge1xyXG5cdFx0Ly8gRm9yIE5vZGUuanMuXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0Ly8gRm9yIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuXHRcdGRlZmluZShbXSwgZmFjdG9yeS5iaW5kKHJvb3QsIHJvb3QpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gRm9yIGJyb3dzZXIgZ2xvYmFscyAobm90IGV4cG9zaW5nIHRoZSBmdW5jdGlvbiBzZXBhcmF0ZWx5KS5cclxuXHRcdGZhY3Rvcnkocm9vdCk7XHJcblx0fVxyXG59KHR5cGVvZiBnbG9iYWwgIT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzLCBmdW5jdGlvbihyb290KSB7XHJcblxyXG5cdGlmIChyb290LkNTUyAmJiByb290LkNTUy5lc2NhcGUpIHtcclxuXHRcdHJldHVybiByb290LkNTUy5lc2NhcGU7XHJcblx0fVxyXG5cclxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3NlcmlhbGl6ZS1hbi1pZGVudGlmaWVyXHJcblx0dmFyIGNzc0VzY2FwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BDU1MuZXNjYXBlYCByZXF1aXJlcyBhbiBhcmd1bWVudC4nKTtcclxuXHRcdH1cclxuXHRcdHZhciBzdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xyXG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XHJcblx0XHR2YXIgaW5kZXggPSAtMTtcclxuXHRcdHZhciBjb2RlVW5pdDtcclxuXHRcdHZhciByZXN1bHQgPSAnJztcclxuXHRcdHZhciBmaXJzdENvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XHJcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG5cdFx0XHRjb2RlVW5pdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcclxuXHRcdFx0Ly8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcclxuXHRcdFx0Ly8gcGFpcnMsIG9yIGxvbmUgc3Vycm9nYXRlcy5cclxuXHJcblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aGUgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXHJcblx0XHRcdC8vIChVK0ZGRkQpLlxyXG5cdFx0XHRpZiAoY29kZVVuaXQgPT0gMHgwMDAwKSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9ICdcXHVGRkZEJztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gdGhlIHJhbmdlIFtcXDEtXFwxRl0gKFUrMDAwMSB0byBVKzAwMUYpIG9yIGlzXHJcblx0XHRcdFx0Ly8gVSswMDdGLCBb4oCmXVxyXG5cdFx0XHRcdChjb2RlVW5pdCA+PSAweDAwMDEgJiYgY29kZVVuaXQgPD0gMHgwMDFGKSB8fCBjb2RlVW5pdCA9PSAweDAwN0YgfHxcclxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxyXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cclxuXHRcdFx0XHQoaW5kZXggPT0gMCAmJiBjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5KSB8fFxyXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIHNlY29uZCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxyXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIGAtYCAoVSswMDJEKSwgW+KApl1cclxuXHRcdFx0XHQoXHJcblx0XHRcdFx0XHRpbmRleCA9PSAxICYmXHJcblx0XHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXHJcblx0XHRcdFx0XHRmaXJzdENvZGVVbml0ID09IDB4MDAyRFxyXG5cdFx0XHRcdClcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXItYXMtY29kZS1wb2ludFxyXG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBjb2RlVW5pdC50b1N0cmluZygxNikgKyAnICc7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGEgYC1gIChVKzAwMkQpLCBhbmRcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBzZWNvbmQgY2hhcmFjdGVyLCBb4oCmXVxyXG5cdFx0XHRcdGluZGV4ID09IDAgJiZcclxuXHRcdFx0XHRsZW5ndGggPT0gMSAmJlxyXG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRFxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gJ1xcXFwnICsgc3RyaW5nLmNoYXJBdChpbmRleCk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGhhbmRsZWQgYnkgb25lIG9mIHRoZSBhYm92ZSBydWxlcyBhbmQgaXNcclxuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFUrMDA4MCwgaXMgYC1gIChVKzAwMkQpIG9yIGBfYCAoVSswMDVGKSwgb3JcclxuXHRcdFx0Ly8gaXMgaW4gb25lIG9mIHRoZSByYW5nZXMgWzAtOV0gKFUrMDAzMCB0byBVKzAwMzkpLCBbQS1aXSAoVSswMDQxIHRvXHJcblx0XHRcdC8vIFUrMDA1QSksIG9yIFthLXpdIChVKzAwNjEgdG8gVSswMDdBKSwgW+KApl1cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA4MCB8fFxyXG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRCB8fFxyXG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDA1RiB8fFxyXG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkgfHxcclxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwNDEgJiYgY29kZVVuaXQgPD0gMHgwMDVBIHx8XHJcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIGl0c2VsZlxyXG5cdFx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyXHJcblx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdGlmICghcm9vdC5DU1MpIHtcclxuXHRcdHJvb3QuQ1NTID0ge307XHJcblx0fVxyXG5cclxuXHRyb290LkNTUy5lc2NhcGUgPSBjc3NFc2NhcGU7XHJcblx0cmV0dXJuIGNzc0VzY2FwZTtcclxuXHJcbn0pKTtcclxuIiwidmFyIGUsdD0oZT1yZXF1aXJlKFwicXVlcnlzdHJpbmdcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplLHI9L2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvO2Z1bmN0aW9uIG8oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWcoZSkpO3ZhciBvPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbz1lLmF1dGgsYT1lLmhvc3RuYW1lLHM9ZS5wcm90b2NvbHx8XCJcIixjPWUucGF0aG5hbWV8fFwiXCIsaD1lLmhhc2h8fFwiXCIscD1lLnF1ZXJ5fHxcIlwiLG49ITE7bz1vP2VuY29kZVVSSUNvbXBvbmVudChvKS5yZXBsYWNlKC8lM0EvaSxcIjpcIikrXCJAXCI6XCJcIixlLmhvc3Q/bj1vK2UuaG9zdDphJiYobj1vKyh+YS5pbmRleE9mKFwiOlwiKT9cIltcIithK1wiXVwiOmEpLGUucG9ydCYmKG4rPVwiOlwiK2UucG9ydCkpLHAmJlwib2JqZWN0XCI9PXR5cGVvZiBwJiYocD10LmVuY29kZShwKSk7dmFyIGw9ZS5zZWFyY2h8fHAmJlwiP1wiK3B8fFwiXCI7cmV0dXJuIHMmJlwiOlwiIT09cy5zdWJzdHIoLTEpJiYocys9XCI6XCIpLGUuc2xhc2hlc3x8KCFzfHxyLnRlc3QocykpJiYhMSE9PW4/KG49XCIvL1wiKyhufHxcIlwiKSxjJiZcIi9cIiE9PWNbMF0mJihjPVwiL1wiK2MpKTpufHwobj1cIlwiKSxoJiZcIiNcIiE9PWhbMF0mJihoPVwiI1wiK2gpLGwmJlwiP1wiIT09bFswXSYmKGw9XCI/XCIrbCkse3Byb3RvY29sOnMsaG9zdDpuLHBhdGhuYW1lOmM9Yy5yZXBsYWNlKC9bPyNdL2csZW5jb2RlVVJJQ29tcG9uZW50KSxzZWFyY2g6bD1sLnJlcGxhY2UoXCIjXCIsXCIlMjNcIiksaGFzaDpofX0oZSx0LHIpO3JldHVyblwiXCIrby5wcm90b2NvbCtvLmhvc3Qrby5wYXRobmFtZStvLnNlYXJjaCtvLmhhc2h9dmFyIGE9XCJodHRwOi8vXCIscz1cIncud1wiLGM9YStzLGg9L14oW2EtejAtOS4rLV0qOlxcL1xcL1xcLykoW2EtejAtOS4rLV06XFwvKik/L2kscD0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gbihlLHQpe3ZhciByPVwic3RyaW5nXCI9PXR5cGVvZiBlP2coZSk6ZTtlPVwib2JqZWN0XCI9PXR5cGVvZiBlP28oZSk6ZTt2YXIgcz1nKHQpLG49XCJcIjtyLnByb3RvY29sJiYhci5zbGFzaGVzJiYobj1yLnByb3RvY29sLGU9ZS5yZXBsYWNlKHIucHJvdG9jb2wsXCJcIiksbis9XCIvXCI9PT10WzBdfHxcIi9cIj09PWVbMF0/XCIvXCI6XCJcIiksbiYmcy5wcm90b2NvbCYmKG49XCJcIixzLnNsYXNoZXN8fChuPXMucHJvdG9jb2wsdD10LnJlcGxhY2Uocy5wcm90b2NvbCxcIlwiKSkpO3ZhciBsPWUubWF0Y2goaCk7bCYmIXMucHJvdG9jb2wmJihlPWUuc3Vic3RyKChuPWxbMV0rKGxbMl18fFwiXCIpKS5sZW5ndGgpLC9eXFwvXFwvW14vXS8udGVzdCh0KSYmKG49bi5zbGljZSgwLC0xKSkpO3ZhciBpPW5ldyBVUkwoZSxjK1wiL1wiKSxmPW5ldyBVUkwodCxpKS50b1N0cmluZygpLnJlcGxhY2UoYyxcIlwiKSx1PXMucHJvdG9jb2x8fHIucHJvdG9jb2w7cmV0dXJuIHUrPXIuc2xhc2hlc3x8cy5zbGFzaGVzP1wiLy9cIjpcIlwiLCFuJiZ1P2Y9Zi5yZXBsYWNlKGEsdSk6biYmKGY9Zi5yZXBsYWNlKGEsXCJcIikpLHAudGVzdChmKXx8fnQuaW5kZXhPZihcIi5cIil8fFwiL1wiPT09ZS5zbGljZSgtMSl8fFwiL1wiPT09dC5zbGljZSgtMSl8fFwiL1wiIT09Zi5zbGljZSgtMSl8fChmPWYuc2xpY2UoMCwtMSkpLG4mJihmPW4rKFwiL1wiPT09ZlswXT9mLnN1YnN0cigxKTpmKSksZn1mdW5jdGlvbiBsKCl7fWwucGFyc2U9ZyxsLmZvcm1hdD1vLGwucmVzb2x2ZT1uLGwucmVzb2x2ZU9iamVjdD1uO3ZhciBpPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sZj0vXiguKj8pKFsjP10uKikvLHU9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLG09L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUpe3RyeXtyZXR1cm4gZGVjb2RlVVJJKGUpfWNhdGNoKHQpe3JldHVybiBlfX1mdW5jdGlvbiBnKGUscixhKXtpZih2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09YSYmKGE9ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgaD0oZT1lLnRyaW0oKSkubWF0Y2goZik7ZT1oP2QoaFsxXSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStoWzJdOmQoZSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSx2LnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIHA9IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHUpLG49bS50ZXN0KGUpLGc9XCJcIjtwJiYoaS50ZXN0KHBbMV0pfHwoZz1wWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK3BbMl0rcFszXSkscFsyXXx8KG49ITEsaS50ZXN0KHBbMV0pPyhnPXBbMV0sZT1cIlwiK3BbM10pOmU9XCIvL1wiK3BbM10pLDMhPT1wWzJdLmxlbmd0aCYmMSE9PXBbMl0ubGVuZ3RofHwoZz1wWzFdLGU9XCIvXCIrcFszXSkpO3ZhciBiLHk9KGg/aFsxXTplKS5tYXRjaCgvKDpbMC05XSspLyksaj1cIlwiO3kmJnlbMV0mJjM9PT15WzFdLmxlbmd0aCYmKGU9ZS5yZXBsYWNlKGo9eVsxXSxqK1wiMDBcIikpO3ZhciB3PW5ldyBsLHg9XCJcIixVPVwiXCI7dHJ5e2I9bmV3IFVSTChlKX1jYXRjaCh0KXt4PXQsZ3x8YXx8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2I9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB3LnByb3RvY29sPWcsdy5ocmVmPWcsd319dy5zbGFzaGVzPW4mJiFVLHcuaG9zdD1iLmhvc3Q9PT1zP1wiXCI6Yi5ob3N0LHcuaG9zdG5hbWU9Yi5ob3N0bmFtZT09PXM/XCJcIjpiLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHcucHJvdG9jb2w9eD9nfHxudWxsOmIucHJvdG9jb2wsdy5zZWFyY2g9Yi5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHcuaGFzaD1iLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBSPWUuc3BsaXQoXCIjXCIpOyF3LnNlYXJjaCYmflJbMF0uaW5kZXhPZihcIj9cIikmJih3LnNlYXJjaD1cIj9cIiksdy5oYXNofHxcIlwiIT09UlsxXXx8KHcuaGFzaD1cIiNcIiksdy5xdWVyeT1yP3QuZGVjb2RlKGIuc2VhcmNoLnN1YnN0cigxKSk6dy5zZWFyY2guc3Vic3RyKDEpLHcucGF0aG5hbWU9VStkKGIucGF0aG5hbWUpLnJlcGxhY2UoL1wiL2csXCIlMjJcIiksXCJhYm91dDpcIj09PXcucHJvdG9jb2wmJlwiYmxhbmtcIj09PXcucGF0aG5hbWUmJih3LnByb3RvY29sPVwiXCIsdy5wYXRobmFtZT1cIlwiKSx4JiZcIi9cIiE9PWVbMF0mJih3LnBhdGhuYW1lPXcucGF0aG5hbWUuc3Vic3RyKDEpKSxnJiYhaS50ZXN0KGcpJiZcIi9cIiE9PWUuc2xpY2UoLTEpJiZcIi9cIj09PXcucGF0aG5hbWUmJih3LnBhdGhuYW1lPVwiXCIpLHcucGF0aD13LnBhdGhuYW1lK3cuc2VhcmNoLHcuYXV0aD1bYi51c2VybmFtZSxiLnBhc3N3b3JkXS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjpcIiksdy5wb3J0PWIucG9ydCxqJiYody5ob3N0PXcuaG9zdC5yZXBsYWNlKGorXCIwMFwiLGopLHcucG9ydD13LnBvcnQuc2xpY2UoMCwtMikpLHcuaHJlZj1VP1wiXCIrdy5wYXRobmFtZSt3LnNlYXJjaCt3Lmhhc2g6byh3KTt2YXIgTz0vXihmaWxlKS8udGVzdCh3LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh3KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe35PLmluZGV4T2YoZSl8fCh3W2VdPXdbZV18fG51bGwpfSksd31leHBvcnRzLnBhcnNlPWcsZXhwb3J0cy5mb3JtYXQ9byxleHBvcnRzLnJlc29sdmU9bixleHBvcnRzLnJlc29sdmVPYmplY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZyhuKGUsdCkpfSxleHBvcnRzLlVybD1sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcclxuIiwiUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseT1mdW5jdGlvbihuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXJldHVybiB0aGlzLnRoZW4obixuKTt2YXIgdD10aGlzLmNvbnN0cnVjdG9yfHxQcm9taXNlO3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocil7cmV0dXJuIHQucmVzb2x2ZShuKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcn0pfSxmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKG4oKSkudGhlbihmdW5jdGlvbigpe3Rocm93IHJ9KX0pfTsiLCJtb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihlLG4pe3JldHVybiBuPW58fHt9LG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7dmFyIHM9bmV3IFhNTEh0dHBSZXF1ZXN0LG89W10sdT1bXSxpPXt9LGE9ZnVuY3Rpb24oKXtyZXR1cm57b2s6Mj09KHMuc3RhdHVzLzEwMHwwKSxzdGF0dXNUZXh0OnMuc3RhdHVzVGV4dCxzdGF0dXM6cy5zdGF0dXMsdXJsOnMucmVzcG9uc2VVUkwsdGV4dDpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUocy5yZXNwb25zZVRleHQpfSxqc29uOmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKHMucmVzcG9uc2VUZXh0KSl9LGJsb2I6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFtzLnJlc3BvbnNlXSkpfSxjbG9uZTphLGhlYWRlcnM6e2tleXM6ZnVuY3Rpb24oKXtyZXR1cm4gb30sZW50cmllczpmdW5jdGlvbigpe3JldHVybiB1fSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGlbZS50b0xvd2VyQ2FzZSgpXX0saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlLnRvTG93ZXJDYXNlKClpbiBpfX19fTtmb3IodmFyIGwgaW4gcy5vcGVuKG4ubWV0aG9kfHxcImdldFwiLGUsITApLHMub25sb2FkPWZ1bmN0aW9uKCl7cy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5yZXBsYWNlKC9eKC4qPyk6W15cXFNcXG5dKihbXFxzXFxTXSo/KSQvZ20sZnVuY3Rpb24oZSxuLHQpe28ucHVzaChuPW4udG9Mb3dlckNhc2UoKSksdS5wdXNoKFtuLHRdKSxpW25dPWlbbl0/aVtuXStcIixcIit0OnR9KSx0KGEoKSl9LHMub25lcnJvcj1yLHMud2l0aENyZWRlbnRpYWxzPVwiaW5jbHVkZVwiPT1uLmNyZWRlbnRpYWxzLG4uaGVhZGVycylzLnNldFJlcXVlc3RIZWFkZXIobCxuLmhlYWRlcnNbbF0pO3Muc2VuZChuLmJvZHl8fG51bGwpfSl9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmZldGNoLmpzLm1hcFxyXG4iLCJpbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKSB7XG4gIGNvbnN0IHNoYWRvd0hvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzaGFkb3dIb3N0LmlkID0gJ19fbmV4dC1idWlsZC13YXRjaGVyJ1xuICAvLyBNYWtlIHN1cmUgY29udGFpbmVyIGlzIGZpeGVkIGFuZCBvbiBhIGhpZ2ggekluZGV4IHNvIGl0IHNob3dzXG4gIHNoYWRvd0hvc3Quc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gIHNoYWRvd0hvc3Quc3R5bGUuYm90dG9tID0gJzEwcHgnXG4gIHNoYWRvd0hvc3Quc3R5bGUucmlnaHQgPSAnMjBweCdcbiAgc2hhZG93SG9zdC5zdHlsZS53aWR0aCA9IDBcbiAgc2hhZG93SG9zdC5zdHlsZS5oZWlnaHQgPSAwXG4gIHNoYWRvd0hvc3Quc3R5bGUuekluZGV4ID0gOTk5OTlcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzaGFkb3dIb3N0KVxuXG4gIGxldCBzaGFkb3dSb290XG4gIGxldCBwcmVmaXggPSAnJ1xuXG4gIGlmIChzaGFkb3dIb3N0LmF0dGFjaFNoYWRvdykge1xuICAgIHNoYWRvd1Jvb3QgPSBzaGFkb3dIb3N0LmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGF0dGFjaFNoYWRvdyBpcyB1bmRlZmluZWQgdGhlbiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0XG4gICAgLy8gdGhlIFNoYWRvdyBET00sIHdlIG5lZWQgdG8gcHJlZml4IGFsbCB0aGUgbmFtZXMgc28gdGhlcmVcbiAgICAvLyB3aWxsIGJlIG5vIGNvbmZsaWN0c1xuICAgIHNoYWRvd1Jvb3QgPSBzaGFkb3dIb3N0XG4gICAgcHJlZml4ID0gJ19fbmV4dC1idWlsZC13YXRjaGVyLSdcbiAgfVxuXG4gIC8vIENvbnRhaW5lclxuICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVDb250YWluZXIocHJlZml4KVxuICBzaGFkb3dSb290LmFwcGVuZENoaWxkKGNvbnRhaW5lcilcblxuICAvLyBDU1NcbiAgY29uc3QgY3NzID0gY3JlYXRlQ3NzKHByZWZpeClcbiAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpXG5cbiAgLy8gU3RhdGVcbiAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4gIGxldCBpc0J1aWxkaW5nID0gZmFsc2VcbiAgbGV0IHRpbWVvdXRJZCA9IG51bGxcblxuICAvLyBIYW5kbGUgZXZlbnRzXG4gIGNvbnN0IGV2dFNvdXJjZSA9IGdldEV2ZW50U291cmNlV3JhcHBlcih7IHBhdGg6ICcvX25leHQvd2VicGFjay1obXInIH0pXG4gIGV2dFNvdXJjZS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGVhcnRiZWF0IGV2ZW50XG4gICAgaWYgKGV2ZW50LmRhdGEgPT09ICdcXHVEODNEXFx1REM5MycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBoYW5kbGVNZXNzYWdlKGV2ZW50KVxuICAgIH0gY2F0Y2gge31cbiAgfSlcblxuICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAob2JqLmFjdGlvbikge1xuICAgICAgY2FzZSAnYnVpbGRpbmcnOlxuICAgICAgICB0aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICBpc0J1aWxkaW5nID0gdHJ1ZVxuICAgICAgICB1cGRhdGVDb250YWluZXIoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYnVpbHQnOlxuICAgICAgY2FzZSAnc3luYyc6XG4gICAgICAgIGlzQnVpbGRpbmcgPSBmYWxzZVxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZmFkZSBvdXQgdHJhbnN0aW9uIHRvIGNvbXBsZXRlXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICAgdXBkYXRlQ29udGFpbmVyKClcbiAgICAgICAgfSwgMTAwKVxuICAgICAgICB1cGRhdGVDb250YWluZXIoKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcigpIHtcbiAgICBpZiAoaXNCdWlsZGluZykge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7cHJlZml4fWJ1aWxkaW5nYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7cHJlZml4fWJ1aWxkaW5nYClcbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChgJHtwcmVmaXh9dmlzaWJsZWApXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGAke3ByZWZpeH12aXNpYmxlYClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKHByZWZpeCkge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBjb250YWluZXIuaWQgPSBgJHtwcmVmaXh9Y29udGFpbmVyYFxuICBjb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgaWQ9XCIke3ByZWZpeH1pY29uLXdyYXBwZXJcIj5cbiAgICAgIDxzdmcgdmlld0JveD1cIjAgMCAyMjYgMjAwXCI+XG4gICAgICAgIDxkZWZzPlxuICAgICAgICAgIDxsaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgeDE9XCIxMTQuNzIwNzc1JVwiXG4gICAgICAgICAgICB5MT1cIjE4MS4yODMyNDUlXCJcbiAgICAgICAgICAgIHgyPVwiMzkuNTM5OTMwNiVcIlxuICAgICAgICAgICAgeTI9XCIxMDAlXCJcbiAgICAgICAgICAgIGlkPVwiJHtwcmVmaXh9bGluZWFyLWdyYWRpZW50XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0ZGRkZGRlwiIG9mZnNldD1cIjAlXCIgLz5cbiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjMDAwMDAwXCIgb2Zmc2V0PVwiMTAwJVwiIC8+XG4gICAgICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAgPC9kZWZzPlxuICAgICAgICA8ZyBpZD1cIiR7cHJlZml4fWljb24tZ3JvdXBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cInVybCgjJHtwcmVmaXh9bGluZWFyLWdyYWRpZW50KVwiIHN0cm9rZS13aWR0aD1cIjE4XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMTMsNS4wODIxOTExNyBMNC4yODM5MzgwMSwxOTcuNSBMMjIxLjcxNjA2MiwxOTcuNSBMMTEzLDUuMDgyMTkxMTcgWlwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICBgXG5cbiAgcmV0dXJuIGNvbnRhaW5lclxufVxuXG5mdW5jdGlvbiBjcmVhdGVDc3MocHJlZml4KSB7XG4gIGNvbnN0IGNzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgY3NzLnRleHRDb250ZW50ID0gYFxuICAgICMke3ByZWZpeH1jb250YWluZXIge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgcmlnaHQ6IDMwcHg7XG5cbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgICBjb2xvcjogIzAwMDtcbiAgICAgIGZvbnQ6IGluaXRpYWw7XG4gICAgICBjdXJzb3I6IGluaXRpYWw7XG4gICAgICBsZXR0ZXItc3BhY2luZzogaW5pdGlhbDtcbiAgICAgIHRleHQtc2hhZG93OiBpbml0aWFsO1xuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XG4gICAgICB2aXNpYmlsaXR5OiBpbml0aWFsO1xuXG4gICAgICBwYWRkaW5nOiA4cHggMTBweDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDExcHggNDBweCAwIHJnYmEoMCwgMCwgMCwgMC4yNSksIDAgMnB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xuXG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgb3BhY2l0eTogMDtcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlLCBib3R0b20gMC4xcyBlYXNlO1xuICAgICAgYW5pbWF0aW9uOiAke3ByZWZpeH1mYWRlLWluIDAuMXMgZWFzZS1pbi1vdXQ7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lci4ke3ByZWZpeH12aXNpYmxlIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lci4ke3ByZWZpeH1idWlsZGluZyB7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLXdyYXBwZXIge1xuICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWljb24td3JhcHBlciA+IHN2ZyB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9aWNvbi1ncm91cCB7XG4gICAgICBhbmltYXRpb246ICR7cHJlZml4fXN0cm9rZWRhc2ggMXMgZWFzZS1pbi1vdXQgYm90aCBpbmZpbml0ZTtcbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzICR7cHJlZml4fWZhZGUtaW4ge1xuICAgICAgZnJvbSB7XG4gICAgICAgIGJvdHRvbTogMTBweDtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgYm90dG9tOiAyMHB4O1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgJHtwcmVmaXh9c3Ryb2tlZGFzaCB7XG4gICAgICAwJSB7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDAgMjI2O1xuICAgICAgfVxuICAgICAgODAlLFxuICAgICAgMTAwJSB7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDY1OSAyMjY7XG4gICAgICB9XG4gICAgfVxuICBgXG5cbiAgcmV0dXJuIGNzc1xufVxuIiwiY29uc3QgZXZlbnRDYWxsYmFja3MgPSBbXVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVdyYXBwZXIob3B0aW9ucykge1xuICB2YXIgc291cmNlXG4gIHZhciBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpXG4gIHZhciBsaXN0ZW5lcnMgPSBbXVxuXG4gIGlmICghb3B0aW9ucy50aW1lb3V0KSB7XG4gICAgb3B0aW9ucy50aW1lb3V0ID0gMjAgKiAxMDAwXG4gIH1cblxuICBpbml0KClcbiAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIGlmIChuZXcgRGF0ZSgpIC0gbGFzdEFjdGl2aXR5ID4gb3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBoYW5kbGVEaXNjb25uZWN0KClcbiAgICB9XG4gIH0sIG9wdGlvbnMudGltZW91dCAvIDIpXG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBzb3VyY2UgPSBuZXcgd2luZG93LkV2ZW50U291cmNlKG9wdGlvbnMucGF0aClcbiAgICBzb3VyY2Uub25vcGVuID0gaGFuZGxlT25saW5lXG4gICAgc291cmNlLm9uZXJyb3IgPSBoYW5kbGVEaXNjb25uZWN0XG4gICAgc291cmNlLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9ubGluZSgpIHtcbiAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKCdbSE1SXSBjb25uZWN0ZWQnKVxuICAgIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXShldmVudClcbiAgICB9XG4gICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignYWN0aW9uJykgIT09IC0xKSB7XG4gICAgICBldmVudENhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoZXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcilcbiAgICBzb3VyY2UuY2xvc2UoKVxuICAgIHNldFRpbWVvdXQoaW5pdCwgb3B0aW9ucy50aW1lb3V0KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcilcbiAgICAgIHNvdXJjZS5jbG9zZSgpXG4gICAgfSxcbiAgICBhZGRNZXNzYWdlTGlzdGVuZXI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgbGlzdGVuZXJzLnB1c2goZm4pXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLm9uZGVtYW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogKGNiKSA9PiB7XG4gICAgICAgIGV2ZW50Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgICB9LFxuICAgIH1cbiAgfVxuICByZXR1cm4gRXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpXG59XG4iLCIvKipcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2Jsb2IvN2IxYTMyYmU2ZWM5Zjk5YTZjOWEzYzY2ODEzZjNhYzA5YzQ3MzZiOS9wYWNrYWdlcy9yZWFjdC1kZXYtdXRpbHMvZm9ybWF0V2VicGFja01lc3NhZ2VzLmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIHRvIHJlbW92ZSBjaGFsayBhbmQgQ1JBLXNwZWNpZmljIGxvZ2ljXG5cbmNvbnN0IGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCA9ICdTeW50YXggZXJyb3I6J1xuXG5mdW5jdGlvbiBpc0xpa2VseUFTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBtZXNzYWdlLmluZGV4T2YoZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsKSAhPT0gLTFcbn1cblxuLy8gQ2xlYW5zIHVwIHdlYnBhY2sgZXJyb3IgbWVzc2FnZXMuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgbGV0IGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcblxuICAvLyBTdHJpcCBXZWJwYWNrLWFkZGVkIGhlYWRlcnMgb2ZmIGVycm9ycy93YXJuaW5nc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFzdGVyL2xpYi9Nb2R1bGVFcnJvci5qc1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigobGluZSkgPT4gIS9Nb2R1bGUgW0EteiBdK1xcKGZyb20vLnRlc3QobGluZSkpXG5cbiAgLy8gVHJhbnNmb3JtIHBhcnNpbmcgZXJyb3IgaW50byBzeW50YXggZXJyb3JcbiAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIG91ciBFU0xpbnQgZm9ybWF0dGVyP1xuICBsaW5lcyA9IGxpbmVzLm1hcCgobGluZSkgPT4ge1xuICAgIGNvbnN0IHBhcnNpbmdFcnJvciA9IC9MaW5lIChcXGQrKTooPzooXFxkKyk6KT9cXHMqUGFyc2luZyBlcnJvcjogKC4rKSQvLmV4ZWMoXG4gICAgICBsaW5lXG4gICAgKVxuICAgIGlmICghcGFyc2luZ0Vycm9yKSB7XG4gICAgICByZXR1cm4gbGluZVxuICAgIH1cbiAgICBjb25zdCBbLCBlcnJvckxpbmUsIGVycm9yQ29sdW1uLCBlcnJvck1lc3NhZ2VdID0gcGFyc2luZ0Vycm9yXG4gICAgcmV0dXJuIGAke2ZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbH0gJHtlcnJvck1lc3NhZ2V9ICgke2Vycm9yTGluZX06JHtlcnJvckNvbHVtbn0pYFxuICB9KVxuXG4gIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICAvLyBTbW9vc2ggc3ludGF4IGVycm9ycyAoY29tbW9ubHkgZm91bmQgaW4gQ1NTKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9TeW50YXhFcnJvclxccytcXCgoXFxkKyk6KFxcZCspXFwpXFxzKiguKz8pXFxuL2csXG4gICAgYCR7ZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsfSAkMyAoJDE6JDIpXFxuYFxuICApXG4gIC8vIENsZWFuIHVwIGV4cG9ydCBlcnJvcnNcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICcoLis/KScgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFxuICAgIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMicuYFxuICApXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL14uKmV4cG9ydCAnZGVmYXVsdCcgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMicgZG9lcyBub3QgY29udGFpbiBhIGRlZmF1bHQgZXhwb3J0IChpbXBvcnRlZCBhcyAnJDEnKS5gXG4gIClcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICcoLis/KScgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQzJyAoaW1wb3J0ZWQgYXMgJyQyJykuYFxuICApXG4gIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcblxuICAvLyBSZW1vdmUgbGVhZGluZyBuZXdsaW5lXG4gIGlmIChsaW5lcy5sZW5ndGggPiAyICYmIGxpbmVzWzFdLnRyaW0oKSA9PT0gJycpIHtcbiAgICBsaW5lcy5zcGxpY2UoMSwgMSlcbiAgfVxuICAvLyBDbGVhbiB1cCBmaWxlIG5hbWVcbiAgbGluZXNbMF0gPSBsaW5lc1swXS5yZXBsYWNlKC9eKC4qKSBcXGQrOlxcZCstXFxkKyQvLCAnJDEnKVxuXG4gIC8vIENsZWFucyB1cCB2ZXJib3NlIFwibW9kdWxlIG5vdCBmb3VuZFwiIG1lc3NhZ2VzIGZvciBmaWxlcyBhbmQgcGFja2FnZXMuXG4gIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5pbmRleE9mKCdNb2R1bGUgbm90IGZvdW5kOiAnKSA9PT0gMCkge1xuICAgIGxpbmVzID0gW1xuICAgICAgbGluZXNbMF0sXG4gICAgICBsaW5lc1sxXVxuICAgICAgICAucmVwbGFjZSgnRXJyb3I6ICcsICcnKVxuICAgICAgICAucmVwbGFjZSgnTW9kdWxlIG5vdCBmb3VuZDogQ2Fubm90IGZpbmQgZmlsZTonLCAnQ2Fubm90IGZpbmQgZmlsZTonKSxcbiAgICAgIC4uLmxpbmVzLnNsaWNlKDIpLmZpbHRlcigobGluZSkgPT4gbGluZS5pbmRleE9mKCcgQCAnKSAhPT0gMCksXG4gICAgXVxuICB9XG5cbiAgLy8gQWRkIGhlbHBmdWwgbWVzc2FnZSBmb3IgdXNlcnMgdHJ5aW5nIHRvIHVzZSBTYXNzIGZvciB0aGUgZmlyc3QgdGltZVxuICBpZiAobGluZXNbMV0gJiYgbGluZXNbMV0ubWF0Y2goL0Nhbm5vdCBmaW5kIG1vZHVsZS4rbm9kZS1zYXNzLykpIHtcbiAgICAvLyAuL2ZpbGUubW9kdWxlLnNjc3MgKDw8bG9hZGVyIGluZm8+PikgPT4gLi9maWxlLm1vZHVsZS5zY3NzXG4gICAgbGluZXNbMF0gPSBsaW5lc1swXS5yZXBsYWNlKC8oLispIFxcKC4rPyg/PVxcP1xcPykuKz9cXCkvLCAnJDEnKVxuXG4gICAgbGluZXNbMV0gPVxuICAgICAgXCJUbyB1c2UgTmV4dC5qcycgYnVpbHQtaW4gU2FzcyBzdXBwb3J0LCB5b3UgZmlyc3QgbmVlZCB0byBpbnN0YWxsIGBzYXNzYC5cXG5cIlxuICAgIGxpbmVzWzFdICs9ICdSdW4gYG5wbSBpIHNhc3NgIG9yIGB5YXJuIGFkZCBzYXNzYCBpbnNpZGUgeW91ciB3b3Jrc3BhY2UuXFxuJ1xuICAgIGxpbmVzWzFdICs9ICdcXG5MZWFybiBtb3JlOiBodHRwczovL2Vyci5zaC9uZXh0LmpzL2luc3RhbGwtc2FzcydcbiAgfVxuXG4gIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICAvLyBJbnRlcm5hbCBzdGFja3MgYXJlIGdlbmVyYWxseSB1c2VsZXNzIHNvIHdlIHN0cmlwIHRoZW0uLi4gd2l0aCB0aGVcbiAgLy8gZXhjZXB0aW9uIG9mIHN0YWNrcyBjb250YWluaW5nIGB3ZWJwYWNrOmAgYmVjYXVzZSB0aGV5J3JlIG5vcm1hbGx5XG4gIC8vIGZyb20gdXNlciBjb2RlIGdlbmVyYXRlZCBieSBXZWJwYWNrLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvcHVsbC8xMDUwXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL15cXHMqYXRcXHMoKD8hd2VicGFjazopLikqOlxcZCs6XFxkK1tcXHMpXSooXFxufCQpL2dtLFxuICAgICcnXG4gICkgLy8gYXQgLi4uIC4uLjp4OnlcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxcczxhbm9ueW1vdXM+KFxcbnwkKS9nbSwgJycpIC8vIGF0IDxhbm9ueW1vdXM+XG4gIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcblxuICAvLyBSZW1vdmUgZHVwbGljYXRlZCBuZXdsaW5lc1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcihcbiAgICAobGluZSwgaW5kZXgsIGFycikgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8IGxpbmUudHJpbSgpICE9PSAnJyB8fCBsaW5lLnRyaW0oKSAhPT0gYXJyW2luZGV4IC0gMV0udHJpbSgpXG4gIClcblxuICAvLyBSZWFzc2VtYmxlIHRoZSBtZXNzYWdlXG4gIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICByZXR1cm4gbWVzc2FnZS50cmltKClcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2VicGFja01lc3NhZ2VzKGpzb24pIHtcbiAgY29uc3QgZm9ybWF0dGVkRXJyb3JzID0ganNvbi5lcnJvcnMubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgdHJ1ZSlcbiAgfSlcbiAgY29uc3QgZm9ybWF0dGVkV2FybmluZ3MgPSBqc29uLndhcm5pbmdzLm1hcChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIGZhbHNlKVxuICB9KVxuICBjb25zdCByZXN1bHQgPSB7IGVycm9yczogZm9ybWF0dGVkRXJyb3JzLCB3YXJuaW5nczogZm9ybWF0dGVkV2FybmluZ3MgfVxuICBpZiAocmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgc3ludGF4IGVycm9ycywgc2hvdyBqdXN0IHRoZW0uXG4gICAgcmVzdWx0LmVycm9ycyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGlzTGlrZWx5QVN5bnRheEVycm9yKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRXZWJwYWNrTWVzc2FnZXNcbiIsIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbi8vIFRoaXMgZmlsZSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIENyZWF0ZSBSZWFjdCBBcHAgSE1SIGRldiBjbGllbnQgdGhhdFxuLy8gY2FuIGJlIGZvdW5kIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iL3YzLjQuMS9wYWNrYWdlcy9yZWFjdC1kZXYtdXRpbHMvd2VicGFja0hvdERldkNsaWVudC5qc1xuXG5pbXBvcnQgKiBhcyBEZXZPdmVybGF5IGZyb20gJ0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9jbGllbnQnXG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpJ1xuaW1wb3J0IHsgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyIH0gZnJvbSAnLi9ldmVudHNvdXJjZSdcbmltcG9ydCBmb3JtYXRXZWJwYWNrTWVzc2FnZXMgZnJvbSAnLi9mb3JtYXQtd2VicGFjay1tZXNzYWdlcydcblxuLy8gVGhpcyBhbHRlcm5hdGl2ZSBXZWJwYWNrRGV2U2VydmVyIGNvbWJpbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL2Jsb2Ivd2VicGFjay0xL2NsaWVudC9pbmRleC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9ibG9iL3dlYnBhY2stMS9ob3QvZGV2LXNlcnZlci5qc1xuXG4vLyBJdCBvbmx5IHN1cHBvcnRzIHRoZWlyIHNpbXBsZXN0IGNvbmZpZ3VyYXRpb24gKGhvdCB1cGRhdGVzIG9uIHNhbWUgc2VydmVyKS5cbi8vIEl0IG1ha2VzIHNvbWUgb3BpbmlvbmF0ZWQgY2hvaWNlcyBvbiB0b3AsIGxpa2UgYWRkaW5nIGEgc3ludGF4IGVycm9yIG92ZXJsYXlcbi8vIHRoYXQgbG9va3Mgc2ltaWxhciB0byBvdXIgY29uc29sZSBvdXRwdXQuIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIGJ5OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlXG5cbmxldCBoYWRSdW50aW1lRXJyb3IgPSBmYWxzZVxubGV0IGN1c3RvbUhtckV2ZW50SGFuZGxlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29ubmVjdChvcHRpb25zKSB7XG4gIERldk92ZXJsYXkucmVnaXN0ZXIoKVxuXG4gIGdldEV2ZW50U291cmNlV3JhcHBlcihvcHRpb25zKS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGVhcnRiZWF0IGV2ZW50XG4gICAgaWYgKGV2ZW50LmRhdGEgPT09ICdcXHVEODNEXFx1REM5MycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcHJvY2Vzc01lc3NhZ2UoZXZlbnQpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBITVIgbWVzc2FnZTogJyArIGV2ZW50LmRhdGEgKyAnXFxuJyArIGV4KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZVRvSG1yRXZlbnQoaGFuZGxlcikge1xuICAgICAgY3VzdG9tSG1yRXZlbnRIYW5kbGVyID0gaGFuZGxlclxuICAgIH0sXG4gICAgb25VbnJlY292ZXJhYmxlRXJyb3IoKSB7XG4gICAgICBoYWRSdW50aW1lRXJyb3IgPSB0cnVlXG4gICAgfSxcbiAgfVxufVxuXG4vLyBSZW1lbWJlciBzb21lIHN0YXRlIHJlbGF0ZWQgdG8gaG90IG1vZHVsZSByZXBsYWNlbWVudC5cbnZhciBpc0ZpcnN0Q29tcGlsYXRpb24gPSB0cnVlXG52YXIgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IG51bGxcbnZhciBoYXNDb21waWxlRXJyb3JzID0gZmFsc2VcblxuZnVuY3Rpb24gY2xlYXJPdXRkYXRlZEVycm9ycygpIHtcbiAgLy8gQ2xlYW4gdXAgb3V0ZGF0ZWQgY29tcGlsZSBlcnJvcnMsIGlmIGFueS5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5jbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChoYXNDb21waWxlRXJyb3JzKSB7XG4gICAgICBjb25zb2xlLmNsZWFyKClcbiAgICB9XG4gIH1cbn1cblxuLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cbmZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3MoKSB7XG4gIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKVxuXG4gIGNvbnN0IGlzSG90VXBkYXRlID0gIWlzRmlyc3RDb21waWxhdGlvblxuICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZVxuICBoYXNDb21waWxlRXJyb3JzID0gZmFsc2VcblxuICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgdHJ5QXBwbHlVcGRhdGVzKGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBDb21waWxhdGlvbiB3aXRoIHdhcm5pbmdzIChlLmcuIEVTTGludCkuXG5mdW5jdGlvbiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncykge1xuICBjbGVhck91dGRhdGVkRXJyb3JzKClcblxuICBjb25zdCBpc0hvdFVwZGF0ZSA9ICFpc0ZpcnN0Q29tcGlsYXRpb25cbiAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2VcbiAgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gcHJpbnRXYXJuaW5ncygpIHtcbiAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoe1xuICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgZXJyb3JzOiBbXSxcbiAgICB9KVxuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC53YXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gNSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdUaGVyZSB3ZXJlIG1vcmUgd2FybmluZ3MgaW4gb3RoZXIgZmlsZXMuXFxuJyArXG4gICAgICAgICAgICAgICdZb3UgY2FuIGZpbmQgYSBjb21wbGV0ZSBsb2cgaW4gdGhlIHRlcm1pbmFsLidcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oc3RyaXBBbnNpKGZvcm1hdHRlZC53YXJuaW5nc1tpXSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpbnRXYXJuaW5ncygpXG5cbiAgLy8gQXR0ZW1wdCB0byBhcHBseSBob3QgdXBkYXRlcyBvciByZWxvYWQuXG4gIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgIHRyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcykge1xuICAgICAgLy8gT25seSBkaXNtaXNzIGl0IHdoZW4gd2UncmUgc3VyZSBpdCdzIGEgaG90IHVwZGF0ZS5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxuICAgICAgb25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzKSB7XG4gIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKVxuXG4gIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlXG4gIGhhc0NvbXBpbGVFcnJvcnMgPSB0cnVlXG5cbiAgLy8gXCJNYXNzYWdlXCIgd2VicGFjayBtZXNzYWdlcy5cbiAgdmFyIGZvcm1hdHRlZCA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyh7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgd2FybmluZ3M6IFtdLFxuICB9KVxuXG4gIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIERldk92ZXJsYXkub25CdWlsZEVycm9yKGZvcm1hdHRlZC5lcnJvcnNbMF0pXG5cbiAgLy8gQWxzbyBsb2cgdGhlbSB0byB0aGUgY29uc29sZS5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0dGVkLmVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc29sZS5lcnJvcihzdHJpcEFuc2koZm9ybWF0dGVkLmVycm9yc1tpXSkpXG4gICAgfVxuICB9XG5cbiAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVsb2FkIG5vdy5cbiAgLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKGZvcm1hdHRlZC5lcnJvcnNbMF0pXG4gICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcykge1xuICBEZXZPdmVybGF5Lm9uQnVpbGRPaygpXG4gIGlmIChoYXNVcGRhdGVzKSB7XG4gICAgRGV2T3ZlcmxheS5vblJlZnJlc2goKVxuICB9XG5cbiAgY29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIGRvbmUnKVxufVxuXG4vLyBUaGVyZSBpcyBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGNvZGUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gaGFuZGxlQXZhaWxhYmxlSGFzaChoYXNoKSB7XG4gIC8vIFVwZGF0ZSBsYXN0IGtub3duIGNvbXBpbGF0aW9uIGhhc2guXG4gIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBoYXNoXG59XG5cbi8vIEhhbmRsZSBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShlKSB7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZS5kYXRhKVxuICBzd2l0Y2ggKG9iai5hY3Rpb24pIHtcbiAgICBjYXNlICdidWlsZGluZyc6IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbRmFzdCBSZWZyZXNoXSByZWJ1aWxkaW5nJylcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ2J1aWx0JzpcbiAgICBjYXNlICdzeW5jJzoge1xuICAgICAgaWYgKG9iai5oYXNoKSB7XG4gICAgICAgIGhhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZXJyb3JzLCB3YXJuaW5ncyB9ID0gb2JqXG4gICAgICBjb25zdCBoYXNFcnJvcnMgPSBCb29sZWFuKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKVxuICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3JzKGVycm9ycylcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFzV2FybmluZ3MgPSBCb29sZWFuKHdhcm5pbmdzICYmIHdhcm5pbmdzLmxlbmd0aClcbiAgICAgIGlmIChoYXNXYXJuaW5ncykge1xuICAgICAgICByZXR1cm4gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVTdWNjZXNzKClcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKGN1c3RvbUhtckV2ZW50SGFuZGxlcikge1xuICAgICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIob2JqKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLy8gSXMgdGhlcmUgYSBuZXdlciB2ZXJzaW9uIG9mIHRoaXMgY29kZSBhdmFpbGFibGU/XG5mdW5jdGlvbiBpc1VwZGF0ZUF2YWlsYWJsZSgpIHtcbiAgLyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovXG4gIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4gIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgcmV0dXJuIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggIT09IF9fd2VicGFja19oYXNoX19cbn1cblxuLy8gV2VicGFjayBkaXNhbGxvd3MgdXBkYXRlcyBpbiBvdGhlciBzdGF0ZXMuXG5mdW5jdGlvbiBjYW5BcHBseVVwZGF0ZXMoKSB7XG4gIHJldHVybiBtb2R1bGUuaG90LnN0YXR1cygpID09PSAnaWRsZSdcbn1cbmZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuKSB7XG4gIGlmIChjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgIGZuKClcbiAgfSBlbHNlIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cykge1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihoYW5kbGVyKVxuICAgICAgICBmbigpXG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKVxuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMob25Ib3RVcGRhdGVTdWNjZXNzKSB7XG4gIGlmICghbW9kdWxlLmhvdCkge1xuICAgIC8vIEhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgY29uc29sZS5lcnJvcignSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi4nKVxuICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghaXNVcGRhdGVBdmFpbGFibGUoKSB8fCAhY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgaWYgKGVyciB8fCBoYWRSdW50aW1lRXJyb3IgfHwgIXVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW0Zhc3QgUmVmcmVzaF0gcGVyZm9ybWluZyBmdWxsIHJlbG9hZFxcblxcbicgK1xuICAgICAgICAgICAgXCJGYXN0IFJlZnJlc2ggd2lsbCBwZXJmb3JtIGEgZnVsbCByZWxvYWQgd2hlbiB5b3UgZWRpdCBhIGZpbGUgdGhhdCdzIGltcG9ydGVkIGJ5IG1vZHVsZXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgdHJlZS5cXG5cIiArXG4gICAgICAgICAgICAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIHJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50LlxcbicgK1xuICAgICAgICAgICAgJ0NvbnNpZGVyIG1pZ3JhdGluZyB0aGUgbm9uLVJlYWN0IGNvbXBvbmVudCBleHBvcnQgdG8gYSBzZXBhcmF0ZSBmaWxlIGFuZCBpbXBvcnRpbmcgaXQgaW50byBib3RoIGZpbGVzLlxcblxcbicgK1xuICAgICAgICAgICAgJ0l0IGlzIGFsc28gcG9zc2libGUgeW91IGFyZSB1c2luZyBjbGFzcyBjb21wb25lbnRzIGF0IHRoZSB0b3AtbGV2ZWwgb2YgeW91ciBhcHBsaWNhdGlvbiwgd2hpY2ggZGlzYWJsZXMgRmFzdCBSZWZyZXNoLlxcbicgK1xuICAgICAgICAgICAgJ0Zhc3QgUmVmcmVzaCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZnVuY3Rpb24gY29tcG9uZW50IGluIHlvdXIgUmVhY3QgdHJlZS4nXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW0Zhc3QgUmVmcmVzaF0gcGVyZm9ybWluZyBmdWxsIHJlbG9hZCBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaGFkIGFuIHVucmVjb3ZlcmFibGUgZXJyb3InXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaGFzVXBkYXRlcyA9IEJvb2xlYW4odXBkYXRlZE1vZHVsZXMubGVuZ3RoKVxuICAgIGlmICh0eXBlb2Ygb25Ib3RVcGRhdGVTdWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBNYXliZSB3ZSB3YW50IHRvIGRvIHNvbWV0aGluZy5cbiAgICAgIG9uSG90VXBkYXRlU3VjY2VzcyhoYXNVcGRhdGVzKVxuICAgIH1cblxuICAgIGlmIChpc1VwZGF0ZUF2YWlsYWJsZSgpKSB7XG4gICAgICAvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbiAgICAgIHRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzID8gdW5kZWZpbmVkIDogb25Ib3RVcGRhdGVTdWNjZXNzKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgICAgICBhZnRlckFwcGx5VXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKClcbiAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbiAgbW9kdWxlLmhvdC5jaGVjaygvKiBhdXRvQXBwbHkgKi8gdHJ1ZSkudGhlbihcbiAgICAodXBkYXRlZE1vZHVsZXMpID0+IHtcbiAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhudWxsLCB1cGRhdGVkTW9kdWxlcylcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIG51bGwpXG4gICAgfVxuICApXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gSW1wcm92ZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0V2ZW50U291cmNlL1xuLy8gQXZhaWxhYmxlIHVuZGVyIE1JVCBMaWNlbnNlIChNSVQpXG4vLyBPbmx5IHRyaWVzIHRvIHN1cHBvcnQgSUUxMSBhbmQgbm90aGluZyBiZWxvd1xuaW1wb3J0IGZldGNoIGZyb20gJ25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvdW5mZXRjaCdcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50XG52YXIgUmVzcG9uc2UgPSB3aW5kb3cuUmVzcG9uc2VcbnZhciBUZXh0RGVjb2RlciA9IHdpbmRvdy5UZXh0RGVjb2RlclxudmFyIFRleHRFbmNvZGVyID0gd2luZG93LlRleHRFbmNvZGVyXG52YXIgQWJvcnRDb250cm9sbGVyID0gd2luZG93LkFib3J0Q29udHJvbGxlclxuXG5pZiAoQWJvcnRDb250cm9sbGVyID09IHVuZGVmaW5lZCkge1xuICBBYm9ydENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaWduYWwgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gVGV4dERlY29kZXJQb2x5ZmlsbCgpIHtcbiAgdGhpcy5iaXRzTmVlZGVkID0gMFxuICB0aGlzLmNvZGVQb2ludCA9IDBcbn1cblxuVGV4dERlY29kZXJQb2x5ZmlsbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKG9jdGV0cykge1xuICBmdW5jdGlvbiB2YWxpZChjb2RlUG9pbnQsIHNoaWZ0LCBvY3RldHNDb3VudCkge1xuICAgIGlmIChvY3RldHNDb3VudCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCA+PSAweDAwODAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4MDdmZlxuICAgIH1cbiAgICBpZiAob2N0ZXRzQ291bnQgPT09IDIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjb2RlUG9pbnQgPj0gMHgwODAwID4+IHNoaWZ0ICYmIGNvZGVQb2ludCA8PCBzaGlmdCA8PSAweGQ3ZmYpIHx8XG4gICAgICAgIChjb2RlUG9pbnQgPj0gMHhlMDAwID4+IHNoaWZ0ICYmIGNvZGVQb2ludCA8PCBzaGlmdCA8PSAweGZmZmYpXG4gICAgICApXG4gICAgfVxuICAgIGlmIChvY3RldHNDb3VudCA9PT0gMykge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCA+PSAweDAxMDAwMCA+PiBzaGlmdCAmJiBjb2RlUG9pbnQgPDwgc2hpZnQgPD0gMHgxMGZmZmZcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfVxuICBmdW5jdGlvbiBvY3RldHNDb3VudChiaXRzTmVlZGVkLCBjb2RlUG9pbnQpIHtcbiAgICBpZiAoYml0c05lZWRlZCA9PT0gNiAqIDEpIHtcbiAgICAgIHJldHVybiBjb2RlUG9pbnQgPj4gNiA+IDE1ID8gMyA6IGNvZGVQb2ludCA+IDMxID8gMiA6IDFcbiAgICB9XG4gICAgaWYgKGJpdHNOZWVkZWQgPT09IDYgKiAyKSB7XG4gICAgICByZXR1cm4gY29kZVBvaW50ID4gMTUgPyAzIDogMlxuICAgIH1cbiAgICBpZiAoYml0c05lZWRlZCA9PT0gNiAqIDMpIHtcbiAgICAgIHJldHVybiAzXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpXG4gIH1cbiAgdmFyIFJFUExBQ0VSID0gMHhmZmZkXG4gIHZhciBzdHJpbmcgPSAnJ1xuICB2YXIgYml0c05lZWRlZCA9IHRoaXMuYml0c05lZWRlZFxuICB2YXIgY29kZVBvaW50ID0gdGhpcy5jb2RlUG9pbnRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvY3RldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgb2N0ZXQgPSBvY3RldHNbaV1cbiAgICBpZiAoYml0c05lZWRlZCAhPT0gMCkge1xuICAgICAgaWYgKFxuICAgICAgICBvY3RldCA8IDEyOCB8fFxuICAgICAgICBvY3RldCA+IDE5MSB8fFxuICAgICAgICAhdmFsaWQoXG4gICAgICAgICAgKGNvZGVQb2ludCA8PCA2KSB8IChvY3RldCAmIDYzKSxcbiAgICAgICAgICBiaXRzTmVlZGVkIC0gNixcbiAgICAgICAgICBvY3RldHNDb3VudChiaXRzTmVlZGVkLCBjb2RlUG9pbnQpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBiaXRzTmVlZGVkID0gMFxuICAgICAgICBjb2RlUG9pbnQgPSBSRVBMQUNFUlxuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaXRzTmVlZGVkID09PSAwKSB7XG4gICAgICBpZiAob2N0ZXQgPj0gMCAmJiBvY3RldCA8PSAxMjcpIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDBcbiAgICAgICAgY29kZVBvaW50ID0gb2N0ZXRcbiAgICAgIH0gZWxzZSBpZiAob2N0ZXQgPj0gMTkyICYmIG9jdGV0IDw9IDIyMykge1xuICAgICAgICBiaXRzTmVlZGVkID0gNiAqIDFcbiAgICAgICAgY29kZVBvaW50ID0gb2N0ZXQgJiAzMVxuICAgICAgfSBlbHNlIGlmIChvY3RldCA+PSAyMjQgJiYgb2N0ZXQgPD0gMjM5KSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSA2ICogMlxuICAgICAgICBjb2RlUG9pbnQgPSBvY3RldCAmIDE1XG4gICAgICB9IGVsc2UgaWYgKG9jdGV0ID49IDI0MCAmJiBvY3RldCA8PSAyNDcpIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDYgKiAzXG4gICAgICAgIGNvZGVQb2ludCA9IG9jdGV0ICYgN1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDBcbiAgICAgICAgY29kZVBvaW50ID0gUkVQTEFDRVJcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgYml0c05lZWRlZCAhPT0gMCAmJlxuICAgICAgICAhdmFsaWQoY29kZVBvaW50LCBiaXRzTmVlZGVkLCBvY3RldHNDb3VudChiaXRzTmVlZGVkLCBjb2RlUG9pbnQpKVxuICAgICAgKSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSAwXG4gICAgICAgIGNvZGVQb2ludCA9IFJFUExBQ0VSXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpdHNOZWVkZWQgLT0gNlxuICAgICAgY29kZVBvaW50ID0gKGNvZGVQb2ludCA8PCA2KSB8IChvY3RldCAmIDYzKVxuICAgIH1cbiAgICBpZiAoYml0c05lZWRlZCA9PT0gMCkge1xuICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKChjb2RlUG9pbnQgLSAweGZmZmYgLSAxKSA+PiAxMCkpXG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgIDB4ZGMwMCArICgoY29kZVBvaW50IC0gMHhmZmZmIC0gMSkgJiAweDNmZilcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLmJpdHNOZWVkZWQgPSBiaXRzTmVlZGVkXG4gIHRoaXMuY29kZVBvaW50ID0gY29kZVBvaW50XG4gIHJldHVybiBzdHJpbmdcbn1cblxuLy8gRmlyZWZveCA8IDM4IHRocm93cyBhbiBlcnJvciB3aXRoIHN0cmVhbSBvcHRpb25cbnZhciBzdXBwb3J0c1N0cmVhbU9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKFxuICAgICAgbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgndGVzdCcpLCB7XG4gICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgIH0pID09PSAndGVzdCdcbiAgICApXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coZXJyb3IpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIElFLCBFZGdlXG5pZiAoXG4gIFRleHREZWNvZGVyID09IHVuZGVmaW5lZCB8fFxuICBUZXh0RW5jb2RlciA9PSB1bmRlZmluZWQgfHxcbiAgIXN1cHBvcnRzU3RyZWFtT3B0aW9uKClcbikge1xuICBUZXh0RGVjb2RlciA9IFRleHREZWNvZGVyUG9seWZpbGxcbn1cblxudmFyIGsgPSBmdW5jdGlvbiAoKSB7fVxuXG5mdW5jdGlvbiBYSFJXcmFwcGVyKHhocikge1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gIHRoaXMucmVzcG9uc2VUeXBlID0gJydcbiAgdGhpcy5yZWFkeVN0YXRlID0gMFxuICB0aGlzLnN0YXR1cyA9IDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgdGhpcy5yZXNwb25zZVRleHQgPSAnJ1xuICB0aGlzLm9ucHJvZ3Jlc3MgPSBrXG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0ga1xuICB0aGlzLl9jb250ZW50VHlwZSA9ICcnXG4gIHRoaXMuX3hociA9IHhoclxuICB0aGlzLl9zZW5kVGltZW91dCA9IDBcbiAgdGhpcy5fYWJvcnQgPSBrXG59XG5cblhIUldyYXBwZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgdGhpcy5fYWJvcnQodHJ1ZSlcblxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIHhociA9IHRoaXMuX3hoclxuICB2YXIgc3RhdGUgPSAxXG4gIHZhciB0aW1lb3V0ID0gMFxuXG4gIHRoaXMuX2Fib3J0ID0gZnVuY3Rpb24gKHNpbGVudCkge1xuICAgIGlmICh0aGF0Ll9zZW5kVGltZW91dCAhPT0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuX3NlbmRUaW1lb3V0KVxuICAgICAgdGhhdC5fc2VuZFRpbWVvdXQgPSAwXG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gMSB8fCBzdGF0ZSA9PT0gMiB8fCBzdGF0ZSA9PT0gMykge1xuICAgICAgc3RhdGUgPSA0XG4gICAgICB4aHIub25sb2FkID0ga1xuICAgICAgeGhyLm9uZXJyb3IgPSBrXG4gICAgICB4aHIub25hYm9ydCA9IGtcbiAgICAgIHhoci5vbnByb2dyZXNzID0ga1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGtcbiAgICAgIC8vIElFIDggLSA5OiBYRG9tYWluUmVxdWVzdCNhYm9ydCgpIGRvZXMgbm90IGZpcmUgYW55IGV2ZW50XG4gICAgICAvLyBPcGVyYSA8IDEwOiBYTUxIdHRwUmVxdWVzdCNhYm9ydCgpIGRvZXMgbm90IGZpcmUgYW55IGV2ZW50XG4gICAgICB4aHIuYWJvcnQoKVxuICAgICAgaWYgKHRpbWVvdXQgIT09IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgIHRpbWVvdXQgPSAwXG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgPSA0XG4gICAgICAgIHRoYXQub25yZWFkeXN0YXRlY2hhbmdlKClcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUgPSAwXG4gIH1cblxuICB2YXIgb25TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgIC8vIHN0YXRlID0gMjtcbiAgICAgIHZhciBzdGF0dXMgPSAwXG4gICAgICB2YXIgc3RhdHVzVGV4dCA9ICcnXG4gICAgICB2YXIgY29udGVudFR5cGUgPSB1bmRlZmluZWRcbiAgICAgIGlmICghKCdjb250ZW50VHlwZScgaW4geGhyKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXNcbiAgICAgICAgICBzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHRcbiAgICAgICAgICBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJylcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBJRSA8IDEwIHRocm93cyBleGNlcHRpb24gZm9yIGB4aHIuc3RhdHVzYCB3aGVuIHhoci5yZWFkeVN0YXRlID09PSAyIHx8IHhoci5yZWFkeVN0YXRlID09PSAzXG4gICAgICAgICAgLy8gT3BlcmEgPCAxMSB0aHJvd3MgZXhjZXB0aW9uIGZvciBgeGhyLnN0YXR1c2Agd2hlbiB4aHIucmVhZHlTdGF0ZSA9PT0gMlxuICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTEyMVxuICAgICAgICAgIHN0YXR1cyA9IDBcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gJydcbiAgICAgICAgICBjb250ZW50VHlwZSA9IHVuZGVmaW5lZFxuICAgICAgICAgIC8vIEZpcmVmb3ggPCAxNCwgQ2hyb21lID8sIFNhZmFyaSA/XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5NjU4XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTc3ODU0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJ1xuICAgICAgICBjb250ZW50VHlwZSA9IHhoci5jb250ZW50VHlwZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXR1cyAhPT0gMCkge1xuICAgICAgICBzdGF0ZSA9IDJcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID0gMlxuICAgICAgICB0aGF0LnN0YXR1cyA9IHN0YXR1c1xuICAgICAgICB0aGF0LnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0XG4gICAgICAgIHRoYXQuX2NvbnRlbnRUeXBlID0gY29udGVudFR5cGVcbiAgICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgb25Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblN0YXJ0KClcbiAgICBpZiAoc3RhdGUgPT09IDIgfHwgc3RhdGUgPT09IDMpIHtcbiAgICAgIHN0YXRlID0gM1xuICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9ICcnXG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUZXh0XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJRSA4IC0gOSB3aXRoIFhNTEh0dHBSZXF1ZXN0XG4gICAgICB9XG4gICAgICB0aGF0LnJlYWR5U3RhdGUgPSAzXG4gICAgICB0aGF0LnJlc3BvbnNlVGV4dCA9IHJlc3BvbnNlVGV4dFxuICAgICAgdGhhdC5vbnByb2dyZXNzKClcbiAgICB9XG4gIH1cbiAgdmFyIG9uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZpcmVmb3ggNTIgZmlyZXMgXCJyZWFkeXN0YXRlY2hhbmdlXCIgKHhoci5yZWFkeVN0YXRlID09PSA0KSB3aXRob3V0IGZpbmFsIFwicmVhZHlzdGF0ZWNoYW5nZVwiICh4aHIucmVhZHlTdGF0ZSA9PT0gMylcbiAgICAvLyBJRSA4IGZpcmVzIFwib25sb2FkXCIgd2l0aG91dCBcIm9ucHJvZ3Jlc3NcIlxuICAgIG9uUHJvZ3Jlc3MoKVxuICAgIGlmIChzdGF0ZSA9PT0gMSB8fCBzdGF0ZSA9PT0gMiB8fCBzdGF0ZSA9PT0gMykge1xuICAgICAgc3RhdGUgPSA0XG4gICAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgIH1cbiAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDRcbiAgICAgIHRoYXQub25yZWFkeXN0YXRlY2hhbmdlKClcbiAgICB9XG4gIH1cbiAgdmFyIG9uUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoeGhyICE9IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT3BlcmEgMTJcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBvbkZpbmlzaCgpXG4gICAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSAzKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3MoKVxuICAgICAgfSBlbHNlIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICBvblN0YXJ0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvblRpbWVvdXQoKVxuICAgIH0sIDUwMClcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgIG9uUHJvZ3Jlc3MoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFhEb21haW5SZXF1ZXN0I2Fib3J0IHJlbW92ZXMgb25wcm9ncmVzcywgb25lcnJvciwgb25sb2FkXG4gIHhoci5vbmxvYWQgPSBvbkZpbmlzaFxuICB4aHIub25lcnJvciA9IG9uRmluaXNoXG4gIC8vIGltcHJvcGVyIGZpeCB0byBtYXRjaCBGaXJlZm94IGJlaGF2aW91ciwgYnV0IGl0IGlzIGJldHRlciB0aGFuIGp1c3QgaWdub3JlIGFib3J0XG4gIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Njg1OTZcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODgwMjAwXG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTM1NzBcbiAgLy8gSUUgOCBmaXJlcyBcIm9ubG9hZFwiIHdpdGhvdXQgXCJvbnByb2dyZXNzXG4gIHhoci5vbmFib3J0ID0gb25GaW5pc2hcblxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzY3MjNcbiAgaWYgKFxuICAgICEoJ3NlbmRBc0JpbmFyeScgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSAmJlxuICAgICEoJ21vekFub24nIGluIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSlcbiAgKSB7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBvblByb2dyZXNzXG4gIH1cblxuICAvLyBJRSA4IC0gOSAoWE1MSFRUUFJlcXVlc3QpXG4gIC8vIE9wZXJhIDwgMTJcbiAgLy8gRmlyZWZveCA8IDMuNVxuICAvLyBGaXJlZm94IDMuNSAtIDMuNiAtID8gPCA5LjBcbiAgLy8gb25wcm9ncmVzcyBpcyBub3QgZmlyZWQgc29tZXRpbWVzIG9yIGRlbGF5ZWRcbiAgLy8gc2VlIGFsc28gIzY0XG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvblJlYWR5U3RhdGVDaGFuZ2VcblxuICBpZiAoJ2NvbnRlbnRUeXBlJyBpbiB4aHIpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICdwYWRkaW5nPXRydWUnXG4gIH1cbiAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpXG5cbiAgaWYgKCdyZWFkeVN0YXRlJyBpbiB4aHIpIHtcbiAgICAvLyB3b3JrYXJvdW5kIGZvciBPcGVyYSAxMiBpc3N1ZSB3aXRoIFwicHJvZ3Jlc3NcIiBldmVudHNcbiAgICAvLyAjOTFcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBvblRpbWVvdXQoKVxuICAgIH0sIDApXG4gIH1cbn1cblhIUldyYXBwZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hYm9ydChmYWxzZSlcbn1cblhIUldyYXBwZXIucHJvdG90eXBlLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbnRlbnRUeXBlXG59XG5YSFJXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB4aHIgPSB0aGlzLl94aHJcbiAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiB4aHIpIHtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgfVxufVxuWEhSV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5feGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyAhPSB1bmRlZmluZWRcbiAgICA/IHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgIDogJydcbn1cblhIUldyYXBwZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGxvYWRpbmcgaW5kaWNhdG9yIGluIFNhZmFyaSA8ID8gKDYpLCBDaHJvbWUgPCAxNCwgRmlyZWZveFxuICBpZiAoXG4gICAgISgnb250aW1lb3V0JyBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpICYmXG4gICAgZG9jdW1lbnQgIT0gdW5kZWZpbmVkICYmXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPSB1bmRlZmluZWQgJiZcbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnXG4gICkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHRoYXQuX3NlbmRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Ll9zZW5kVGltZW91dCA9IDBcbiAgICAgIHRoYXQuc2VuZCgpXG4gICAgfSwgNClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciB4aHIgPSB0aGlzLl94aHJcbiAgLy8gd2l0aENyZWRlbnRpYWxzIHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJvcGVuXCIgZm9yIFNhZmFyaSBhbmQgQ2hyb21lICg8IDE5ID8pXG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFsc1xuICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGVcbiAgdHJ5IHtcbiAgICAvLyB4aHIuc2VuZCgpOyB0aHJvd3MgXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiIGluIEZpcmVmb3ggMy4wXG4gICAgeGhyLnNlbmQodW5kZWZpbmVkKVxuICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAvLyBTYWZhcmkgNS4xLjcsIE9wZXJhIDEyXG4gICAgdGhyb3cgZXJyb3IxXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9Mb3dlckNhc2UobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMuY2hhckNvZGVBdCgwKSArIDB4MjApXG4gIH0pXG59XG5cbmZ1bmN0aW9uIEhlYWRlcnNQb2x5ZmlsbChhbGwpIHtcbiAgLy8gR2V0IGhlYWRlcnM6IGltcGxlbWVudGVkIGFjY29yZGluZyB0byBtb3ppbGxhJ3MgZXhhbXBsZSBjb2RlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvZ2V0QWxsUmVzcG9uc2VIZWFkZXJzI0V4YW1wbGVcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgdmFyIGFycmF5ID0gYWxsLnNwbGl0KCdcXHJcXG4nKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGxpbmUgPSBhcnJheVtpXVxuICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzogJylcbiAgICB2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KClcbiAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6ICcpXG4gICAgbWFwW3RvTG93ZXJDYXNlKG5hbWUpXSA9IHZhbHVlXG4gIH1cbiAgdGhpcy5fbWFwID0gbWFwXG59XG5IZWFkZXJzUG9seWZpbGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9tYXBbdG9Mb3dlckNhc2UobmFtZSldXG59XG5cbmZ1bmN0aW9uIFhIUlRyYW5zcG9ydCgpIHt9XG5cblhIUlRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChcbiAgeGhyLFxuICBvblN0YXJ0Q2FsbGJhY2ssXG4gIG9uUHJvZ3Jlc3NDYWxsYmFjayxcbiAgb25GaW5pc2hDYWxsYmFjayxcbiAgdXJsLFxuICB3aXRoQ3JlZGVudGlhbHMsXG4gIGhlYWRlcnNcbikge1xuICB4aHIub3BlbignR0VUJywgdXJsKVxuICB2YXIgb2Zmc2V0ID0gMFxuICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dFxuICAgIHZhciBjaHVuayA9IHJlc3BvbnNlVGV4dC5zbGljZShvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aFxuICAgIG9uUHJvZ3Jlc3NDYWxsYmFjayhjaHVuaylcbiAgfVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXNcbiAgICAgIHZhciBzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHRcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJylcbiAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICBvblN0YXJ0Q2FsbGJhY2soXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgIG5ldyBIZWFkZXJzUG9seWZpbGwoaGVhZGVycyksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBlbHNlIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgb25GaW5pc2hDYWxsYmFjaygpXG4gICAgfVxuICB9XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHNcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0J1xuICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIG5hbWUpKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH1cbiAgfVxuICB4aHIuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIEhlYWRlcnNXcmFwcGVyKGhlYWRlcnMpIHtcbiAgdGhpcy5faGVhZGVycyA9IGhlYWRlcnNcbn1cbkhlYWRlcnNXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5faGVhZGVycy5nZXQobmFtZSlcbn1cblxuZnVuY3Rpb24gRmV0Y2hUcmFuc3BvcnQoKSB7fVxuXG5GZXRjaFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChcbiAgeGhyLFxuICBvblN0YXJ0Q2FsbGJhY2ssXG4gIG9uUHJvZ3Jlc3NDYWxsYmFjayxcbiAgb25GaW5pc2hDYWxsYmFjayxcbiAgdXJsLFxuICB3aXRoQ3JlZGVudGlhbHMsXG4gIGhlYWRlcnNcbikge1xuICB2YXIgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICB2YXIgc2lnbmFsID0gY29udHJvbGxlci5zaWduYWwgLy8gc2VlICMxMjBcbiAgdmFyIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgZmV0Y2godXJsLCB7XG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWw6IHNpZ25hbCxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG4gICAgICBvblN0YXJ0Q2FsbGJhY2soXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLFxuICAgICAgICBuZXcgSGVhZGVyc1dyYXBwZXIocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKClcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlYWROZXh0Q2h1bmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVhZGVyXG4gICAgICAgICAgICAucmVhZCgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGJ5dGVzIGluIHRleHREZWNvZGVyIGFyZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gdGV4dERlY29kZXIuZGVjb2RlKHJlc3VsdC52YWx1ZSwgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzQ2FsbGJhY2soY2h1bmspXG4gICAgICAgICAgICAgICAgcmVhZE5leHRDaHVuaygpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmVhZE5leHRDaHVuaygpXG4gICAgICB9KVxuICAgIH0pXG4gICAgLnRoZW4oXG4gICAgICBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIG9uRmluaXNoQ2FsbGJhY2soKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG9uRmluaXNoQ2FsbGJhY2soKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgICB9XG4gICAgKVxufVxuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKGUpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZVxuICB9LCAwKVxufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudC50YXJnZXQgPSB0aGlzXG4gIHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdXG4gIGlmICh0eXBlTGlzdGVuZXJzICE9IHVuZGVmaW5lZCkge1xuICAgIHZhciBsZW5ndGggPSB0eXBlTGlzdGVuZXJzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IHR5cGVMaXN0ZW5lcnNbaV1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudChldmVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93RXJyb3IoZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHR5cGUgPSBTdHJpbmcodHlwZSlcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1xuICB2YXIgdHlwZUxpc3RlbmVycyA9IGxpc3RlbmVyc1t0eXBlXVxuICBpZiAodHlwZUxpc3RlbmVycyA9PSB1bmRlZmluZWQpIHtcbiAgICB0eXBlTGlzdGVuZXJzID0gW11cbiAgICBsaXN0ZW5lcnNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzXG4gIH1cbiAgdmFyIGZvdW5kID0gZmFsc2VcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICBmb3VuZCA9IHRydWVcbiAgICB9XG4gIH1cbiAgaWYgKCFmb3VuZCkge1xuICAgIHR5cGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgfVxufVxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgdHlwZSA9IFN0cmluZyh0eXBlKVxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzXG4gIHZhciB0eXBlTGlzdGVuZXJzID0gbGlzdGVuZXJzW3R5cGVdXG4gIGlmICh0eXBlTGlzdGVuZXJzICE9IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWx0ZXJlZCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZUxpc3RlbmVyc1tpXSAhPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgZmlsdGVyZWQucHVzaCh0eXBlTGlzdGVuZXJzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdXG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGZpbHRlcmVkXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEV2ZW50KHR5cGUpIHtcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBNZXNzYWdlRXZlbnQodHlwZSwgb3B0aW9ucykge1xuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpXG4gIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YVxuICB0aGlzLmxhc3RFdmVudElkID0gb3B0aW9ucy5sYXN0RXZlbnRJZFxufVxuXG5NZXNzYWdlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpXG5cbmZ1bmN0aW9uIENvbm5lY3Rpb25FdmVudCh0eXBlLCBvcHRpb25zKSB7XG4gIEV2ZW50LmNhbGwodGhpcywgdHlwZSlcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1c1xuICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHRcbiAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzXG59XG5cbkNvbm5lY3Rpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSlcblxudmFyIFdBSVRJTkcgPSAtMVxudmFyIENPTk5FQ1RJTkcgPSAwXG52YXIgT1BFTiA9IDFcbnZhciBDTE9TRUQgPSAyXG5cbnZhciBBRlRFUl9DUiA9IC0xXG52YXIgRklFTERfU1RBUlQgPSAwXG52YXIgRklFTEQgPSAxXG52YXIgVkFMVUVfU1RBUlQgPSAyXG52YXIgVkFMVUUgPSAzXG5cbnZhciBjb250ZW50VHlwZVJlZ0V4cCA9IC9edGV4dFxcL2V2ZW50XFwtc3RyZWFtOz8oXFxzKmNoYXJzZXRcXD11dGZcXC04KT8kL2lcblxudmFyIE1JTklNVU1fRFVSQVRJT04gPSAxMDAwXG52YXIgTUFYSU1VTV9EVVJBVElPTiA9IDE4MDAwMDAwXG5cbnZhciBwYXJzZUR1cmF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBkZWYpIHtcbiAgdmFyIG4gPSBwYXJzZUludCh2YWx1ZSwgMTApXG4gIGlmIChuICE9PSBuKSB7XG4gICAgbiA9IGRlZlxuICB9XG4gIHJldHVybiBjbGFtcER1cmF0aW9uKG4pXG59XG52YXIgY2xhbXBEdXJhdGlvbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBNSU5JTVVNX0RVUkFUSU9OKSwgTUFYSU1VTV9EVVJBVElPTilcbn1cblxudmFyIGZpcmUgPSBmdW5jdGlvbiAodGhhdCwgZiwgZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGYuY2FsbCh0aGF0LCBldmVudClcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvd0Vycm9yKGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VQb2x5ZmlsbCh1cmwsIG9wdGlvbnMpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKVxuXG4gIHRoaXMub25vcGVuID0gdW5kZWZpbmVkXG4gIHRoaXMub25tZXNzYWdlID0gdW5kZWZpbmVkXG4gIHRoaXMub25lcnJvciA9IHVuZGVmaW5lZFxuXG4gIHRoaXMudXJsID0gdW5kZWZpbmVkXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHVuZGVmaW5lZFxuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHVuZGVmaW5lZFxuXG4gIHRoaXMuX2Nsb3NlID0gdW5kZWZpbmVkXG5cbiAgc3RhcnQodGhpcywgdXJsLCBvcHRpb25zKVxufVxuXG52YXIgaXNGZXRjaFN1cHBvcnRlZCA9XG4gIGZldGNoICE9IHVuZGVmaW5lZCAmJiBSZXNwb25zZSAhPSB1bmRlZmluZWQgJiYgJ2JvZHknIGluIFJlc3BvbnNlLnByb3RvdHlwZVxuXG5mdW5jdGlvbiBzdGFydChlcywgdXJsLCBvcHRpb25zKSB7XG4gIHVybCA9IFN0cmluZyh1cmwpXG4gIHZhciB3aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBCb29sZWFuKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKVxuXG4gIHZhciBpbml0aWFsUmV0cnkgPSBjbGFtcER1cmF0aW9uKDEwMDApXG4gIHZhciBoZWFydGJlYXRUaW1lb3V0ID1cbiAgICBvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlYXJ0YmVhdFRpbWVvdXQgIT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcnNlRHVyYXRpb24ob3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0LCA0NTAwMClcbiAgICAgIDogY2xhbXBEdXJhdGlvbig0NTAwMClcblxuICB2YXIgbGFzdEV2ZW50SWQgPSAnJ1xuICB2YXIgcmV0cnkgPSBpbml0aWFsUmV0cnlcbiAgdmFyIHdhc0FjdGl2aXR5ID0gZmFsc2VcbiAgdmFyIGhlYWRlcnMgPVxuICAgIG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVhZGVycyAhPSB1bmRlZmluZWRcbiAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zLmhlYWRlcnMpKVxuICAgICAgOiB1bmRlZmluZWRcbiAgdmFyIEN1cnJlbnRUcmFuc3BvcnQgPVxuICAgIG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuVHJhbnNwb3J0ICE9IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLlRyYW5zcG9ydFxuICAgICAgOiBYTUxIdHRwUmVxdWVzdFxuICB2YXIgeGhyID1cbiAgICBpc0ZldGNoU3VwcG9ydGVkICYmXG4gICAgIShvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLlRyYW5zcG9ydCAhPSB1bmRlZmluZWQpXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBuZXcgWEhSV3JhcHBlcihuZXcgQ3VycmVudFRyYW5zcG9ydCgpKVxuICB2YXIgdHJhbnNwb3J0ID0geGhyID09IHVuZGVmaW5lZCA/IG5ldyBGZXRjaFRyYW5zcG9ydCgpIDogbmV3IFhIUlRyYW5zcG9ydCgpXG4gIHZhciBjYW5jZWxGdW5jdGlvbiA9IHVuZGVmaW5lZFxuICB2YXIgdGltZW91dCA9IDBcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IFdBSVRJTkdcbiAgdmFyIGRhdGFCdWZmZXIgPSAnJ1xuICB2YXIgbGFzdEV2ZW50SWRCdWZmZXIgPSAnJ1xuICB2YXIgZXZlbnRUeXBlQnVmZmVyID0gJydcblxuICB2YXIgdGV4dEJ1ZmZlciA9ICcnXG4gIHZhciBzdGF0ZSA9IEZJRUxEX1NUQVJUXG4gIHZhciBmaWVsZFN0YXJ0ID0gMFxuICB2YXIgdmFsdWVTdGFydCA9IDBcblxuICB2YXIgb25TdGFydCA9IGZ1bmN0aW9uIChzdGF0dXMsIHN0YXR1c1RleHQsIGNvbnRlbnRUeXBlLCBoZWFkZXJzLCBjYW5jZWwpIHtcbiAgICBpZiAoY3VycmVudFN0YXRlID09PSBDT05ORUNUSU5HKSB7XG4gICAgICBjYW5jZWxGdW5jdGlvbiA9IGNhbmNlbFxuICAgICAgaWYgKFxuICAgICAgICBzdGF0dXMgPT09IDIwMCAmJlxuICAgICAgICBjb250ZW50VHlwZSAhPSB1bmRlZmluZWQgJiZcbiAgICAgICAgY29udGVudFR5cGVSZWdFeHAudGVzdChjb250ZW50VHlwZSlcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBPUEVOXG4gICAgICAgIHdhc0FjdGl2aXR5ID0gdHJ1ZVxuICAgICAgICByZXRyeSA9IGluaXRpYWxSZXRyeVxuICAgICAgICBlcy5yZWFkeVN0YXRlID0gT1BFTlxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ29ubmVjdGlvbkV2ZW50KCdvcGVuJywge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfSlcbiAgICAgICAgZXMuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgICAgZmlyZShlcywgZXMub25vcGVuLCBldmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJydcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgaWYgKHN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgIFwiRXZlbnRTb3VyY2UncyByZXNwb25zZSBoYXMgYSBzdGF0dXMgXCIgK1xuICAgICAgICAgICAgc3RhdHVzICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBzdGF0dXNUZXh0ICtcbiAgICAgICAgICAgICcgdGhhdCBpcyBub3QgMjAwLiBBYm9ydGluZyB0aGUgY29ubmVjdGlvbi4nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICBcIkV2ZW50U291cmNlJ3MgcmVzcG9uc2UgaGFzIGEgQ29udGVudC1UeXBlIHNwZWNpZnlpbmcgYW4gdW5zdXBwb3J0ZWQgdHlwZTogXCIgK1xuICAgICAgICAgICAgKGNvbnRlbnRUeXBlID09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/ICctJ1xuICAgICAgICAgICAgICA6IGNvbnRlbnRUeXBlLnJlcGxhY2UoL1xccysvZywgJyAnKSkgK1xuICAgICAgICAgICAgJy4gQWJvcnRpbmcgdGhlIGNvbm5lY3Rpb24uJ1xuICAgICAgICB9XG4gICAgICAgIHRocm93RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKVxuICAgICAgICBjbG9zZSgpXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDb25uZWN0aW9uRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfSlcbiAgICAgICAgZXMuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgICAgZmlyZShlcywgZXMub25lcnJvciwgZXZlbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAodGV4dENodW5rKSB7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gT1BFTikge1xuICAgICAgdmFyIG4gPSAtMVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Q2h1bmsubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSB0ZXh0Q2h1bmsuY2hhckNvZGVBdChpKVxuICAgICAgICBpZiAoYyA9PT0gJ1xcbicuY2hhckNvZGVBdCgwKSB8fCBjID09PSAnXFxyJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgbiA9IGlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNodW5rID0gKG4gIT09IC0xID8gdGV4dEJ1ZmZlciA6ICcnKSArIHRleHRDaHVuay5zbGljZSgwLCBuICsgMSlcbiAgICAgIHRleHRCdWZmZXIgPSAobiA9PT0gLTEgPyB0ZXh0QnVmZmVyIDogJycpICsgdGV4dENodW5rLnNsaWNlKG4gKyAxKVxuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICB3YXNBY3Rpdml0eSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHBvc2l0aW9uID0gMDsgcG9zaXRpb24gPCBjaHVuay5sZW5ndGg7IHBvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaHVuay5jaGFyQ29kZUF0KHBvc2l0aW9uKVxuICAgICAgICBpZiAoc3RhdGUgPT09IEFGVEVSX0NSICYmIGMgPT09ICdcXG4nLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBzdGF0ZSA9IEZJRUxEX1NUQVJUXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBBRlRFUl9DUikge1xuICAgICAgICAgICAgc3RhdGUgPSBGSUVMRF9TVEFSVFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJ1xccicuY2hhckNvZGVBdCgwKSB8fCBjID09PSAnXFxuJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IEZJRUxEX1NUQVJUKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gRklFTEQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ID0gcG9zaXRpb24gKyAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpZWxkID0gY2h1bmsuc2xpY2UoZmllbGRTdGFydCwgdmFsdWVTdGFydCAtIDEpXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNodW5rLnNsaWNlKFxuICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgK1xuICAgICAgICAgICAgICAgICAgKHZhbHVlU3RhcnQgPCBwb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgY2h1bmsuY2hhckNvZGVBdCh2YWx1ZVN0YXJ0KSA9PT0gJyAnLmNoYXJDb2RlQXQoMClcbiAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBpZiAoZmllbGQgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIGRhdGFCdWZmZXIgKz0gJ1xcbidcbiAgICAgICAgICAgICAgICBkYXRhQnVmZmVyICs9IHZhbHVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdpZCcpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZEJ1ZmZlciA9IHZhbHVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdldmVudCcpIHtcbiAgICAgICAgICAgICAgICBldmVudFR5cGVCdWZmZXIgPSB2YWx1ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAncmV0cnknKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFJldHJ5ID0gcGFyc2VEdXJhdGlvbih2YWx1ZSwgaW5pdGlhbFJldHJ5KVxuICAgICAgICAgICAgICAgIHJldHJ5ID0gaW5pdGlhbFJldHJ5XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdoZWFydGJlYXRUaW1lb3V0Jykge1xuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQgPSBwYXJzZUR1cmF0aW9uKHZhbHVlLCBoZWFydGJlYXRUaW1lb3V0KVxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb25UaW1lb3V0KClcbiAgICAgICAgICAgICAgICAgIH0sIGhlYXJ0YmVhdFRpbWVvdXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEZJRUxEX1NUQVJUKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhQnVmZmVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGxhc3RFdmVudElkID0gbGFzdEV2ZW50SWRCdWZmZXJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlQnVmZmVyID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlQnVmZmVyID0gJ21lc3NhZ2UnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoZXZlbnRUeXBlQnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhQnVmZmVyLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQ6IGxhc3RFdmVudElkQnVmZmVyLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgZXMuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlQnVmZmVyID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgICAgICAgIGZpcmUoZXMsIGVzLm9ubWVzc2FnZSwgZXZlbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFCdWZmZXIgPSAnJ1xuICAgICAgICAgICAgICBldmVudFR5cGVCdWZmZXIgPSAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBjID09PSAnXFxyJy5jaGFyQ29kZUF0KDApID8gQUZURVJfQ1IgOiBGSUVMRF9TVEFSVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEZJRUxEX1NUQVJUKSB7XG4gICAgICAgICAgICAgIGZpZWxkU3RhcnQgPSBwb3NpdGlvblxuICAgICAgICAgICAgICBzdGF0ZSA9IEZJRUxEXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEZJRUxEKSB7XG4gICAgICAgICAgICAgIGlmIChjID09PSAnOicuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSBwb3NpdGlvbiArIDFcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFZBTFVFX1NUQVJUXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFZBTFVFX1NUQVJUKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gVkFMVUVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gT1BFTiB8fCBjdXJyZW50U3RhdGUgPT09IENPTk5FQ1RJTkcpIHtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IFdBSVRJTkdcbiAgICAgIGlmICh0aW1lb3V0ICE9PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICB0aW1lb3V0ID0gMFxuICAgICAgfVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvblRpbWVvdXQoKVxuICAgICAgfSwgcmV0cnkpXG4gICAgICByZXRyeSA9IGNsYW1wRHVyYXRpb24oTWF0aC5taW4oaW5pdGlhbFJldHJ5ICogMTYsIHJldHJ5ICogMikpXG5cbiAgICAgIGVzLnJlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Vycm9yJylcbiAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICBmaXJlKGVzLCBlcy5vbmVycm9yLCBldmVudClcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudFN0YXRlID0gQ0xPU0VEXG4gICAgaWYgKGNhbmNlbEZ1bmN0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsRnVuY3Rpb24oKVxuICAgICAgY2FuY2VsRnVuY3Rpb24gPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRpbWVvdXQgIT09IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgdGltZW91dCA9IDBcbiAgICB9XG4gICAgZXMucmVhZHlTdGF0ZSA9IENMT1NFRFxuICB9XG5cbiAgdmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aW1lb3V0ID0gMFxuXG4gICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gV0FJVElORykge1xuICAgICAgaWYgKCF3YXNBY3Rpdml0eSAmJiBjYW5jZWxGdW5jdGlvbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnTm8gYWN0aXZpdHkgd2l0aGluICcgK1xuICAgICAgICAgICAgICBoZWFydGJlYXRUaW1lb3V0ICtcbiAgICAgICAgICAgICAgJyBtaWxsaXNlY29uZHMuIFJlY29ubmVjdGluZy4nXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIGNhbmNlbEZ1bmN0aW9uKClcbiAgICAgICAgY2FuY2VsRnVuY3Rpb24gPSB1bmRlZmluZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhc0FjdGl2aXR5ID0gZmFsc2VcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uVGltZW91dCgpXG4gICAgICAgIH0sIGhlYXJ0YmVhdFRpbWVvdXQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB3YXNBY3Rpdml0eSA9IGZhbHNlXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb25UaW1lb3V0KClcbiAgICB9LCBoZWFydGJlYXRUaW1lb3V0KVxuXG4gICAgY3VycmVudFN0YXRlID0gQ09OTkVDVElOR1xuICAgIGRhdGFCdWZmZXIgPSAnJ1xuICAgIGV2ZW50VHlwZUJ1ZmZlciA9ICcnXG4gICAgbGFzdEV2ZW50SWRCdWZmZXIgPSBsYXN0RXZlbnRJZFxuICAgIHRleHRCdWZmZXIgPSAnJ1xuICAgIGZpZWxkU3RhcnQgPSAwXG4gICAgdmFsdWVTdGFydCA9IDBcbiAgICBzdGF0ZSA9IEZJRUxEX1NUQVJUXG5cbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00Mjg5MTZcbiAgICAvLyBSZXF1ZXN0IGhlYWRlciBmaWVsZCBMYXN0LUV2ZW50LUlEIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMuXG4gICAgdmFyIHJlcXVlc3RVUkwgPSB1cmxcbiAgICBpZiAodXJsLnNsaWNlKDAsIDUpICE9PSAnZGF0YTonICYmIHVybC5zbGljZSgwLCA1KSAhPT0gJ2Jsb2I6Jykge1xuICAgICAgaWYgKGxhc3RFdmVudElkICE9PSAnJykge1xuICAgICAgICByZXF1ZXN0VVJMICs9XG4gICAgICAgICAgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArXG4gICAgICAgICAgJ2xhc3RFdmVudElkPScgK1xuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChsYXN0RXZlbnRJZClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0ge31cbiAgICByZXF1ZXN0SGVhZGVyc1snQWNjZXB0J10gPSAndGV4dC9ldmVudC1zdHJlYW0nXG4gICAgaWYgKGhlYWRlcnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBuYW1lKSkge1xuICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW25hbWVdID0gaGVhZGVyc1tuYW1lXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0cmFuc3BvcnQub3BlbihcbiAgICAgICAgeGhyLFxuICAgICAgICBvblN0YXJ0LFxuICAgICAgICBvblByb2dyZXNzLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgcmVxdWVzdFVSTCxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICByZXF1ZXN0SGVhZGVyc1xuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbG9zZSgpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGVzLnVybCA9IHVybFxuICBlcy5yZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuICBlcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHNcbiAgZXMuX2Nsb3NlID0gY2xvc2VcblxuICBvblRpbWVvdXQoKVxufVxuXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlKVxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ09OTkVDVElORyA9IENPTk5FQ1RJTkdcbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLk9QRU4gPSBPUEVOXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5DTE9TRUQgPSBDTE9TRURcbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jbG9zZSgpXG59XG5cbkV2ZW50U291cmNlUG9seWZpbGwuQ09OTkVDVElORyA9IENPTk5FQ1RJTkdcbkV2ZW50U291cmNlUG9seWZpbGwuT1BFTiA9IE9QRU5cbkV2ZW50U291cmNlUG9seWZpbGwuQ0xPU0VEID0gQ0xPU0VEXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSB1bmRlZmluZWRcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRTb3VyY2VQb2x5ZmlsbFxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRpc3BsYXlDb250ZW50KGNhbGxiYWNrKSB7XG4gIC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrIGhlbHBlciB0aGF0IHJlbW92ZXMgTmV4dC5qcycgbm8tRk9VQyBzdHlsZXMgd2hlblxuICAvLyBDU1MgbW9kZSBpcyBlbmFibGVkLiBUaGlzIG9ubHkgcmVhbGx5IGFjdGl2YXRlcyBpZiB5b3UgaGF2ZW4ndCBjcmVhdGVkXG4gIC8vIF9hbnlfIHN0eWxlcyBpbiB5b3VyIGFwcGxpY2F0aW9uIHlldC5cbiAgOyh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQpKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIHggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uZXh0LWhpZGUtZm91Y10nKSwgaSA9IHgubGVuZ3RoO1xuICAgICAgaS0tO1xuXG4gICAgKSB7XG4gICAgICB4W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeFtpXSlcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IFJvdXRlciBmcm9tICduZXh0L3JvdXRlcidcbmltcG9ydCB7IHNldHVwUGluZywgY3VycmVudFBhZ2UsIGNsb3NlUGluZyB9IGZyb20gJy4vb24tZGVtYW5kLWVudHJpZXMtdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7IGFzc2V0UHJlZml4IH0pID0+IHtcbiAgUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKFxuICAgICAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAgICAgc2V0dXBQaW5nLmJpbmQodGhpcywgYXNzZXRQcmVmaXgsICgpID0+IFJvdXRlci5wYXRobmFtZSlcbiAgICApXG4gIH0pXG5cbiAgc2V0dXBQaW5nKGFzc2V0UHJlZml4LCAoKSA9PiBSb3V0ZXIucGF0aG5hbWUsIGN1cnJlbnRQYWdlKVxuXG4gIC8vIHByZXZlbnQgSE1SIGNvbm5lY3Rpb24gZnJvbSBiZWluZyBjbG9zZWQgd2hlbiBydW5uaW5nIHRlc3RzXG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlXG4gICAgICBpZiAoc3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICBzZXR1cFBpbmcoYXNzZXRQcmVmaXgsICgpID0+IFJvdXRlci5wYXRobmFtZSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlUGluZygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICBjbG9zZVBpbmcoKVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuXG5pbXBvcnQgZmV0Y2ggZnJvbSAnbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy91bmZldGNoJ1xuaW1wb3J0IHsgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyIH0gZnJvbSAnLi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlJ1xuXG5sZXQgZXZ0U291cmNlXG5leHBvcnQgbGV0IGN1cnJlbnRQYWdlXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVBpbmcoKSB7XG4gIGlmIChldnRTb3VyY2UpIGV2dFNvdXJjZS5jbG9zZSgpXG4gIGV2dFNvdXJjZSA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwUGluZyhhc3NldFByZWZpeCwgcGF0aG5hbWVGbiwgcmV0cnkpIHtcbiAgY29uc3QgcGF0aG5hbWUgPSBwYXRobmFtZUZuKClcblxuICAvLyBNYWtlIHN1cmUgdG8gb25seSBjcmVhdGUgbmV3IEV2ZW50U291cmNlIHJlcXVlc3QgaWYgcGFnZSBoYXMgY2hhbmdlZFxuICBpZiAocGF0aG5hbWUgPT09IGN1cnJlbnRQYWdlICYmICFyZXRyeSkgcmV0dXJuXG4gIGN1cnJlbnRQYWdlID0gcGF0aG5hbWVcbiAgLy8gY2xvc2UgY3VycmVudCBFdmVudFNvdXJjZSBjb25uZWN0aW9uXG4gIGNsb3NlUGluZygpXG5cbiAgY29uc3QgdXJsID0gYCR7YXNzZXRQcmVmaXh9L19uZXh0L3dlYnBhY2staG1yP3BhZ2U9JHtjdXJyZW50UGFnZX1gXG4gIGV2dFNvdXJjZSA9IGdldEV2ZW50U291cmNlV3JhcHBlcih7IHBhdGg6IHVybCwgdGltZW91dDogNTAwMCwgb25kZW1hbmQ6IDEgfSlcblxuICBldnRTb3VyY2UuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpIHJldHVyblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgaWYgKHBheWxvYWQuaW52YWxpZCkge1xuICAgICAgICAvLyBQYXlsb2FkIGNhbiBiZSBpbnZhbGlkIGV2ZW4gaWYgdGhlIHBhZ2UgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIC8vIFNvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBleGlzdHMgYmVmb3JlIHJlbG9hZGluZy5cbiAgICAgICAgZmV0Y2gobG9jYXRpb24uaHJlZiwge1xuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICB9KS50aGVuKChwYWdlUmVzKSA9PiB7XG4gICAgICAgICAgaWYgKHBhZ2VSZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCBSb3V0ZXIgZnJvbSAnLi4vcm91dGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0aWFsaXplQnVpbGRXYXRjaGVyKCkge1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc2hhZG93SG9zdC5pZCA9ICdfX25leHQtcHJlcmVuZGVyLWluZGljYXRvcidcbiAgLy8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuICBzaGFkb3dIb3N0LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICBzaGFkb3dIb3N0LnN0eWxlLmJvdHRvbSA9ICcyMHB4J1xuICBzaGFkb3dIb3N0LnN0eWxlLnJpZ2h0ID0gJzEwcHgnXG4gIHNoYWRvd0hvc3Quc3R5bGUud2lkdGggPSAwXG4gIHNoYWRvd0hvc3Quc3R5bGUuaGVpZ2h0ID0gMFxuICBzaGFkb3dIb3N0LnN0eWxlLnpJbmRleCA9IDk5OTk4XG4gIHNoYWRvd0hvc3Quc3R5bGUudHJhbnNpdGlvbiA9ICdhbGwgMTAwbXMgZWFzZSdcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpXG5cbiAgbGV0IHNoYWRvd1Jvb3RcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgaWYgKHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KSB7XG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbiAgICAvLyB0aGUgU2hhZG93IERPTSwgd2UgbmVlZCB0byBwcmVmaXggYWxsIHRoZSBuYW1lcyBzbyB0aGVyZVxuICAgIC8vIHdpbGwgYmUgbm8gY29uZmxpY3RzXG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3RcbiAgICBwcmVmaXggPSAnX19uZXh0LXByZXJlbmRlci1pbmRpY2F0b3ItJ1xuICB9XG5cbiAgLy8gQ29udGFpbmVyXG4gIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpXG4gIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuXG4gIC8vIENTU1xuICBjb25zdCBjc3MgPSBjcmVhdGVDc3MocHJlZml4KVxuICBzaGFkb3dSb290LmFwcGVuZENoaWxkKGNzcylcblxuICBjb25zdCBleHBhbmRFbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhJylcbiAgY29uc3QgY2xvc2VFbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAjJHtwcmVmaXh9Y2xvc2VgKVxuXG4gIC8vIFN0YXRlXG4gIGNvbnN0IGRpc21pc3NLZXkgPSAnX19ORVhUX0RJU01JU1NfUFJFUkVOREVSX0lORElDQVRPUidcbiAgY29uc3QgZGlzbWlzc1VudGlsID0gcGFyc2VJbnQod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGRpc21pc3NLZXkpLCAxMClcbiAgY29uc3QgZGlzbWlzc2VkID0gZGlzbWlzc1VudGlsID4gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICBsZXQgaXNWaXNpYmxlID0gIWRpc21pc3NlZCAmJiB3aW5kb3cuX19ORVhUX0RBVEFfXy5uZXh0RXhwb3J0XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCkge1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGAke3ByZWZpeH12aXNpYmxlYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7cHJlZml4fXZpc2libGVgKVxuICAgIH1cbiAgfVxuICBjb25zdCBleHBhbmRlZENsYXNzID0gYCR7cHJlZml4fWV4cGFuZGVkYFxuICBsZXQgdG9nZ2xlVGltZW91dFxuXG4gIGNvbnN0IHRvZ2dsZUV4cGFuZCA9IChleHBhbmQgPSB0cnVlKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRvZ2dsZVRpbWVvdXQpXG5cbiAgICB0b2dnbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgIGV4cGFuZEVsLmNsYXNzTGlzdC5hZGQoZXhwYW5kZWRDbGFzcylcbiAgICAgICAgY2xvc2VFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHBhbmRFbC5jbGFzc0xpc3QucmVtb3ZlKGV4cGFuZGVkQ2xhc3MpXG4gICAgICAgIGNsb3NlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgfVxuICAgIH0sIDUwKVxuICB9XG5cbiAgY2xvc2VFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBjb25zdCBvbmVIb3VyQXdheSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgMSAqIDYwICogNjAgKiAxMDAwXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGRpc21pc3NLZXksIG9uZUhvdXJBd2F5ICsgJycpXG4gICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICB1cGRhdGVDb250YWluZXIoKVxuICB9KVxuICBjbG9zZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB0b2dnbGVFeHBhbmQoKSlcbiAgY2xvc2VFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4gdG9nZ2xlRXhwYW5kKGZhbHNlKSlcbiAgZXhwYW5kRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHRvZ2dsZUV4cGFuZCgpKVxuICBleHBhbmRFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4gdG9nZ2xlRXhwYW5kKGZhbHNlKSlcblxuICBSb3V0ZXIuZXZlbnRzLm9uKCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgKCkgPT4ge1xuICAgIGlzVmlzaWJsZSA9IHdpbmRvdy5uZXh0LmlzUHJlcmVuZGVyZWRcbiAgICB1cGRhdGVDb250YWluZXIoKVxuICB9KVxuICB1cGRhdGVDb250YWluZXIoKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRhaW5lci5pZCA9IGAke3ByZWZpeH1jb250YWluZXJgXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGJ1dHRvbiBpZD1cIiR7cHJlZml4fWNsb3NlXCIgdGl0bGU9XCJIaWRlIGluZGljYXRvciBmb3Igc2Vzc2lvblwiPlxuICAgICAgPHNwYW4+w5c8L3NwYW4+XG4gICAgPC9idXR0b24+XG4gICAgPGEgaHJlZj1cImh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzI2F1dG9tYXRpYy1zdGF0aWMtb3B0aW1pemF0aW9uLWluZGljYXRvclwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vcmVmZXJyZXJcIj5cbiAgICAgIDxkaXYgaWQ9XCIke3ByZWZpeH1pY29uLXdyYXBwZXJcIj5cbiAgICAgICAgICA8c3ZnIHdpZHRoPVwiMTVcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgNjAgODBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTM2IDNMMzAuNzQgNDFIOEwzNiAzWlwiIGZpbGw9XCJibGFja1wiLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTI1IDc3TDMwLjI2IDM5SDUzTDI1IDc3WlwiIGZpbGw9XCJibGFja1wiLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTEzLjUgMzMuNUw1MyAzOUw0Ny41IDQ2LjVMNyA0MS4yNUwxMy41IDMzLjVaXCIgZmlsbD1cImJsYWNrXCIvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIFByZXJlbmRlcmVkIFBhZ2VcbiAgICAgIDwvZGl2PlxuICAgIDwvYT5cbiAgYFxuICByZXR1cm4gY29udGFpbmVyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNzcyhwcmVmaXgpIHtcbiAgY29uc3QgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBjc3MudGV4dENvbnRlbnQgPSBgXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgcmlnaHQ6IDE1cHg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWNsb3NlIHtcbiAgICAgIHRvcDogLTEwcHg7XG4gICAgICByaWdodDogLTEwcHg7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB3aWR0aDogMThweDtcbiAgICAgIGhlaWdodDogMThweDtcbiAgICAgIGNvbG9yOiAjMzMzMzMzO1xuICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyIGEge1xuICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICB3aWR0aDogMTVweDtcbiAgICAgIGhlaWdodDogMjNweDtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgICBjb2xvcjogIzAwMDtcbiAgICAgIGZvbnQ6IGluaXRpYWw7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBsZXR0ZXItc3BhY2luZzogaW5pdGlhbDtcbiAgICAgIHRleHQtc2hhZG93OiBpbml0aWFsO1xuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XG4gICAgICB2aXNpYmlsaXR5OiBpbml0aWFsO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcblxuICAgICAgcGFkZGluZzogNHB4IDJweDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDExcHggNDBweCAwIHJnYmEoMCwgMCwgMCwgMC4yNSksIDAgMnB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xuXG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2UsIGJvdHRvbSAwLjFzIGVhc2UsIHdpZHRoIDAuM3MgZWFzZTtcbiAgICAgIGFuaW1hdGlvbjogJHtwcmVmaXh9ZmFkZS1pbiAwLjFzIGVhc2UtaW4tb3V0O1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLXdyYXBwZXIge1xuICAgICAgd2lkdGg6IDE0MHB4O1xuICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9aWNvbi13cmFwcGVyIHN2ZyB7XG4gICAgICBmbGV4LXNocmluazogMDtcbiAgICAgIG1hcmdpbi1yaWdodDogM3B4O1xuICAgIH1cblxuICAgICMke3ByZWZpeH1jb250YWluZXIgYS4ke3ByZWZpeH1leHBhbmRlZCB7XG4gICAgICB3aWR0aDogMTM1cHg7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lci4ke3ByZWZpeH12aXNpYmxlIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBib3R0b206IDEwcHg7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgJHtwcmVmaXh9ZmFkZS1pbiB7XG4gICAgICBmcm9tIHtcbiAgICAgICAgYm90dG9tOiAwcHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG4gICAgICB0byB7XG4gICAgICAgIGJvdHRvbTogMTBweDtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cbiAgICB9XG4gIGBcblxuICByZXR1cm4gY3NzXG59XG4iLCJpbXBvcnQgY29ubmVjdCBmcm9tICcuL2Vycm9yLW92ZXJsYXkvaG90LWRldi1jbGllbnQnXG5cbmV4cG9ydCBkZWZhdWx0ICh7IGFzc2V0UHJlZml4IH0pID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBwYXRoOiBgJHthc3NldFByZWZpeH0vX25leHQvd2VicGFjay1obXJgLFxuICB9XG5cbiAgY29uc3QgZGV2Q2xpZW50ID0gY29ubmVjdChvcHRpb25zKVxuXG4gIGRldkNsaWVudC5zdWJzY3JpYmVUb0htckV2ZW50KChvYmopID0+IHtcbiAgICBpZiAob2JqLmFjdGlvbiA9PT0gJ3JlbG9hZFBhZ2UnKSB7XG4gICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfVxuICAgIGlmIChvYmouYWN0aW9uID09PSAncmVtb3ZlZFBhZ2UnKSB7XG4gICAgICBjb25zdCBbcGFnZV0gPSBvYmouZGF0YVxuICAgICAgaWYgKHBhZ2UgPT09IHdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKG9iai5hY3Rpb24gPT09ICdhZGRlZFBhZ2UnKSB7XG4gICAgICBjb25zdCBbcGFnZV0gPSBvYmouZGF0YVxuICAgICAgaWYgKFxuICAgICAgICBwYWdlID09PSB3aW5kb3cubmV4dC5yb3V0ZXIucGF0aG5hbWUgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5uZXh0LnJvdXRlci5jb21wb25lbnRzW3BhZ2VdID09PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYWN0aW9uICcgKyBvYmouYWN0aW9uKVxuICB9KVxuXG4gIHJldHVybiBkZXZDbGllbnRcbn1cbiIsImNvbnN0IERPTUF0dHJpYnV0ZU5hbWVzID0ge1xuICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICBjbGFzc05hbWU6ICdjbGFzcycsXG4gIGh0bWxGb3I6ICdmb3InLFxuICBodHRwRXF1aXY6ICdodHRwLWVxdWl2Jyxcbn1cblxuZnVuY3Rpb24gcmVhY3RFbGVtZW50VG9ET00oeyB0eXBlLCBwcm9wcyB9KSB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKVxuICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZVxuICAgIGlmIChwID09PSAnY2hpbGRyZW4nIHx8IHAgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIGNvbnRpbnVlXG5cbiAgICAvLyB3ZSBkb24ndCByZW5kZXIgdW5kZWZpbmVkIHByb3BzIHRvIHRoZSBET01cbiAgICBpZiAocHJvcHNbcF0gPT09IHVuZGVmaW5lZCkgY29udGludWVcblxuICAgIGNvbnN0IGF0dHIgPSBET01BdHRyaWJ1dGVOYW1lc1twXSB8fCBwLnRvTG93ZXJDYXNlKClcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgcHJvcHNbcF0pXG4gIH1cblxuICBjb25zdCB7IGNoaWxkcmVuLCBkYW5nZXJvdXNseVNldElubmVySFRNTCB9ID0gcHJvcHNcbiAgaWYgKGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIHx8ICcnXG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBjaGlsZHJlbiA6IGNoaWxkcmVuLmpvaW4oJycpXG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHR5cGUsIGNvbXBvbmVudHMpIHtcbiAgY29uc3QgaGVhZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXVxuICBjb25zdCBoZWFkQ291bnRFbCA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9bmV4dC1oZWFkLWNvdW50XScpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFoZWFkQ291bnRFbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1dhcm5pbmc6IG5leHQtaGVhZC1jb3VudCBpcyBtaXNzaW5nLiBodHRwczovL2Vyci5zaC9uZXh0LmpzL25leHQtaGVhZC1jb3VudC1taXNzaW5nJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGVhZENvdW50ID0gTnVtYmVyKGhlYWRDb3VudEVsLmNvbnRlbnQpXG4gIGNvbnN0IG9sZFRhZ3MgPSBbXVxuXG4gIGZvciAoXG4gICAgbGV0IGkgPSAwLCBqID0gaGVhZENvdW50RWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBpIDwgaGVhZENvdW50O1xuICAgIGkrKywgaiA9IGoucHJldmlvdXNFbGVtZW50U2libGluZ1xuICApIHtcbiAgICBpZiAoai50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUpIHtcbiAgICAgIG9sZFRhZ3MucHVzaChqKVxuICAgIH1cbiAgfVxuICBjb25zdCBuZXdUYWdzID0gY29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcigobmV3VGFnKSA9PiB7XG4gICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IG9sZFRhZ3MubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIGNvbnN0IG9sZFRhZyA9IG9sZFRhZ3Nba11cbiAgICAgIGlmIChvbGRUYWcuaXNFcXVhbE5vZGUobmV3VGFnKSkge1xuICAgICAgICBvbGRUYWdzLnNwbGljZShrLCAxKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSlcblxuICBvbGRUYWdzLmZvckVhY2goKHQpID0+IHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSlcbiAgbmV3VGFncy5mb3JFYWNoKCh0KSA9PiBoZWFkRWwuaW5zZXJ0QmVmb3JlKHQsIGhlYWRDb3VudEVsKSlcbiAgaGVhZENvdW50RWwuY29udGVudCA9IChoZWFkQ291bnQgLSBvbGRUYWdzLmxlbmd0aCArIG5ld1RhZ3MubGVuZ3RoKS50b1N0cmluZygpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRIZWFkTWFuYWdlcigpIHtcbiAgbGV0IHVwZGF0ZVByb21pc2UgPSBudWxsXG5cbiAgcmV0dXJuIChoZWFkKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZSA9ICh1cGRhdGVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAocHJvbWlzZSAhPT0gdXBkYXRlUHJvbWlzZSkgcmV0dXJuXG5cbiAgICAgIHVwZGF0ZVByb21pc2UgPSBudWxsXG4gICAgICBjb25zdCB0YWdzID0ge31cblxuICAgICAgaGVhZC5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0YWdzW2gudHlwZV0gfHwgW11cbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGgpXG4gICAgICAgIHRhZ3NbaC50eXBlXSA9IGNvbXBvbmVudHNcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRpdGxlQ29tcG9uZW50ID0gdGFncy50aXRsZSA/IHRhZ3MudGl0bGVbMF0gOiBudWxsXG4gICAgICBsZXQgdGl0bGUgPSAnJ1xuICAgICAgaWYgKHRpdGxlQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRpdGxlQ29tcG9uZW50LnByb3BzXG4gICAgICAgIHRpdGxlID0gdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGNoaWxkcmVuIDogY2hpbGRyZW4uam9pbignJylcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZSAhPT0gZG9jdW1lbnQudGl0bGUpIGRvY3VtZW50LnRpdGxlID0gdGl0bGVcbiAgICAgIDtbJ21ldGEnLCAnYmFzZScsICdsaW5rJywgJ3N0eWxlJywgJ3NjcmlwdCddLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdXBkYXRlRWxlbWVudHModHlwZSwgdGFnc1t0eXBlXSB8fCBbXSlcbiAgICAgIH0pXG4gICAgfSkpXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyLCBtYWtlUHVibGljUm91dGVySW5zdGFuY2UgfSBmcm9tICduZXh0L3JvdXRlcidcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlUXMsIHN0cmluZ2lmeSBhcyBzdHJpbmdpZnlRcyB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dCdcbmltcG9ydCBtaXR0IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9taXR0J1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0ICogYXMgZW52Q29uZmlnIGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9ydW50aW1lLWNvbmZpZydcbmltcG9ydCB7IGdldFVSTCwgbG9hZEdldEluaXRpYWxQcm9wcywgU1QgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgaW5pdEhlYWRNYW5hZ2VyIGZyb20gJy4vaGVhZC1tYW5hZ2VyJ1xuaW1wb3J0IFBhZ2VMb2FkZXIgZnJvbSAnLi9wYWdlLWxvYWRlcidcbmltcG9ydCBtZWFzdXJlV2ViVml0YWxzIGZyb20gJy4vcGVyZm9ybWFuY2UtcmVsYXllcidcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC1kb20vZXhwZXJpbWVudGFsXCIgLz5cblxuaWYgKCEoJ2ZpbmFsbHknIGluIFByb21pc2UucHJvdG90eXBlKSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZVxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9maW5hbGx5LXBvbHlmaWxsLm1pbicpXG59XG5cbmNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJykudGV4dENvbnRlbnQpXG53aW5kb3cuX19ORVhUX0RBVEFfXyA9IGRhdGFcblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfVkVSU0lPTlxuXG5jb25zdCB7XG4gIHByb3BzLFxuICBlcnIsXG4gIHBhZ2UsXG4gIHF1ZXJ5LFxuICBidWlsZElkLFxuICBhc3NldFByZWZpeCxcbiAgcnVudGltZUNvbmZpZyxcbiAgZHluYW1pY0lkcyxcbiAgaXNGYWxsYmFjayxcbn0gPSBkYXRhXG5cbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnXG5cbi8vIFdpdGggZHluYW1pYyBhc3NldFByZWZpeCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXQgYXNzZXRQcmVmaXggYXQgdGhlIGJ1aWxkIHRpbWVcbi8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuX193ZWJwYWNrX3B1YmxpY19wYXRoX18gPSBgJHtwcmVmaXh9L19uZXh0L2AgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4vLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbmVudkNvbmZpZy5zZXRDb25maWcoe1xuICBzZXJ2ZXJSdW50aW1lQ29uZmlnOiB7fSxcbiAgcHVibGljUnVudGltZUNvbmZpZzogcnVudGltZUNvbmZpZyB8fCB7fSxcbn0pXG5cbmNvbnN0IGFzUGF0aCA9IGdldFVSTCgpXG5cbmNvbnN0IHBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcihidWlsZElkLCBwcmVmaXgpXG5jb25zdCByZWdpc3RlciA9IChbciwgZl0pID0+IHBhZ2VMb2FkZXIucmVnaXN0ZXJQYWdlKHIsIGYpXG5pZiAod2luZG93Ll9fTkVYVF9QKSB7XG4gIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAvLyBsYXRlbmN5IGluIGh5ZHJhdGluZyB0aGUgcGFnZSwgYnV0IHJlZHVjZSB0aGUgdG90YWwgYmxvY2tpbmcgdGltZS5cbiAgd2luZG93Ll9fTkVYVF9QLm1hcCgocCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWdpc3RlcihwKSwgMCkpXG59XG53aW5kb3cuX19ORVhUX1AgPSBbXVxud2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlclxuXG5jb25zdCB1cGRhdGVIZWFkID0gaW5pdEhlYWRNYW5hZ2VyKClcbmNvbnN0IGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0JylcblxubGV0IGxhc3RBcHBQcm9wc1xubGV0IGxhc3RSZW5kZXJSZWplY3RcbmxldCB3ZWJwYWNrSE1SXG5leHBvcnQgbGV0IHJvdXRlclxubGV0IENvbXBvbmVudFxubGV0IEFwcCwgb25QZXJmRW50cnlcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyLCBpbmZvKSB7XG4gICAgdGhpcy5wcm9wcy5mbihlcnIsIGluZm8pXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjcm9sbFRvSGFzaCgpXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaW1wb3J0KCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT11bnN0YWJsZS1wb3N0LWh5ZHJhdGlvbiEnKVxuICAgICAgICAudGhlbigobW9kKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG1vZC5kZWZhdWx0KClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIHBvc3QtaHlkcmF0aW9uIGZvciBwbHVnaW5zJywgZXJyKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgIC8vIC0gdGhlIHBhZ2Ugd2FzIChhdXRvKSBleHBvcnRlZCBhbmQgaGFzIGEgcXVlcnkgc3RyaW5nIG9yIHNlYXJjaCAoaGFzaClcbiAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgIGlmIChcbiAgICAgIHJvdXRlci5pc1NzciAmJlxuICAgICAgKGlzRmFsbGJhY2sgfHxcbiAgICAgICAgKGRhdGEubmV4dEV4cG9ydCAmJlxuICAgICAgICAgIChpc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCkpIHx8XG4gICAgICAgIChwcm9wcyAmJiBwcm9wcy5fX05fU1NHICYmIGxvY2F0aW9uLnNlYXJjaCkpXG4gICAgKSB7XG4gICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICByb3V0ZXIucmVwbGFjZShcbiAgICAgICAgcm91dGVyLnBhdGhuYW1lICtcbiAgICAgICAgICAnPycgK1xuICAgICAgICAgIHN0cmluZ2lmeVFzKHtcbiAgICAgICAgICAgIC4uLnJvdXRlci5xdWVyeSxcbiAgICAgICAgICAgIC4uLnBhcnNlUXMobG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSksXG4gICAgICAgICAgfSksXG4gICAgICAgIGFzUGF0aCxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgIHNoYWxsb3c6ICFpc0ZhbGxiYWNrLFxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG5cbiAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLnNjcm9sbFRvSGFzaCgpXG4gIH1cblxuICBzY3JvbGxUb0hhc2goKSB7XG4gICAgbGV0IHsgaGFzaCB9ID0gbG9jYXRpb25cbiAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKVxuICAgIGlmICghaGFzaCkgcmV0dXJuXG5cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKCFlbCkgcmV0dXJuXG5cbiAgICAvLyBJZiB3ZSBjYWxsIHNjcm9sbEludG9WaWV3KCkgaW4gaGVyZSB3aXRob3V0IGEgc2V0VGltZW91dFxuICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGVsLnNjcm9sbEludG9WaWV3KCksIDApXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IFJlYWN0RGV2T3ZlcmxheSB9ID0gcmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpXG4gICAgICByZXR1cm4gPFJlYWN0RGV2T3ZlcmxheT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L1JlYWN0RGV2T3ZlcmxheT5cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVtaXR0ZXIgPSBtaXR0KClcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgd2VicGFja0hNUjogcGFzc2VkV2VicGFja0hNUiB9ID0ge30pID0+IHtcbiAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICB3ZWJwYWNrSE1SID0gcGFzc2VkV2VicGFja0hNUlxuICB9XG4gIGNvbnN0IHsgcGFnZTogYXBwLCBtb2QgfSA9IGF3YWl0IHBhZ2VMb2FkZXIubG9hZFBhZ2VTY3JpcHQoJy9fYXBwJylcbiAgQXBwID0gYXBwXG5cbiAgaWYgKG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzKSB7XG4gICAgb25QZXJmRW50cnkgPSAoe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVudHJ5VHlwZSxcbiAgICAgIGVudHJpZXMsXG4gICAgfSkgPT4ge1xuICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICBjb25zdCB1bmlxdWVJRCA9IGAke0RhdGUubm93KCl9LSR7XG4gICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMlxuICAgICAgfWBcbiAgICAgIGxldCBwZXJmU3RhcnRFbnRyeVxuXG4gICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICBwZXJmU3RhcnRFbnRyeSA9IGVudHJpZXNbMF0uc3RhcnRUaW1lXG4gICAgICB9XG5cbiAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMoe1xuICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgIGxhYmVsOlxuICAgICAgICAgIGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnXG4gICAgICAgICAgICA/ICdjdXN0b20nXG4gICAgICAgICAgICA6ICd3ZWItdml0YWwnLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBsZXQgaW5pdGlhbEVyciA9IGVyclxuXG4gIHRyeSB7XG4gICAgOyh7IHBhZ2U6IENvbXBvbmVudCB9ID0gYXdhaXQgcGFnZUxvYWRlci5sb2FkUGFnZShwYWdlKSlcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhZ2V9XCJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICBpbml0aWFsRXJyID0gZXJyb3JcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IHsgZ2V0Tm9kZUVycm9yIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50JylcbiAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAvLyB0aGF0IHRoZSBvdmVybGF5IGlzIHJlbmRlcmVkLlxuICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICBpZiAoaW5pdGlhbEVyciA9PT0gZXJyKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGxldCBlcnJvclxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBlcnJvciBvYmplY3QuIFdlIGB0aHJvd2AgaXQgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5pdGlhbEVyci5tZXNzYWdlKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWVcbiAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIuc3RhY2tcblxuICAgICAgICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlRXJyb3IoZXJyb3IpXG4gICAgICAgICAgdGhyb3cgbm9kZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gV2UgcmVwbGFjZWQgdGhlIHNlcnZlci1zaWRlIGVycm9yIHdpdGggYSBjbGllbnQtc2lkZSBlcnJvciwgYW5kIHNob3VsZFxuICAgICAgLy8gbm8gbG9uZ2VyIHJld3JpdGUgdGhlIHN0YWNrIHRyYWNlIHRvIGEgTm9kZSBlcnJvci5cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgYXdhaXQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoZHluYW1pY0lkcylcbiAgfVxuXG4gIHJvdXRlciA9IGNyZWF0ZVJvdXRlcihwYWdlLCBxdWVyeSwgYXNQYXRoLCB7XG4gICAgaW5pdGlhbFByb3BzOiBwcm9wcyxcbiAgICBwYWdlTG9hZGVyLFxuICAgIEFwcCxcbiAgICBDb21wb25lbnQsXG4gICAgd3JhcEFwcCxcbiAgICBlcnI6IGluaXRpYWxFcnIsXG4gICAgaXNGYWxsYmFjayxcbiAgICBzdWJzY3JpcHRpb246ICh7IENvbXBvbmVudCwgcHJvcHMsIGVyciB9LCBBcHApID0+XG4gICAgICByZW5kZXIoeyBBcHAsIENvbXBvbmVudCwgcHJvcHMsIGVyciB9KSxcbiAgfSlcblxuICAvLyBjYWxsIGluaXQtY2xpZW50IG1pZGRsZXdhcmVcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9QTFVHSU5TKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaW1wb3J0KCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1pbml0LWNsaWVudCEnKVxuICAgICAgLnRoZW4oKG1vZCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kLmRlZmF1bHQoeyByb3V0ZXIgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGNsaWVudC1pbml0IGZvciBwbHVnaW5zJywgZXJyKVxuICAgICAgfSlcbiAgfVxuXG4gIGNvbnN0IHJlbmRlckN0eCA9IHsgQXBwLCBDb21wb25lbnQsIHByb3BzLCBlcnI6IGluaXRpYWxFcnIgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmVuZGVyKHJlbmRlckN0eClcbiAgICByZXR1cm4gZW1pdHRlclxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4geyBlbWl0dGVyLCByZW5kZXIsIHJlbmRlckN0eCB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuICBpZiAocHJvcHMuZXJyKSB7XG4gICAgYXdhaXQgcmVuZGVyRXJyb3IocHJvcHMpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGRvUmVuZGVyKHByb3BzKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGlzIGVycm9yIGlzIGRpc3BsYXllZCBpbiB0aGUgb3ZlcmxheSBpbiBkZXZlbG9wbWVudFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9XG4gICAgYXdhaXQgcmVuZGVyRXJyb3IoeyAuLi5wcm9wcywgZXJyIH0pXG4gIH1cbn1cblxuLy8gVGhpcyBtZXRob2QgaGFuZGxlcyBhbGwgcnVudGltZSBhbmQgZGVidWcgZXJyb3JzLlxuLy8gNDA0IGFuZCA1MDAgZXJyb3JzIGFyZSBzcGVjaWFsIGtpbmQgb2YgZXJyb3JzXG4vLyBhbmQgdGhleSBhcmUgc3RpbGwgaGFuZGxlIHZpYSB0aGUgbWFpbiByZW5kZXIgbWV0aG9kLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckVycm9yKHByb3BzKSB7XG4gIGNvbnN0IHsgQXBwLCBlcnIgfSA9IHByb3BzXG5cbiAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICB3ZWJwYWNrSE1SLm9uVW5yZWNvdmVyYWJsZUVycm9yKClcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgQXBwOiAoKSA9PiBudWxsLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgQ29tcG9uZW50OiAoKSA9PiBudWxsLFxuICAgICAgZXJyOiBudWxsLFxuICAgIH0pXG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9QTFVHSU5TKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaW1wb3J0KCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1lcnJvci1jbGllbnQhJylcbiAgICAgIC50aGVuKChtb2QpID0+IHtcbiAgICAgICAgcmV0dXJuIG1vZC5kZWZhdWx0KHsgZXJyIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3IgY2FsbGluZyBvbi1lcnJvci1jbGllbnQgZm9yIHBsdWdpbnMnLCBlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbiAgY29uc29sZS5lcnJvcihlcnIpXG4gIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKCcvX2Vycm9yJykudGhlbigoeyBwYWdlOiBFcnJvckNvbXBvbmVudCB9KSA9PiB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApXG4gICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgIEFwcFRyZWUsXG4gICAgICByb3V0ZXIsXG4gICAgICBjdHg6IHsgZXJyLCBwYXRobmFtZTogcGFnZSwgcXVlcnksIGFzUGF0aCwgQXBwVHJlZSB9LFxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgcHJvcHMucHJvcHMgPyBwcm9wcy5wcm9wcyA6IGxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpXG4gICAgKS50aGVuKChpbml0UHJvcHMpID0+XG4gICAgICBkb1JlbmRlcih7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0UHJvcHMsXG4gICAgICB9KVxuICAgIClcbiAgfSlcbn1cblxuLy8gSWYgaHlkcmF0ZSBkb2VzIG5vdCBleGlzdCwgZWcgaW4gcHJlYWN0LlxubGV0IGlzSW5pdGlhbFJlbmRlciA9IHR5cGVvZiBSZWFjdERPTS5oeWRyYXRlID09PSAnZnVuY3Rpb24nXG5sZXQgcmVhY3RSb290ID0gbnVsbFxuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KHJlYWN0RWwsIGRvbUVsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfTU9ERSAhPT0gJ2xlZ2FjeScpIHtcbiAgICBpZiAoIXJlYWN0Um9vdCkge1xuICAgICAgY29uc3Qgb3B0cyA9IHsgaHlkcmF0ZTogdHJ1ZSB9XG4gICAgICByZWFjdFJvb3QgPVxuICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfTU9ERSA9PT0gJ2NvbmN1cnJlbnQnXG4gICAgICAgICAgPyBSZWFjdERPTS51bnN0YWJsZV9jcmVhdGVSb290KGRvbUVsLCBvcHRzKVxuICAgICAgICAgIDogUmVhY3RET00udW5zdGFibGVfY3JlYXRlQmxvY2tpbmdSb290KGRvbUVsLCBvcHRzKVxuICAgIH1cbiAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJylcbiAgICB9XG5cbiAgICAvLyBUaGUgY2hlY2sgZm9yIGAuaHlkcmF0ZWAgaXMgdGhlcmUgdG8gc3VwcG9ydCBSZWFjdCBhbHRlcm5hdGl2ZXMgbGlrZSBwcmVhY3RcbiAgICBpZiAoaXNJbml0aWFsUmVuZGVyKSB7XG4gICAgICBSZWFjdERPTS5oeWRyYXRlKHJlYWN0RWwsIGRvbUVsLCBtYXJrSHlkcmF0ZUNvbXBsZXRlKVxuICAgICAgaXNJbml0aWFsUmVuZGVyID0gZmFsc2VcblxuICAgICAgaWYgKG9uUGVyZkVudHJ5ICYmIFNUKSB7XG4gICAgICAgIG1lYXN1cmVXZWJWaXRhbHMob25QZXJmRW50cnkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NLnJlbmRlcihyZWFjdEVsLCBkb21FbCwgbWFya1JlbmRlckNvbXBsZXRlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICBpZiAoIVNUKSByZXR1cm5cblxuICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlckh5ZHJhdGUnKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cblxuICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLFxuICAgICduYXZpZ2F0aW9uU3RhcnQnLFxuICAgICdiZWZvcmVSZW5kZXInXG4gIClcbiAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpXG5cbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICB9XG4gIGNsZWFyTWFya3MoKVxufVxuXG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gIGlmICghU1QpIHJldHVyblxuXG4gIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVyUmVuZGVyJykgLy8gbWFyayBlbmQgb2YgcmVuZGVyXG4gIGNvbnN0IG5hdlN0YXJ0RW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ3JvdXRlQ2hhbmdlJywgJ21hcmsnKVxuXG4gIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgICBuYXZTdGFydEVudHJpZXNbMF0ubmFtZSxcbiAgICAnYmVmb3JlUmVuZGVyJ1xuICApXG4gIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtcmVuZGVyJywgJ2JlZm9yZVJlbmRlcicsICdhZnRlclJlbmRlcicpXG4gIGlmIChvblBlcmZFbnRyeSkge1xuICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSlcbiAgICBwZXJmb3JtYW5jZVxuICAgICAgLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicpXG4gICAgICAuZm9yRWFjaChvblBlcmZFbnRyeSlcbiAgfVxuICBjbGVhck1hcmtzKClcbiAgO1snTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgJ05leHQuanMtcmVuZGVyJ10uZm9yRWFjaCgobWVhc3VyZSkgPT5cbiAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpXG4gIClcbn1cblxuZnVuY3Rpb24gY2xlYXJNYXJrcygpIHtcbiAgO1tcbiAgICAnYmVmb3JlUmVuZGVyJyxcbiAgICAnYWZ0ZXJIeWRyYXRlJyxcbiAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICdyb3V0ZUNoYW5nZScsXG4gIF0uZm9yRWFjaCgobWFyaykgPT4gcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSlcbn1cblxuZnVuY3Rpb24gQXBwQ29udGFpbmVyKHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gKFxuICAgIDxDb250YWluZXJcbiAgICAgIGZuPXsoZXJyb3IpID0+XG4gICAgICAgIHJlbmRlckVycm9yKHsgQXBwLCBlcnI6IGVycm9yIH0pLmNhdGNoKChlcnIpID0+XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHBhZ2U6ICcsIGVycilcbiAgICAgICAgKVxuICAgICAgfVxuICAgID5cbiAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXttYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKX0+XG4gICAgICAgIDxIZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VwZGF0ZUhlYWR9PlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L1JvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9Db250YWluZXI+XG4gIClcbn1cblxuY29uc3Qgd3JhcEFwcCA9IChBcHApID0+IChwcm9wcykgPT4ge1xuICBjb25zdCBhcHBQcm9wcyA9IHsgLi4ucHJvcHMsIENvbXBvbmVudCwgZXJyLCByb3V0ZXIgfVxuICByZXR1cm4gKFxuICAgIDxBcHBDb250YWluZXI+XG4gICAgICA8QXBwIHsuLi5hcHBQcm9wc30gLz5cbiAgICA8L0FwcENvbnRhaW5lcj5cbiAgKVxufVxuXG5hc3luYyBmdW5jdGlvbiBkb1JlbmRlcih7IEFwcCwgQ29tcG9uZW50LCBwcm9wcywgZXJyIH0pIHtcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnRcbiAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHNcblxuICBjb25zdCBhcHBQcm9wcyA9IHsgLi4ucHJvcHMsIENvbXBvbmVudCwgZXJyLCByb3V0ZXIgfVxuICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICBsYXN0QXBwUHJvcHMgPSBhcHBQcm9wc1xuXG4gIGxldCByZXNvbHZlUHJvbWlzZVxuICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChsYXN0UmVuZGVyUmVqZWN0KSB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0KClcbiAgICB9XG4gICAgcmVzb2x2ZVByb21pc2UgPSAoKSA9PiB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGxhc3RSZW5kZXJSZWplY3QgPSAoKSA9PiB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuICAgICAgcmVqZWN0KClcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgZWxlbSA9IChcbiAgICA8Um9vdCBjYWxsYmFjaz17cmVzb2x2ZVByb21pc2V9PlxuICAgICAgPEFwcENvbnRhaW5lcj5cbiAgICAgICAgPEFwcCB7Li4uYXBwUHJvcHN9IC8+XG4gICAgICA8L0FwcENvbnRhaW5lcj5cbiAgICA8L1Jvb3Q+XG4gIClcblxuICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgcmVuZGVyUmVhY3RFbGVtZW50KFxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERSA/IChcbiAgICAgIDxSZWFjdC5TdHJpY3RNb2RlPntlbGVtfTwvUmVhY3QuU3RyaWN0TW9kZT5cbiAgICApIDogKFxuICAgICAgZWxlbVxuICAgICksXG4gICAgYXBwRWxlbWVudFxuICApXG5cbiAgYXdhaXQgcmVuZGVyUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBSb290KHsgY2FsbGJhY2ssIGNoaWxkcmVuIH0pIHtcbiAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWRcbiAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGUuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBjYWxsYmFjaygpLCBbY2FsbGJhY2tdKVxuICByZXR1cm4gY2hpbGRyZW5cbn1cbiIsIi8qIGdsb2JhbHMgX19SRVBMQUNFX05PT1BfSU1QT1JUX18gKi9cbmltcG9ydCBpbml0TmV4dCwgKiBhcyBuZXh0IGZyb20gJy4vJ1xuaW1wb3J0IEV2ZW50U291cmNlUG9seWZpbGwgZnJvbSAnLi9kZXYvZXZlbnQtc291cmNlLXBvbHlmaWxsJ1xuaW1wb3J0IGluaXRPbkRlbWFuZEVudHJpZXMgZnJvbSAnLi9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50J1xuaW1wb3J0IGluaXRXZWJwYWNrSE1SIGZyb20gJy4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50J1xuaW1wb3J0IGluaXRpYWxpemVCdWlsZFdhdGNoZXIgZnJvbSAnLi9kZXYvZGV2LWJ1aWxkLXdhdGNoZXInXG5pbXBvcnQgaW5pdGlhbGl6ZVByZXJlbmRlckluZGljYXRvciBmcm9tICcuL2Rldi9wcmVyZW5kZXItaW5kaWNhdG9yJ1xuaW1wb3J0IHsgZGlzcGxheUNvbnRlbnQgfSBmcm9tICcuL2Rldi9mb3VjJ1xuXG4vLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgdGhlIGlzc3VlIGRlc2NyaWJlZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzc1I2lzc3VlY29tbWVudC00MDc0MzgxMjNcbi8vIFRoZSBydW50aW1lQ2h1bmsgZG9lc24ndCBoYXZlIGR5bmFtaWMgaW1wb3J0IGhhbmRsaW5nIGNvZGUgd2hlbiB0aGVyZSBoYXNuJ3QgYmVlbiBhIGR5bmFtaWMgaW1wb3J0XG4vLyBUaGUgcnVudGltZUNodW5rIGNhbid0IGhvdCByZWxvYWQgaXRzZWxmIGN1cnJlbnRseSB0byBjb3JyZWN0IGl0IHdoZW4gYWRkaW5nIHBhZ2VzIHVzaW5nIG9uLWRlbWFuZC1lbnRyaWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5fX1JFUExBQ0VfTk9PUF9JTVBPUlRfX1xuXG4vLyBTdXBwb3J0IEV2ZW50U291cmNlIG9uIEludGVybmV0IEV4cGxvcmVyIDExXG5pZiAoIXdpbmRvdy5FdmVudFNvdXJjZSkge1xuICB3aW5kb3cuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZVBvbHlmaWxsXG59XG5cbmNvbnN0IHtcbiAgX19ORVhUX0RBVEFfXzogeyBhc3NldFByZWZpeCB9LFxufSA9IHdpbmRvd1xuXG5jb25zdCBwcmVmaXggPSBhc3NldFByZWZpeCB8fCAnJ1xuY29uc3Qgd2VicGFja0hNUiA9IGluaXRXZWJwYWNrSE1SKHsgYXNzZXRQcmVmaXg6IHByZWZpeCB9KVxuXG53aW5kb3cubmV4dCA9IG5leHRcbmluaXROZXh0KHsgd2VicGFja0hNUiB9KVxuICAudGhlbigoeyBlbWl0dGVyLCByZW5kZXJDdHgsIHJlbmRlciB9KSA9PiB7XG4gICAgaW5pdE9uRGVtYW5kRW50cmllcyh7IGFzc2V0UHJlZml4OiBwcmVmaXggfSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0JVSUxEX0lORElDQVRPUikgaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcigpXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX1BSRVJFTkRFUl9JTkRJQ0FUT1IgJiZcbiAgICAgIC8vIGRpc2FibGUgYnkgZGVmYXVsdCBpbiBlbGVjdHJvblxuICAgICAgISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VsZWN0cm9uJyBpbiBwcm9jZXNzLnZlcnNpb25zKVxuICAgICkge1xuICAgICAgaW5pdGlhbGl6ZVByZXJlbmRlckluZGljYXRvcigpXG4gICAgfVxuXG4gICAgLy8gZGVsYXkgcmVuZGVyaW5nIHVudGlsIGFmdGVyIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZCBpbiBkZXZlbG9wbWVudFxuICAgIGRpc3BsYXlDb250ZW50KCgpID0+IHtcbiAgICAgIHJlbmRlcihyZW5kZXJDdHgpXG4gICAgfSlcbiAgfSlcbiAgLmNhdGNoKChlcnIpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsIGVycilcbiAgfSlcbiIsImltcG9ydCB7IHBhcnNlIH0gZnJvbSAndXJsJ1xuaW1wb3J0IG1pdHQgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4J1xuaW1wb3J0IHsgZGVsQmFzZVBhdGggfSBmcm9tICcuLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuXG5mdW5jdGlvbiBoYXNSZWwocmVsLCBsaW5rKSB7XG4gIHRyeSB7XG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIHJldHVybiBsaW5rLnJlbExpc3Quc3VwcG9ydHMocmVsKVxuICB9IGNhdGNoIHt9XG59XG5cbmNvbnN0IHJlbFByZWZldGNoID1cbiAgaGFzUmVsKCdwcmVsb2FkJykgJiYgIWhhc1JlbCgncHJlZmV0Y2gnKVxuICAgID8gLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1saW5rLXJlbC1wcmVsb2FkXG4gICAgICAvLyBtYWNPUyBhbmQgaU9TIChTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBwcmVmZXRjaClcbiAgICAgICdwcmVsb2FkJ1xuICAgIDogLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1saW5rLXJlbC1wcmVmZXRjaFxuICAgICAgLy8gSUUgMTEsIEVkZ2UgMTIrLCBuZWFybHkgYWxsIGV2ZXJncmVlblxuICAgICAgJ3ByZWZldGNoJ1xuXG5jb25zdCBoYXNOb01vZHVsZSA9ICdub01vZHVsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUm91dGUocm91dGUpIHtcbiAgaWYgKHJvdXRlWzBdICE9PSAnLycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBcIi9cIiwgZ290IFwiJHtyb3V0ZX1cImApXG4gIH1cbiAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKC9cXC9pbmRleCQvLCAnLycpXG5cbiAgaWYgKHJvdXRlID09PSAnLycpIHJldHVybiByb3V0ZVxuICByZXR1cm4gcm91dGUucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiBhcHBlbmRMaW5rKGhyZWYsIHJlbCwgYXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaiwgbGluaykgPT4ge1xuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICBsaW5rLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5jcm9zc09yaWdpblxuICAgIGxpbmsuaHJlZiA9IGhyZWZcbiAgICBsaW5rLnJlbCA9IHJlbFxuICAgIGlmIChhcykgbGluay5hcyA9IGFzXG5cbiAgICBsaW5rLm9ubG9hZCA9IHJlc1xuICAgIGxpbmsub25lcnJvciA9IHJlalxuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRJZCwgYXNzZXRQcmVmaXgpIHtcbiAgICB0aGlzLmJ1aWxkSWQgPSBidWlsZElkXG4gICAgdGhpcy5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4XG5cbiAgICB0aGlzLnBhZ2VDYWNoZSA9IHt9XG4gICAgdGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMgPSBtaXR0KClcbiAgICB0aGlzLmxvYWRpbmdSb3V0ZXMgPSB7fVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKSB7XG4gICAgICB0aGlzLnByb21pc2VkQnVpbGRNYW5pZmVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cuX19CVUlMRF9NQU5JRkVTVCkge1xuICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fQlVJTERfTUFOSUZFU1QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Ll9fQlVJTERfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX0JVSUxEX01BTklGRVNUKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPFNldDxzdHJpbmc+Pn0gKi9cbiAgICB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5fX1NTR19NQU5JRkVTVCkge1xuICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5fX1NTR19NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGRlcGVuZGVuY2llcyBmb3IgYSBwYXJ0aWN1bGFyIHJvdXRlXG4gIGdldERlcGVuZGVuY2llcyhyb3V0ZSkge1xuICAgIHJldHVybiB0aGlzLnByb21pc2VkQnVpbGRNYW5pZmVzdC50aGVuKFxuICAgICAgKG1hbikgPT5cbiAgICAgICAgKG1hbltyb3V0ZV0gJiZcbiAgICAgICAgICBtYW5bcm91dGVdLm1hcChcbiAgICAgICAgICAgICh1cmwpID0+IGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0LyR7ZW5jb2RlVVJJKHVybCl9YFxuICAgICAgICAgICkpIHx8XG4gICAgICAgIFtdXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIHRoZSByb3V0ZSBocmVmIChmaWxlLXN5c3RlbSBwYXRoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNQYXRoIHRoZSBVUkwgYXMgc2hvd24gaW4gYnJvd3NlciAodmlydHVhbCBwYXRoKTsgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICovXG4gIGdldERhdGFIcmVmKGhyZWYsIGFzUGF0aCkge1xuICAgIGNvbnN0IGdldEhyZWZGb3JTbHVnID0gKC8qKiBAdHlwZSBzdHJpbmcgKi8gcGF0aCkgPT4ge1xuICAgICAgcGF0aCA9IGRlbEJhc2VQYXRoKHBhdGgpXG4gICAgICByZXR1cm4gYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvZGF0YS8ke3RoaXMuYnVpbGRJZH0ke1xuICAgICAgICBwYXRoID09PSAnLycgPyAnL2luZGV4JyA6IHBhdGhcbiAgICAgIH0uanNvbmBcbiAgICB9XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lOiBocmVmUGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZShocmVmLCB0cnVlKVxuICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHBhcnNlKGFzUGF0aClcblxuICAgIGNvbnN0IHJvdXRlID0gbm9ybWFsaXplUm91dGUoaHJlZlBhdGhuYW1lKVxuXG4gICAgbGV0IGlzRHluYW1pYyA9IGlzRHluYW1pY1JvdXRlKHJvdXRlKSxcbiAgICAgIGludGVycG9sYXRlZFJvdXRlXG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzXG4gICAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAgICAgZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgfHxcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICAgICAgcXVlcnlcblxuICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZVxuICAgICAgaWYgKFxuICAgICAgICAhT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcykuZXZlcnkoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dXG4gICAgICAgICAgY29uc3QgcmVwZWF0ID0gZHluYW1pY0dyb3Vwc1twYXJhbV0ucmVwZWF0XG5cbiAgICAgICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzICYmXG4gICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9IGludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UoXG4gICAgICAgICAgICAgIGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWAsXG4gICAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICAgID8gdmFsdWUubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignLycpXG4gICAgICAgICAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXG4gICAgICAgICAgICApKVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgICkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cbiAgICAgICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAgICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXNEeW5hbWljXG4gICAgICA/IGludGVycG9sYXRlZFJvdXRlICYmIGdldEhyZWZGb3JTbHVnKGludGVycG9sYXRlZFJvdXRlKVxuICAgICAgOiBnZXRIcmVmRm9yU2x1Zyhyb3V0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzUGF0aCB0aGUgVVJMIGFzIHNob3duIGluIGJyb3dzZXIgKHZpcnR1YWwgcGF0aCk7IHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAqL1xuICBwcmVmZXRjaERhdGEoaHJlZiwgYXNQYXRoKSB7XG4gICAgY29uc3QgeyBwYXRobmFtZTogaHJlZlBhdGhuYW1lIH0gPSBwYXJzZShocmVmLCB0cnVlKVxuICAgIGNvbnN0IHJvdXRlID0gbm9ybWFsaXplUm91dGUoaHJlZlBhdGhuYW1lKVxuICAgIHJldHVybiB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QudGhlbihcbiAgICAgIChzLCBfZGF0YUhyZWYpID0+XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByb3V0ZSByZXF1aXJlcyBhIGRhdGEgZmlsZVxuICAgICAgICBzLmhhcyhyb3V0ZSkgJiZcbiAgICAgICAgLy8gVHJ5IHRvIGdlbmVyYXRlIGRhdGEgaHJlZiwgbm9vcCB3aGVuIGZhbHN5XG4gICAgICAgIChfZGF0YUhyZWYgPSB0aGlzLmdldERhdGFIcmVmKGhyZWYsIGFzUGF0aCkpICYmXG4gICAgICAgIC8vIG5vb3Agd2hlbiBkYXRhIGhhcyBhbHJlYWR5IGJlZW4gcHJlZmV0Y2hlZCAoZGVkdXBlKVxuICAgICAgICAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBgbGlua1tyZWw9XCIke3JlbFByZWZldGNofVwiXVtocmVmXj1cIiR7X2RhdGFIcmVmfVwiXWBcbiAgICAgICAgKSAmJlxuICAgICAgICAvLyBJbmplY3QgdGhlIGA8bGluayByZWw9cHJlZmV0Y2g+YCB0YWcgZm9yIGFib3ZlIGNvbXB1dGVkIGBocmVmYC5cbiAgICAgICAgYXBwZW5kTGluayhfZGF0YUhyZWYsIHJlbFByZWZldGNoLCAnZmV0Y2gnKVxuICAgIClcbiAgfVxuXG4gIGxvYWRQYWdlKHJvdXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZFBhZ2VTY3JpcHQocm91dGUpXG4gIH1cblxuICBsb2FkUGFnZVNjcmlwdChyb3V0ZSkge1xuICAgIHJvdXRlID0gbm9ybWFsaXplUm91dGUocm91dGUpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZmlyZSA9ICh7IGVycm9yLCBwYWdlLCBtb2QgfSkgPT4ge1xuICAgICAgICB0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5vZmYocm91dGUsIGZpcmUpXG4gICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRpbmdSb3V0ZXNbcm91dGVdXG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoeyBwYWdlLCBtb2QgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHBhZ2UsIGxldCdzIHVzZSBpdC5cbiAgICAgIGNvbnN0IGNhY2hlZFBhZ2UgPSB0aGlzLnBhZ2VDYWNoZVtyb3V0ZV1cbiAgICAgIGlmIChjYWNoZWRQYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IsIHBhZ2UsIG1vZCB9ID0gY2FjaGVkUGFnZVxuICAgICAgICBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHsgcGFnZSwgbW9kIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBSZWdpc3RlciBhIGxpc3RlbmVyIHRvIGdldCB0aGUgcGFnZVxuICAgICAgdGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMub24ocm91dGUsIGZpcmUpXG5cbiAgICAgIC8vIElmIHRoZSBwYWdlIGlzIGxvYWRpbmcgdmlhIFNTUiwgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgICAgLy8gcmF0aGVyIGRvd25sb2FkaW5nIGl0IGFnYWluLlxuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtkYXRhLW5leHQtcGFnZT1cIiR7cm91dGV9XCJdYCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5sb2FkaW5nUm91dGVzW3JvdXRlXSkge1xuICAgICAgICB0aGlzLmxvYWRpbmdSb3V0ZXNbcm91dGVdID0gdHJ1ZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0dSQU5VTEFSX0NIVU5LUykge1xuICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKHJvdXRlKS50aGVuKChkZXBzKSA9PiB7XG4gICAgICAgICAgICBkZXBzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC9cXC5qcyQvLnRlc3QoZCkgJiZcbiAgICAgICAgICAgICAgICAhZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyY149XCIke2R9XCJdYClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkU2NyaXB0KGQsIHJvdXRlLCBmYWxzZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgL1xcLmNzcyQvLnRlc3QoZCkgJiZcbiAgICAgICAgICAgICAgICAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl49XCIke2R9XCJdYClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kTGluayhkLCAnc3R5bGVzaGVldCcpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBoYW5kbGUgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgbm93LCB0aGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IGFuIHVuaGFuZGxlZCByZWplY3Rpb24uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMubG9hZFJvdXRlKHJvdXRlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2FkUm91dGUocm91dGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbG9hZFJvdXRlKHJvdXRlKSB7XG4gICAgcm91dGUgPSBub3JtYWxpemVSb3V0ZShyb3V0ZSlcbiAgICBsZXQgc2NyaXB0Um91dGUgPSByb3V0ZSA9PT0gJy8nID8gJy9pbmRleC5qcycgOiBgJHtyb3V0ZX0uanNgXG5cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICB0aGlzLmJ1aWxkSWRcbiAgICApfS9wYWdlcyR7ZW5jb2RlVVJJKHNjcmlwdFJvdXRlKX1gXG4gICAgdGhpcy5sb2FkU2NyaXB0KHVybCwgcm91dGUsIHRydWUpXG4gIH1cblxuICBsb2FkU2NyaXB0KHVybCwgcm91dGUsIGlzUGFnZSkge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQgJiYgaGFzTm9Nb2R1bGUpIHtcbiAgICAgIHNjcmlwdC50eXBlID0gJ21vZHVsZSdcbiAgICAgIC8vIE9ubHkgcGFnZSBidW5kbGUgc2NyaXB0cyBuZWVkIHRvIGhhdmUgLm1vZHVsZSBhZGRlZCB0byB1cmwsXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgYWxyZWFkeSBoYXZlIGl0IGFkZGVkIGR1cmluZyBidWlsZCBtYW5pZmVzdCBjcmVhdGlvblxuICAgICAgaWYgKGlzUGFnZSkgdXJsID0gdXJsLnJlcGxhY2UoL1xcLmpzJC8sICcubW9kdWxlLmpzJylcbiAgICB9XG4gICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5jcm9zc09yaWdpblxuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBFcnJvciBsb2FkaW5nIHNjcmlwdCAke3VybH1gKVxuICAgICAgZXJyb3IuY29kZSA9ICdQQUdFX0xPQURfRVJST1InXG4gICAgICB0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5lbWl0KHJvdXRlLCB7IGVycm9yIH0pXG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgaWYgY2FsbGVkIGJ5IHRoZSByb3V0ZSBjb2RlLlxuICByZWdpc3RlclBhZ2Uocm91dGUsIHJlZ0ZuKSB7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb2QgPSByZWdGbigpXG4gICAgICAgIGNvbnN0IHBhZ2VEYXRhID0geyBwYWdlOiBtb2QuZGVmYXVsdCB8fCBtb2QsIG1vZCB9XG4gICAgICAgIHRoaXMucGFnZUNhY2hlW3JvdXRlXSA9IHBhZ2VEYXRhXG4gICAgICAgIHRoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUsIHBhZ2VEYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYWdlQ2FjaGVbcm91dGVdID0geyBlcnJvciB9XG4gICAgICAgIHRoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUsIHsgZXJyb3IgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2FpdCBmb3Igd2VicGFjayB0byBiZWNvbWUgaWRsZSBpZiBpdCdzIG5vdC5cbiAgICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3B1bGwvMTUxMVxuICAgICAgaWYgKG1vZHVsZS5ob3QgJiYgbW9kdWxlLmhvdC5zdGF0dXMoKSAhPT0gJ2lkbGUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBXYWl0aW5nIGZvciB3ZWJwYWNrIHRvIGJlY29tZSBcImlkbGVcIiB0byBpbml0aWFsaXplIHRoZSBwYWdlOiBcIiR7cm91dGV9XCJgXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCBjaGVjayA9IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihjaGVjaylcbiAgICAgICAgICAgIHJlZ2lzdGVyKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlLmhvdC5zdGF0dXMoY2hlY2spXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZXBlbmRlbmN5XVxuICAgKi9cbiAgcHJlZmV0Y2gocm91dGUsIGlzRGVwZW5kZW5jeSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcbiAgICAvLyBMaWNlbnNlOiBBcGFjaGUgMi4wXG4gICAgbGV0IGNuXG4gICAgaWYgKChjbiA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSkge1xuICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdXJsXG4gICAgaWYgKGlzRGVwZW5kZW5jeSkge1xuICAgICAgdXJsID0gcm91dGVcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGUgPSBub3JtYWxpemVSb3V0ZShyb3V0ZSlcblxuICAgICAgbGV0IHNjcmlwdFJvdXRlID0gYCR7cm91dGUgPT09ICcvJyA/ICcvaW5kZXgnIDogcm91dGV9LmpzYFxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQgJiYgaGFzTm9Nb2R1bGUpIHtcbiAgICAgICAgc2NyaXB0Um91dGUgPSBzY3JpcHRSb3V0ZS5yZXBsYWNlKC9cXC5qcyQvLCAnLm1vZHVsZS5qcycpXG4gICAgICB9XG5cbiAgICAgIHVybCA9IGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0L3N0YXRpYy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgdGhpcy5idWlsZElkXG4gICAgICApfS9wYWdlcyR7ZW5jb2RlVVJJKHNjcmlwdFJvdXRlKX1gXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYGxpbmtbcmVsPVwiJHtyZWxQcmVmZXRjaH1cIl1baHJlZl49XCIke3VybH1cIl0sIHNjcmlwdFtkYXRhLW5leHQtcGFnZT1cIiR7cm91dGV9XCJdYFxuICAgICAgKVxuICAgICAgICA/IFtdXG4gICAgICAgIDogW1xuICAgICAgICAgICAgYXBwZW5kTGluayhcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICByZWxQcmVmZXRjaCxcbiAgICAgICAgICAgICAgdXJsLm1hdGNoKC9cXC5jc3MkLykgPyAnc3R5bGUnIDogJ3NjcmlwdCdcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTICYmXG4gICAgICAgICAgICAgICFpc0RlcGVuZGVuY3kgJiZcbiAgICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMocm91dGUpLnRoZW4oKHVybHMpID0+XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwodXJscy5tYXAoKHVybCkgPT4gdGhpcy5wcmVmZXRjaCh1cmwsIHRydWUpKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICBdXG4gICAgKS50aGVuKFxuICAgICAgLy8gZG8gbm90IHJldHVybiBhbnkgZGF0YVxuICAgICAgKCkgPT4ge30sXG4gICAgICAvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuICAgICAgKCkgPT4ge31cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IGdldENMUywgZ2V0RklELCBnZXRGQ1AsIGdldExDUCwgZ2V0VFRGQiB9IGZyb20gJ3dlYi12aXRhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IChvblBlcmZFbnRyeSkgPT4ge1xuICBnZXRDTFMob25QZXJmRW50cnkpXG4gIGdldEZJRChvblBlcmZFbnRyeSlcbiAgZ2V0RkNQKG9uUGVyZkVudHJ5KVxuICBnZXRMQ1Aob25QZXJmRW50cnkpXG4gIGdldFRURkIob25QZXJmRW50cnkpXG59XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbih7fSwgX3JvdXRlcltwcm9wZXJ0eV0pIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9e307ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhyKXtpZih0W3JdKXtyZXR1cm4gdFtyXS5leHBvcnRzfXZhciBuPXRbcl09e2k6cixsOmZhbHNlLGV4cG9ydHM6e319O2Vbcl0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyk7bi5sPXRydWU7cmV0dXJuIG4uZXhwb3J0c31fX3dlYnBhY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtmdW5jdGlvbiBzdGFydHVwKCl7cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oODU1KX1yZXR1cm4gc3RhcnR1cCgpfSh7ODQ5OmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz0oKHtvbmx5Rmlyc3Q6ZT1mYWxzZX09e30pPT57Y29uc3Qgcj1bXCJbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86W2EtekEtWlxcXFxkXSooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpO3JldHVybiBuZXcgUmVnRXhwKHIsZT91bmRlZmluZWQ6XCJnXCIpfSl9LDg1NTpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgbj10KDg0OSk7ZS5leHBvcnRzPShlPT50eXBlb2YgZT09PVwic3RyaW5nXCI/ZS5yZXBsYWNlKG4oKSxcIlwiKTplKX19KTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBIZWFkTWFuYWdlckNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIEphc29uIE1pbGxlciAoaHR0cHM6Ly9qYXNvbmZvcm1hdC5jb20vKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvdjEuMS4zL3NyYy9pbmRleC5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCBmb3IgdGhlIG5lZWRzIG9mIHRoaXMgc2NyaXB0XG4vLyBTZWUgdGhlIExJQ0VOU0UgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZVxuXG50eXBlIEhhbmRsZXIgPSAoLi4uZXZ0czogYW55W10pID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgTWl0dEVtaXR0ZXIgPSB7XG4gIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKTogdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KCk6IE1pdHRFbWl0dGVyIHtcbiAgY29uc3QgYWxsOiB7IFtzOiBzdHJpbmddOiBIYW5kbGVyW10gfSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICByZXR1cm4ge1xuICAgIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgOyhhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICBpZiAoYWxsW3R5cGVdKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgOyhhbGxbdHlwZV0gfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyOiBIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoLi4uZXZ0cylcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXI+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iLCIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHBhcnNlLCBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZVBhdGgpICE9PSAwID8gYmFzZVBhdGggKyBwYXRoIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlUGF0aCkgPT09IDBcbiAgICA/IHBhdGguc3Vic3RyKGJhc2VQYXRoLmxlbmd0aCkgfHwgJy8nXG4gICAgOiBwYXRoXG59XG5cbmZ1bmN0aW9uIHRvUm91dGUocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLydcbn1cblxuY29uc3QgcHJlcGFyZVJvdXRlID0gKHBhdGg6IHN0cmluZykgPT5cbiAgdG9Sb3V0ZSghcGF0aCB8fCBwYXRoID09PSAnLycgPyAnL2luZGV4JyA6IHBhdGgpXG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbnR5cGUgQ29tcG9uZW50UmVzID0geyBwYWdlOiBDb21wb25lbnRUeXBlOyBtb2Q6IGFueSB9XG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxufVxuXG50eXBlIFJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogYW55XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbnR5cGUgU3Vic2NyaXB0aW9uID0gKGRhdGE6IFJvdXRlSW5mbywgQXBwPzogQ29tcG9uZW50VHlwZSkgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IGFueSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5IHwgbnVsbCxcbiAgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4sXG4gIGNiPzogKC4uLmFyZ3M6IGFueSkgPT4gYW55XG4pIHtcbiAgbGV0IGF0dGVtcHRzID0gaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMVxuICBmdW5jdGlvbiBnZXRSZXNwb25zZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBmZXRjaChcbiAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX19ORVhUX0RBVEFfX1xuICAgICAgICAgIGAvX25leHQvZGF0YS8ke19fTkVYVF9EQVRBX18uYnVpbGRJZH0ke2RlbEJhc2VQYXRoKHBhdGhuYW1lKX0uanNvbmBcbiAgICAgICAgKSxcbiAgICAgICAgcXVlcnksXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICB9XG4gICAgKS50aGVuKChyZXMpID0+IHtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGlmICgtLWF0dGVtcHRzID4gMCAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgIHJldHVybiBnZXRSZXNwb25zZSgpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5qc29uKClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGdldFJlc3BvbnNlKClcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgcmV0dXJuIGNiID8gY2IoZGF0YSkgOiBkYXRhXG4gICAgfSlcbiAgICAuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAgIC8vIGxvb3AuXG4gICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgIDsoZXJyIGFzIGFueSkuY29kZSA9ICdQQUdFX0xPQURfRVJST1InXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQ29tcG9uZW50VHlwZVxuICAgICAgd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0geyBDb21wb25lbnQ6IEFwcCB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIHRoaXMuYXNQYXRoID1cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBfX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBhc1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyBAZGVwcmVjYXRlZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBldmVuIHRob3VnaCBpdCdzIGEgcHJpdmF0ZSBtZXRob2QuXG4gIHN0YXRpYyBfcmV3cml0ZVVybEZvck5leHRFeHBvcnQodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgIC5yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydFxuICAgICAgcmV0dXJuIHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0KHVybClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGlmICghZS5zdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAoXG4gICAgICBlLnN0YXRlICYmXG4gICAgICB0aGlzLmlzU3NyICYmXG4gICAgICBlLnN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCAmJlxuICAgICAgcGFyc2UoZS5zdGF0ZS51cmwpLnBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoZS5zdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucyB9ID0gZS5zdGF0ZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGFzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Bwb3BzdGF0ZWAgZXZlbnQgdHJpZ2dlcmVkIGJ1dCBgZXZlbnQuc3RhdGVgIGRpZCBub3QgaGF2ZSBgdXJsYCBvciBgYXNgIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3BvcHN0YXRlLXN0YXRlLWVtcHR5J1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgdXBkYXRlKHJvdXRlOiBzdHJpbmcsIG1vZDogYW55KSB7XG4gICAgY29uc3QgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlID0gbW9kLmRlZmF1bHQgfHwgbW9kXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwZGF0ZSB1bmF2YWlsYWJsZSByb3V0ZTogJHtyb3V0ZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0RhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBDb21wb25lbnQsXG4gICAgICBfX05fU1NHOiBtb2QuX19OX1NTRyxcbiAgICAgIF9fTl9TU1A6IG1vZC5fX05fU1NQLFxuICAgIH0pXG4gICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IG5ld0RhdGFcblxuICAgIC8vIHBhZ2VzL19hcHAuanMgdXBkYXRlZFxuICAgIGlmIChyb3V0ZSA9PT0gJy9fYXBwJykge1xuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHJvdXRlID09PSB0aGlzLnJvdXRlKSB7XG4gICAgICB0aGlzLm5vdGlmeShuZXdEYXRhKVxuICAgIH1cbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzOiBVcmwgPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICBfdXJsOiBVcmwsXG4gICAgX2FzOiBVcmwsXG4gICAgb3B0aW9uczogYW55XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnMuX2gpIHtcbiAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICBpZiAoU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgICBsZXQgdXJsID0gdHlwZW9mIF91cmwgPT09ICdvYmplY3QnID8gZm9ybWF0V2l0aFZhbGlkYXRpb24oX3VybCkgOiBfdXJsXG4gICAgICBsZXQgYXMgPSB0eXBlb2YgX2FzID09PSAnb2JqZWN0JyA/IGZvcm1hdFdpdGhWYWxpZGF0aW9uKF9hcykgOiBfYXNcblxuICAgICAgdXJsID0gYWRkQmFzZVBhdGgodXJsKVxuICAgICAgYXMgPSBhZGRCYXNlUGF0aChhcylcblxuICAgICAgLy8gQWRkIHRoZSBlbmRpbmcgc2xhc2ggdG8gdGhlIHBhdGhzLiBTbywgd2UgY2FuIHNlcnZlIHRoZVxuICAgICAgLy8gXCI8cGFnZT4vaW5kZXguaHRtbFwiIGRpcmVjdGx5IGZvciB0aGUgU1NSIHBhZ2UuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUE9SVF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgaWYgKF9fTkVYVF9EQVRBX18ubmV4dEV4cG9ydCkge1xuICAgICAgICAgIGFzID0gcmV3cml0ZVVybEZvck5leHRFeHBvcnQoYXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQoYXMpXG5cbiAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgaWYgKCFvcHRpb25zLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKSkge1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcylcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcylcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIHByb3RvY29sIH0gPSBwYXJzZSh1cmwsIHRydWUpXG5cbiAgICAgIGlmICghcGF0aG5hbWUgfHwgcHJvdG9jb2wpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBocmVmIHBhc3NlZCB0byByb3V0ZXI6ICR7dXJsfSBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbnZhbGlkLWhyZWYtcGFzc2VkYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgIGlmICghdGhpcy51cmxJc05ldyhhcykpIHtcbiAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGUgPSB0b1JvdXRlKHBhdGhuYW1lKVxuICAgICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSBwYXJzZShhcylcbiAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgICtcbiAgICAgICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2luY29tcGF0aWJsZS1ocmVmLWFzYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcylcblxuICAgICAgLy8gSWYgc2hhbGxvdyBpcyB0cnVlIGFuZCB0aGUgcm91dGUgZXhpc3RzIGluIHRoZSByb3V0ZXIgY2FjaGUgd2UgcmV1c2UgdGhlIHByZXZpb3VzIHJlc3VsdFxuICAgICAgdGhpcy5nZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHNoYWxsb3cpLnRoZW4oXG4gICAgICAgIChyb3V0ZUluZm8pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSByb3V0ZUluZm9cblxuICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzKVxuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcENvbXA6IGFueSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnRcbiAgICAgICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICAgICAhKHJvdXRlSW5mby5Db21wb25lbnQgYXMgYW55KS5nZXRJbml0aWFsUHJvcHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVJbmZvKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgYXMpXG4gICAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByZWplY3RcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAnJyxcbiAgICAgICAgYXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxSb3V0ZUluZm8+IHtcbiAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHNoYWxsb3cgcm91dGUgdHJhbnNpdGlvbiBwb3NzaWJsZVxuICAgIC8vIElmIHRoZSByb3V0ZSBpcyBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4uXG4gICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJvdXRlSW5mbylcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChcbiAgICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICAgICkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ1BBR0VfTE9BRF9FUlJPUicgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgLy8gU28sIHdlIG5lZWQgdG8gbWFyayBpdCBhcyBhIGNhbmNlbGxlZCBlcnJvciBhbmQgc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVE9ETzogZml4IHRoZSBjb250cm9sIGZsb3cgaGVyZVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IGVycm9yOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcGFnZTogQ29tcG9uZW50IH0gPSByZXNcbiAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvOiBSb3V0ZUluZm8gPSB7IENvbXBvbmVudCwgZXJyIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KS50aGVuKFxuICAgICAgICAgICAgICAgICAgKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvciA9IGVyclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJvdXRlSW5mbylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAoZ2lwRXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsXG4gICAgICAgICAgICAgICAgICAgICAgZ2lwRXJyXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yID0gZXJyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm91dGVJbmZvKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSkgYXMgUHJvbWlzZTxSb3V0ZUluZm8+XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGhhbmRsZUVycm9yKGVyciwgdHJ1ZSkpXG4gICAgICAgIClcbiAgICAgIH0pIGFzIFByb21pc2U8Um91dGVJbmZvPlxuICAgIH1cblxuICAgIHJldHVybiAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGNhY2hlZFJvdXRlSW5mbykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShjYWNoZWRSb3V0ZUluZm8pXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oXG4gICAgICAgIChyZXMpID0+XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pLFxuICAgICAgICByZWplY3RcbiAgICAgIClcbiAgICB9KSBhcyBQcm9taXNlPFJvdXRlSW5mbz4pXG4gICAgICAudGhlbigocm91dGVJbmZvOiBSb3V0ZUluZm8pID0+IHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGF0YTxSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgICAgX19OX1NTR1xuICAgICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGFzKVxuICAgICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoYXMpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICAgIClcbiAgICAgICAgKS50aGVuKChwcm9wcykgPT4ge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goaGFuZGxlRXJyb3IpXG4gIH1cblxuICBzZXQoXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBSb3V0ZUluZm9cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2VcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZVxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgaWYgKGhhc2ggPT09ICcnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcHJvdG9jb2wgfSA9IHBhcnNlKHVybClcblxuICAgICAgaWYgKCFwYXRobmFtZSB8fCBwcm90b2NvbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIHJvdXRlcjogJHt1cmx9IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtaHJlZi1wYXNzZWRgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvdXRlID0gZGVsQmFzZVBhdGgodG9Sb3V0ZShwYXRobmFtZSkpXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucGFnZUxvYWRlci5wcmVmZXRjaERhdGEodXJsLCBkZWxCYXNlUGF0aChhc1BhdGgpKSxcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgICAgXSkudGhlbigoKSA9PiByZXNvbHZlKCksIHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Q29tcG9uZW50UmVzPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG4gICAgcm91dGUgPSBkZWxCYXNlUGF0aChyb3V0ZSlcblxuICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U3RhdGljRGF0YSA9IChhc1BhdGg6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUocGFyc2UoYXNQYXRoKS5wYXRobmFtZSEpXG5cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1twYXRobmFtZV1cbiAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW3BhdGhuYW1lXSlcbiAgICAgIDogZmV0Y2hOZXh0RGF0YShcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRoaXMuaXNTc3IsXG4gICAgICAgICAgKGRhdGEpID0+ICh0aGlzLnNkY1twYXRobmFtZV0gPSBkYXRhKVxuICAgICAgICApXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YSA9IChhc1BhdGg6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZShhc1BhdGgsIHRydWUpXG4gICAgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUocGF0aG5hbWUhKVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKHBhdGhuYW1lLCBxdWVyeSwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJylcbiAgICAgIDsoZSBhcyBhbnkpLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGUsIGFzKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KGRhdGE6IFJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50KVxuICB9XG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogeyBwb3M6IG51bWJlcjsgcmVwZWF0OiBib29sZWFuIH0gfVxufSB7XG4gIC8vIEVzY2FwZSBhbGwgY2hhcmFjdGVycyB0aGF0IGNvdWxkIGJlIGNvbnNpZGVyZWQgUmVnRXhcbiAgY29uc3QgZXNjYXBlZFJvdXRlID0gZXNjYXBlUmVnZXgobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuXG4gIGNvbnN0IGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiB7IHBvczogbnVtYmVyOyByZXBlYXQ6IGJvb2xlYW4gfSB9ID0ge31cbiAgbGV0IGdyb3VwSW5kZXggPSAxXG5cbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gZXNjYXBlZFJvdXRlLnJlcGxhY2UoXG4gICAgL1xcL1xcXFxcXFsoW14vXSs/KVxcXFxcXF0oPz1cXC98JCkvZyxcbiAgICAoXywgJDEpID0+IHtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSAvXlxcXFxcXFsuKlxcXFxcXF0kLy50ZXN0KCQxKVxuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgJDEgPSAkMS5zbGljZSgyLCAtMilcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2F0Y2hBbGwgPSAvXihcXFxcXFwuKXszfS8udGVzdCgkMSlcbiAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICQxID0gJDEuc2xpY2UoNilcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1tcbiAgICAgICAgJDFcbiAgICAgICAgICAvLyBVbi1lc2NhcGUga2V5XG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwoW3xcXFxce30oKVtcXF1eJCsqPy4tXSkvZywgJyQxJylcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgXSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdDogaXNDYXRjaEFsbCB9XG4gICAgICByZXR1cm4gaXNDYXRjaEFsbCA/IChpc09wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgfVxuICApXG5cbiAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBlc2NhcGVkUm91dGUucmVwbGFjZShcbiAgICAgIC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csXG4gICAgICAoXywgJDEpID0+IHtcbiAgICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IC9eKFxcXFxcXC4pezN9Ly50ZXN0KCQxKVxuICAgICAgICBjb25zdCBrZXkgPSAkMVxuICAgICAgICAgIC8vIFVuLWVzY2FwZSBrZXlcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXChbfFxcXFx7fSgpW1xcXV4kKyo/Li1dKS9nLCAnJDEnKVxuICAgICAgICAgIC5yZXBsYWNlKC9eXFwuezN9LywgJycpXG5cbiAgICAgICAgcmV0dXJuIGlzQ2F0Y2hBbGxcbiAgICAgICAgICA/IGAvKD88JHtlc2NhcGVSZWdleChrZXkpfT4uKz8pYFxuICAgICAgICAgIDogYC8oPzwke2VzY2FwZVJlZ2V4KGtleSl9PlteL10rPylgXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cCgnXicgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyAnKD86Lyk/JCcsICdpJyksXG4gICAgZ3JvdXBzLFxuICAgIG5hbWVkUmVnZXg6IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlXG4gICAgICA/IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYFxuICAgICAgOiB1bmRlZmluZWQsXG4gIH1cbn1cbiIsImxldCBydW50aW1lQ29uZmlnOiBhbnlcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuICByZXR1cm4gcnVudGltZUNvbmZpZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29uZmlnKGNvbmZpZ1ZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgcnVudGltZUNvbmZpZyA9IGNvbmZpZ1ZhbHVlXG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBmb3JtYXQsIFVSTEZvcm1hdE9wdGlvbnMsIFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnLi4vLi4vbGliL2xvYWQtZW52LWNvbmZpZydcblxuLyoqXG4gKiBUeXBlcyB1c2VkIGJ5IGJvdGggbmV4dCBhbmQgbmV4dC1zZXJ2ZXJcbiAqL1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4gPSBDb21wb25lbnRUeXBlPFA+ICYge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW5pdGlhbCBwYWdlIGxvYWQgZGF0YSBwb3B1bGF0aW9uLiBEYXRhIHJldHVybmVkIGZyb20gYGdldEluaXRpYWxQcm9wc2AgaXMgc2VyaWFsaXplZCB3aGVuIHNlcnZlciByZW5kZXJlZC5cbiAgICogTWFrZSBzdXJlIHRvIHJldHVybiBwbGFpbiBgT2JqZWN0YCB3aXRob3V0IHVzaW5nIGBEYXRlYCwgYE1hcGAsIGBTZXRgLlxuICAgKiBAcGFyYW0gY3R4IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IEMpOiBJUCB8IFByb21pc2U8SVA+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50VHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBEb2N1bWVudENvbnRleHQsXG4gIERvY3VtZW50SW5pdGlhbFByb3BzLFxuICBEb2N1bWVudFByb3BzXG4+ICYge1xuICByZW5kZXJEb2N1bWVudChcbiAgICBEb2N1bWVudDogRG9jdW1lbnRUeXBlLFxuICAgIHByb3BzOiBEb2N1bWVudFByb3BzXG4gICk6IFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBBcHBUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBBcHBJbml0aWFsUHJvcHMsXG4gIEFwcFByb3BzVHlwZVxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gUmVuZGVyUGFnZVJlc3VsdCB8IFByb21pc2U8UmVuZGVyUGFnZVJlc3VsdD5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogYW55XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgaW50ZXJmYWNlLW5hbWVcbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8UiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyPiA9IHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQ+XG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG4gIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gIHJvdXRlcjogUlxufVxuXG5leHBvcnQgdHlwZSBBcHBJbml0aWFsUHJvcHMgPSB7XG4gIHBhZ2VQcm9wczogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyLFxuICBQID0ge31cbj4gPSBBcHBJbml0aWFsUHJvcHMgJiB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0LCBhbnksIFA+XG4gIHJvdXRlcjogUlxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudENvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQgJiB7XG4gIHJlbmRlclBhZ2U6IFJlbmRlclBhZ2Vcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IFJlYWN0LlJlYWN0RnJhZ21lbnRcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRQcm9wcyA9IERvY3VtZW50SW5pdGlhbFByb3BzICYge1xuICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgZGFuZ2Vyb3VzQXNQYXRoOiBzdHJpbmdcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgc3RhdGljTWFya3VwOiBib29sZWFuXG4gIGlzRGV2ZWxvcG1lbnQ6IGJvb2xlYW5cbiAgZGV2RmlsZXM6IHN0cmluZ1tdXG4gIGZpbGVzOiBzdHJpbmdbXVxuICBsb3dQcmlvcml0eUZpbGVzOiBzdHJpbmdbXVxuICBwb2x5ZmlsbEZpbGVzOiBzdHJpbmdbXVxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGh0bWxQcm9wczogYW55XG4gIGJvZHlUYWdzOiBhbnlbXVxuICBoZWFkVGFnczogYW55W11cbiAgdW5zdGFibGVfcnVudGltZUpTPzogZmFsc2Vcbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgdXJsOiBVcmxPYmplY3QsXG4gIG9wdGlvbnM/OiBVUkxGb3JtYXRPcHRpb25zXG4pOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0KHVybCBhcyBVUkwsIG9wdGlvbnMpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCIvKiFcclxuICogUGxhdGZvcm0uanMgPGh0dHBzOi8vbXRocy5iZS9wbGF0Zm9ybT5cclxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiBCZW5qYW1pbiBUYW4gPGh0dHBzOi8vZGVtb25lYXV4LmdpdGh1Yi5pby8+XHJcbiAqIENvcHlyaWdodCAyMDExLTIwMTMgSm9obi1EYXZpZCBEYWx0b24gPGh0dHA6Ly9hbGx5b3VjYW5sZWV0LmNvbS8+XHJcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9tdGhzLmJlL21pdD5cclxuICovXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cclxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XHJcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxyXG4gICAgJ29iamVjdCc6IHRydWVcclxuICB9O1xyXG5cclxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cclxuICB2YXIgcm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpIHx8IHRoaXM7XHJcblxyXG4gIC8qKiBCYWNrdXAgcG9zc2libGUgZ2xvYmFsIG9iamVjdC4gKi9cclxuICB2YXIgb2xkUm9vdCA9IHJvb3Q7XHJcblxyXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXHJcbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHM7XHJcblxyXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cclxuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YC4gKi9cclxuICB2YXIgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XHJcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkpIHtcclxuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCBhcyB0aGUgbWF4aW11bSBsZW5ndGggb2YgYW4gYXJyYXktbGlrZSBvYmplY3QuXHJcbiAgICogU2VlIHRoZSBbRVM2IHNwZWNdKGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxyXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICovXHJcbiAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcclxuXHJcbiAgLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBkZXRlY3QgT3BlcmEuICovXHJcbiAgdmFyIHJlT3BlcmEgPSAvXFxiT3BlcmEvO1xyXG5cclxuICAvKiogUG9zc2libGUgZ2xvYmFsIG9iamVjdC4gKi9cclxuICB2YXIgdGhpc0JpbmRpbmcgPSB0aGlzO1xyXG5cclxuICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGNoZWNrIGZvciBvd24gcHJvcGVydGllcyBvZiBhbiBvYmplY3QuICovXHJcbiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XHJcblxyXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIHZhbHVlcy4gKi9cclxuICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8qKlxyXG4gICAqIENhcGl0YWxpemVzIGEgc3RyaW5nIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XHJcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nKTtcclxuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gY2xlYW4gdXAgdGhlIE9TIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcyBUaGUgT1MgbmFtZSB0byBjbGVhbiB1cC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIEEgYFJlZ0V4cGAgcGF0dGVybiBtYXRjaGluZyB0aGUgT1MgbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXSBBIGxhYmVsIGZvciB0aGUgT1MuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xlYW51cE9TKG9zLCBwYXR0ZXJuLCBsYWJlbCkge1xyXG4gICAgLy8gUGxhdGZvcm0gdG9rZW5zIGFyZSBkZWZpbmVkIGF0OlxyXG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTAzKFZTLjg1KS5hc3B4XHJcbiAgICAvLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDA4MTEyMjA1Mzk1MC9odHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAnMTAuMCc6ICcxMCcsXHJcbiAgICAgICc2LjQnOiAgJzEwIFRlY2huaWNhbCBQcmV2aWV3JyxcclxuICAgICAgJzYuMyc6ICAnOC4xJyxcclxuICAgICAgJzYuMic6ICAnOCcsXHJcbiAgICAgICc2LjEnOiAgJ1NlcnZlciAyMDA4IFIyIC8gNycsXHJcbiAgICAgICc2LjAnOiAgJ1NlcnZlciAyMDA4IC8gVmlzdGEnLFxyXG4gICAgICAnNS4yJzogICdTZXJ2ZXIgMjAwMyAvIFhQIDY0LWJpdCcsXHJcbiAgICAgICc1LjEnOiAgJ1hQJyxcclxuICAgICAgJzUuMDEnOiAnMjAwMCBTUDEnLFxyXG4gICAgICAnNS4wJzogICcyMDAwJyxcclxuICAgICAgJzQuMCc6ICAnTlQnLFxyXG4gICAgICAnNC45MCc6ICdNRSdcclxuICAgIH07XHJcbiAgICAvLyBEZXRlY3QgV2luZG93cyB2ZXJzaW9uIGZyb20gcGxhdGZvcm0gdG9rZW5zLlxyXG4gICAgaWYgKHBhdHRlcm4gJiYgbGFiZWwgJiYgL15XaW4vaS50ZXN0KG9zKSAmJiAhL15XaW5kb3dzIFBob25lIC9pLnRlc3Qob3MpICYmXHJcbiAgICAgICAgKGRhdGEgPSBkYXRhWy9bXFxkLl0rJC8uZXhlYyhvcyldKSkge1xyXG4gICAgICBvcyA9ICdXaW5kb3dzICcgKyBkYXRhO1xyXG4gICAgfVxyXG4gICAgLy8gQ29ycmVjdCBjaGFyYWN0ZXIgY2FzZSBhbmQgY2xlYW51cCBzdHJpbmcuXHJcbiAgICBvcyA9IFN0cmluZyhvcyk7XHJcblxyXG4gICAgaWYgKHBhdHRlcm4gJiYgbGFiZWwpIHtcclxuICAgICAgb3MgPSBvcy5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBsYWJlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3MgPSBmb3JtYXQoXHJcbiAgICAgIG9zLnJlcGxhY2UoLyBjZSQvaSwgJyBDRScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYmhwdy9pLCAnd2ViJylcclxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjaW50b3NoXFxiLywgJ01hYyBPUycpXHJcbiAgICAgICAgLnJlcGxhY2UoL19Qb3dlclBDXFxiL2ksICcgT1MnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGIoT1MgWCkgW14gXFxkXSsvaSwgJyQxJylcclxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjIChPUyBYKVxcYi8sICckMScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLyhcXGQpLywgJyAkMScpXHJcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJy4nKVxyXG4gICAgICAgIC5yZXBsYWNlKC8oPzogQmVQQ3xbIC5dKmZjWyBcXGQuXSspJC9pLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvXFxieDg2XFwuNjRcXGIvZ2ksICd4ODZfNjQnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGIoV2luZG93cyBQaG9uZSkgT1NcXGIvLCAnJDEnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGIoQ2hyb21lIE9TIFxcdyspIFtcXGQuXStcXGIvLCAnJDEnKVxyXG4gICAgICAgIC5zcGxpdCgnIG9uICcpWzBdXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBvcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGl0ZXJhdGlvbiB1dGlsaXR5IGZvciBhcnJheXMgYW5kIG9iamVjdHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID8gb2JqZWN0Lmxlbmd0aCA6IDA7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gLTEgJiYgbGVuZ3RoIDw9IG1heFNhZmVJbnRlZ2VyKSB7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2luZGV4XSwgaW5kZXgsIG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvck93bihvYmplY3QsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaW0gYW5kIGNvbmRpdGlvbmFsbHkgY2FwaXRhbGl6ZSBzdHJpbmcgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHJpbmcpIHtcclxuICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcclxuICAgIHJldHVybiAvXig/OndlYk9TfGkoPzpPU3xQKSkvLnRlc3Qoc3RyaW5nKVxyXG4gICAgICA/IHN0cmluZ1xyXG4gICAgICA6IGNhcGl0YWxpemUoc3RyaW5nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGVzIG92ZXIgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMsIGV4ZWN1dGluZyB0aGUgYGNhbGxiYWNrYCBmb3IgZWFjaC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgcGVyIG93biBwcm9wZXJ0eS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcclxuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBgW1tDbGFzc11dYCBvZiBhIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYFtbQ2xhc3NdXWAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0Q2xhc3NPZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09IG51bGxcclxuICAgICAgPyBjYXBpdGFsaXplKHZhbHVlKVxyXG4gICAgICA6IHRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvc3Qgb2JqZWN0cyBjYW4gcmV0dXJuIHR5cGUgdmFsdWVzIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIHRoZWlyIGFjdHVhbFxyXG4gICAqIGRhdGEgdHlwZS4gVGhlIG9iamVjdHMgd2UgYXJlIGNvbmNlcm5lZCB3aXRoIHVzdWFsbHkgcmV0dXJuIG5vbi1wcmltaXRpdmVcclxuICAgKiB0eXBlcyBvZiBcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCIsIG9yIFwidW5rbm93blwiLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb3duZXIgb2YgdGhlIHByb3BlcnR5LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIG5vbi1wcmltaXRpdmUsIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpc0hvc3RUeXBlKG9iamVjdCwgcHJvcGVydHkpIHtcclxuICAgIHZhciB0eXBlID0gb2JqZWN0ICE9IG51bGwgPyB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSA6ICdudW1iZXInO1xyXG4gICAgcmV0dXJuICEvXig/OmJvb2xlYW58bnVtYmVyfHN0cmluZ3x1bmRlZmluZWQpJC8udGVzdCh0eXBlKSAmJlxyXG4gICAgICAodHlwZSA9PSAnb2JqZWN0JyA/ICEhb2JqZWN0W3Byb3BlcnR5XSA6IHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGFyZXMgYSBzdHJpbmcgZm9yIHVzZSBpbiBhIGBSZWdFeHBgIGJ5IG1ha2luZyBoeXBoZW5zIGFuZCBzcGFjZXMgb3B0aW9uYWwuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBxdWFsaWZ5LlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBxdWFsaWZpZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHF1YWxpZnkoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvKFsgLV0pKD8hJCkvZywgJyQxPycpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBiYXJlLWJvbmVzIGBBcnJheSNyZWR1Y2VgIGxpa2UgdXRpbGl0eSBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXHJcbiAgICogQHJldHVybnMgeyp9IFRoZSBhY2N1bXVsYXRlZCByZXN1bHQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGFjY3VtdWxhdG9yID0gbnVsbDtcclxuICAgIGVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGFycmF5KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gYSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cclxuICAgKi9cclxuICBmdW5jdGlvbiB0cmltKHN0cmluZykge1xyXG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL14gK3wgKyQvZywgJycpO1xyXG4gIH1cclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgcGxhdGZvcm0gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbdWE9bmF2aWdhdG9yLnVzZXJBZ2VudF0gVGhlIHVzZXIgYWdlbnQgc3RyaW5nIG9yXHJcbiAgICogIGNvbnRleHQgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhdGZvcm0gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBhcnNlKHVhKSB7XHJcblxyXG4gICAgLyoqIFRoZSBlbnZpcm9ubWVudCBjb250ZXh0IG9iamVjdC4gKi9cclxuICAgIHZhciBjb250ZXh0ID0gcm9vdDtcclxuXHJcbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYSBjdXN0b20gY29udGV4dCBpcyBwcm92aWRlZC4gKi9cclxuICAgIHZhciBpc0N1c3RvbUNvbnRleHQgPSB1YSAmJiB0eXBlb2YgdWEgPT0gJ29iamVjdCcgJiYgZ2V0Q2xhc3NPZih1YSkgIT0gJ1N0cmluZyc7XHJcblxyXG4gICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cclxuICAgIGlmIChpc0N1c3RvbUNvbnRleHQpIHtcclxuICAgICAgY29udGV4dCA9IHVhO1xyXG4gICAgICB1YSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEJyb3dzZXIgbmF2aWdhdG9yIG9iamVjdC4gKi9cclxuICAgIHZhciBuYXYgPSBjb250ZXh0Lm5hdmlnYXRvciB8fCB7fTtcclxuXHJcbiAgICAvKiogQnJvd3NlciB1c2VyIGFnZW50IHN0cmluZy4gKi9cclxuICAgIHZhciB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50IHx8ICcnO1xyXG5cclxuICAgIHVhIHx8ICh1YSA9IHVzZXJBZ2VudCk7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZmxhZyB3aGVuIGB0aGlzQmluZGluZ2AgaXMgdGhlIFtNb2R1bGVTY29wZV0uICovXHJcbiAgICB2YXIgaXNNb2R1bGVTY29wZSA9IGlzQ3VzdG9tQ29udGV4dCB8fCB0aGlzQmluZGluZyA9PSBvbGRSb290O1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBicm93c2VyIGlzIGxpa2UgQ2hyb21lLiAqL1xyXG4gICAgdmFyIGxpa2VDaHJvbWUgPSBpc0N1c3RvbUNvbnRleHRcclxuICAgICAgPyAhIW5hdi5saWtlQ2hyb21lXHJcbiAgICAgIDogL1xcYkNocm9tZVxcYi8udGVzdCh1YSkgJiYgIS9pbnRlcm5hbHxcXG4vaS50ZXN0KHRvU3RyaW5nLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBgW1tDbGFzc11dYCB2YWx1ZSBzaG9ydGN1dHMuICovXHJcbiAgICB2YXIgb2JqZWN0Q2xhc3MgPSAnT2JqZWN0JyxcclxuICAgICAgICBhaXJSdW50aW1lQ2xhc3MgPSBpc0N1c3RvbUNvbnRleHQgPyBvYmplY3RDbGFzcyA6ICdTY3JpcHRCcmlkZ2luZ1Byb3h5T2JqZWN0JyxcclxuICAgICAgICBlbnZpcm9DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ0Vudmlyb25tZW50JyxcclxuICAgICAgICBqYXZhQ2xhc3MgPSAoaXNDdXN0b21Db250ZXh0ICYmIGNvbnRleHQuamF2YSkgPyAnSmF2YVBhY2thZ2UnIDogZ2V0Q2xhc3NPZihjb250ZXh0LmphdmEpLFxyXG4gICAgICAgIHBoYW50b21DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1J1bnRpbWVPYmplY3QnO1xyXG5cclxuICAgIC8qKiBEZXRlY3QgSmF2YSBlbnZpcm9ubWVudHMuICovXHJcbiAgICB2YXIgamF2YSA9IC9cXGJKYXZhLy50ZXN0KGphdmFDbGFzcykgJiYgY29udGV4dC5qYXZhO1xyXG5cclxuICAgIC8qKiBEZXRlY3QgUmhpbm8uICovXHJcbiAgICB2YXIgcmhpbm8gPSBqYXZhICYmIGdldENsYXNzT2YoY29udGV4dC5lbnZpcm9ubWVudCkgPT0gZW52aXJvQ2xhc3M7XHJcblxyXG4gICAgLyoqIEEgY2hhcmFjdGVyIHRvIHJlcHJlc2VudCBhbHBoYS4gKi9cclxuICAgIHZhciBhbHBoYSA9IGphdmEgPyAnYScgOiAnXFx1MDNiMSc7XHJcblxyXG4gICAgLyoqIEEgY2hhcmFjdGVyIHRvIHJlcHJlc2VudCBiZXRhLiAqL1xyXG4gICAgdmFyIGJldGEgPSBqYXZhID8gJ2InIDogJ1xcdTAzYjInO1xyXG5cclxuICAgIC8qKiBCcm93c2VyIGRvY3VtZW50IG9iamVjdC4gKi9cclxuICAgIHZhciBkb2MgPSBjb250ZXh0LmRvY3VtZW50IHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0IE9wZXJhIGJyb3dzZXIgKFByZXN0by1iYXNlZCkuXHJcbiAgICAgKiBodHRwOi8vd3d3Lmhvd3RvY3JlYXRlLmNvLnVrL29wZXJhU3R1ZmYvb3BlcmFPYmplY3QuaHRtbFxyXG4gICAgICogaHR0cDovL2Rldi5vcGVyYS5jb20vYXJ0aWNsZXMvdmlldy9vcGVyYS1taW5pLXdlYi1jb250ZW50LWF1dGhvcmluZy1ndWlkZWxpbmVzLyNvcGVyYW1pbmlcclxuICAgICAqL1xyXG4gICAgdmFyIG9wZXJhID0gY29udGV4dC5vcGVyYW1pbmkgfHwgY29udGV4dC5vcGVyYTtcclxuXHJcbiAgICAvKiogT3BlcmEgYFtbQ2xhc3NdXWAuICovXHJcbiAgICB2YXIgb3BlcmFDbGFzcyA9IHJlT3BlcmEudGVzdChvcGVyYUNsYXNzID0gKGlzQ3VzdG9tQ29udGV4dCAmJiBvcGVyYSkgPyBvcGVyYVsnW1tDbGFzc11dJ10gOiBnZXRDbGFzc09mKG9wZXJhKSlcclxuICAgICAgPyBvcGVyYUNsYXNzXHJcbiAgICAgIDogKG9wZXJhID0gbnVsbCk7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgdXNlZCBvdmVyIHRoZSBzY3JpcHQncyBsaWZldGltZS4gKi9cclxuICAgIHZhciBkYXRhO1xyXG5cclxuICAgIC8qKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZS4gKi9cclxuICAgIHZhciBhcmNoID0gdWE7XHJcblxyXG4gICAgLyoqIFBsYXRmb3JtIGRlc2NyaXB0aW9uIGFycmF5LiAqL1xyXG4gICAgdmFyIGRlc2NyaXB0aW9uID0gW107XHJcblxyXG4gICAgLyoqIFBsYXRmb3JtIGFscGhhL2JldGEgaW5kaWNhdG9yLiAqL1xyXG4gICAgdmFyIHByZXJlbGVhc2UgPSBudWxsO1xyXG5cclxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBlbnZpcm9ubWVudCBmZWF0dXJlcyBzaG91bGQgYmUgdXNlZCB0byByZXNvbHZlIHRoZSBwbGF0Zm9ybS4gKi9cclxuICAgIHZhciB1c2VGZWF0dXJlcyA9IHVhID09IHVzZXJBZ2VudDtcclxuXHJcbiAgICAvKiogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi4gKi9cclxuICAgIHZhciB2ZXJzaW9uID0gdXNlRmVhdHVyZXMgJiYgb3BlcmEgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT0gJ2Z1bmN0aW9uJyAmJiBvcGVyYS52ZXJzaW9uKCk7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgT1MgZW5kcyB3aXRoIFwiLyBWZXJzaW9uXCIgKi9cclxuICAgIHZhciBpc1NwZWNpYWxDYXNlZE9TO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgbGF5b3V0IGVuZ2luZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0KFtcclxuICAgICAgeyAnbGFiZWwnOiAnRWRnZUhUTUwnLCAncGF0dGVybic6ICdFZGdlJyB9LFxyXG4gICAgICAnVHJpZGVudCcsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ1dlYktpdCcsICdwYXR0ZXJuJzogJ0FwcGxlV2ViS2l0JyB9LFxyXG4gICAgICAnaUNhYicsXHJcbiAgICAgICdQcmVzdG8nLFxyXG4gICAgICAnTmV0RnJvbnQnLFxyXG4gICAgICAnVGFzbWFuJyxcclxuICAgICAgJ0tIVE1MJyxcclxuICAgICAgJ0dlY2tvJ1xyXG4gICAgXSk7XHJcblxyXG4gICAgLyogRGV0ZWN0YWJsZSBicm93c2VyIG5hbWVzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xyXG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKFtcclxuICAgICAgJ0Fkb2JlIEFJUicsXHJcbiAgICAgICdBcm9yYScsXHJcbiAgICAgICdBdmFudCBCcm93c2VyJyxcclxuICAgICAgJ0JyZWFjaCcsXHJcbiAgICAgICdDYW1pbm8nLFxyXG4gICAgICAnRXBpcGhhbnknLFxyXG4gICAgICAnRmVubmVjJyxcclxuICAgICAgJ0Zsb2NrJyxcclxuICAgICAgJ0dhbGVvbicsXHJcbiAgICAgICdHcmVlbkJyb3dzZXInLFxyXG4gICAgICAnaUNhYicsXHJcbiAgICAgICdJY2V3ZWFzZWwnLFxyXG4gICAgICAnSy1NZWxlb24nLFxyXG4gICAgICAnS29ucXVlcm9yJyxcclxuICAgICAgJ0x1bmFzY2FwZScsXHJcbiAgICAgICdNYXh0aG9uJyxcclxuICAgICAgeyAnbGFiZWwnOiAnTWljcm9zb2Z0IEVkZ2UnLCAncGF0dGVybic6ICdFZGdlJyB9LFxyXG4gICAgICAnTWlkb3JpJyxcclxuICAgICAgJ05vb2sgQnJvd3NlcicsXHJcbiAgICAgICdQYWxlTW9vbicsXHJcbiAgICAgICdQaGFudG9tSlMnLFxyXG4gICAgICAnUmF2ZW4nLFxyXG4gICAgICAnUmVrb25xJyxcclxuICAgICAgJ1JvY2tNZWx0JyxcclxuICAgICAgJ1NlYU1vbmtleScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ1NpbGsnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXHJcbiAgICAgICdTbGVpcG5pcicsXHJcbiAgICAgICdTbGltQnJvd3NlcicsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ1NSV2FyZSBJcm9uJywgJ3BhdHRlcm4nOiAnSXJvbicgfSxcclxuICAgICAgJ1N1bnJpc2UnLFxyXG4gICAgICAnU3dpZnRmb3gnLFxyXG4gICAgICAnV2ViUG9zaXRpdmUnLFxyXG4gICAgICAnT3BlcmEgTWluaScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ09wZXJhIE1pbmknLCAncGF0dGVybic6ICdPUGlPUycgfSxcclxuICAgICAgJ09wZXJhJyxcclxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEnLCAncGF0dGVybic6ICdPUFInIH0sXHJcbiAgICAgICdDaHJvbWUnLFxyXG4gICAgICB7ICdsYWJlbCc6ICdDaHJvbWUgTW9iaWxlJywgJ3BhdHRlcm4nOiAnKD86Q3JpT1N8Q3JNbyknIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0ZpcmVmb3gnLCAncGF0dGVybic6ICcoPzpGaXJlZm94fE1pbmVmaWVsZCknIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0ZpcmVmb3ggZm9yIGlPUycsICdwYXR0ZXJuJzogJ0Z4aU9TJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdJRScsICdwYXR0ZXJuJzogJ0lFTW9iaWxlJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdJRScsICdwYXR0ZXJuJzogJ01TSUUnIH0sXHJcbiAgICAgICdTYWZhcmknXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIHByb2R1Y3RzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xyXG4gICAgdmFyIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFtcclxuICAgICAgeyAnbGFiZWwnOiAnQmxhY2tCZXJyeScsICdwYXR0ZXJuJzogJ0JCMTAnIH0sXHJcbiAgICAgICdCbGFja0JlcnJ5JyxcclxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMnLCAncGF0dGVybic6ICdHVC1JOTAwMCcgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMyJywgJ3BhdHRlcm4nOiAnR1QtSTkxMDAnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTMycsICdwYXR0ZXJuJzogJ0dULUk5MzAwJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzQnLCAncGF0dGVybic6ICdHVC1JOTUwMCcgfSxcclxuICAgICAgJ0dvb2dsZSBUVicsXHJcbiAgICAgICdMdW1pYScsXHJcbiAgICAgICdpUGFkJyxcclxuICAgICAgJ2lQb2QnLFxyXG4gICAgICAnaVBob25lJyxcclxuICAgICAgJ0tpbmRsZScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0tpbmRsZSBGaXJlJywgJ3BhdHRlcm4nOiAnKD86Q2xvdWQ5fFNpbGstQWNjZWxlcmF0ZWQpJyB9LFxyXG4gICAgICAnTmV4dXMnLFxyXG4gICAgICAnTm9vaycsXHJcbiAgICAgICdQbGF5Qm9vaycsXHJcbiAgICAgICdQbGF5U3RhdGlvbiAzJyxcclxuICAgICAgJ1BsYXlTdGF0aW9uIDQnLFxyXG4gICAgICAnUGxheVN0YXRpb24gVml0YScsXHJcbiAgICAgICdUb3VjaFBhZCcsXHJcbiAgICAgICdUcmFuc2Zvcm1lcicsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ1dpaSBVJywgJ3BhdHRlcm4nOiAnV2lpVScgfSxcclxuICAgICAgJ1dpaScsXHJcbiAgICAgICdYYm94IE9uZScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ1hib3ggMzYwJywgJ3BhdHRlcm4nOiAnWGJveCcgfSxcclxuICAgICAgJ1hvb20nXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIG1hbnVmYWN0dXJlcnMuICovXHJcbiAgICB2YXIgbWFudWZhY3R1cmVyID0gZ2V0TWFudWZhY3R1cmVyKHtcclxuICAgICAgJ0FwcGxlJzogeyAnaVBhZCc6IDEsICdpUGhvbmUnOiAxLCAnaVBvZCc6IDEgfSxcclxuICAgICAgJ0FyY2hvcyc6IHt9LFxyXG4gICAgICAnQW1hem9uJzogeyAnS2luZGxlJzogMSwgJ0tpbmRsZSBGaXJlJzogMSB9LFxyXG4gICAgICAnQXN1cyc6IHsgJ1RyYW5zZm9ybWVyJzogMSB9LFxyXG4gICAgICAnQmFybmVzICYgTm9ibGUnOiB7ICdOb29rJzogMSB9LFxyXG4gICAgICAnQmxhY2tCZXJyeSc6IHsgJ1BsYXlCb29rJzogMSB9LFxyXG4gICAgICAnR29vZ2xlJzogeyAnR29vZ2xlIFRWJzogMSwgJ05leHVzJzogMSB9LFxyXG4gICAgICAnSFAnOiB7ICdUb3VjaFBhZCc6IDEgfSxcclxuICAgICAgJ0hUQyc6IHt9LFxyXG4gICAgICAnTEcnOiB7fSxcclxuICAgICAgJ01pY3Jvc29mdCc6IHsgJ1hib3gnOiAxLCAnWGJveCBPbmUnOiAxIH0sXHJcbiAgICAgICdNb3Rvcm9sYSc6IHsgJ1hvb20nOiAxIH0sXHJcbiAgICAgICdOaW50ZW5kbyc6IHsgJ1dpaSBVJzogMSwgICdXaWknOiAxIH0sXHJcbiAgICAgICdOb2tpYSc6IHsgJ0x1bWlhJzogMSB9LFxyXG4gICAgICAnU2Ftc3VuZyc6IHsgJ0dhbGF4eSBTJzogMSwgJ0dhbGF4eSBTMic6IDEsICdHYWxheHkgUzMnOiAxLCAnR2FsYXh5IFM0JzogMSB9LFxyXG4gICAgICAnU29ueSc6IHsgJ1BsYXlTdGF0aW9uIDQnOiAxLCAnUGxheVN0YXRpb24gMyc6IDEsICdQbGF5U3RhdGlvbiBWaXRhJzogMSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIG9wZXJhdGluZyBzeXN0ZW1zIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xyXG4gICAgdmFyIG9zID0gZ2V0T1MoW1xyXG4gICAgICAnV2luZG93cyBQaG9uZScsXHJcbiAgICAgICdBbmRyb2lkJyxcclxuICAgICAgJ0NlbnRPUycsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBPUycsICdwYXR0ZXJuJzogJ0NyT1MnIH0sXHJcbiAgICAgICdEZWJpYW4nLFxyXG4gICAgICAnRmVkb3JhJyxcclxuICAgICAgJ0ZyZWVCU0QnLFxyXG4gICAgICAnR2VudG9vJyxcclxuICAgICAgJ0hhaWt1JyxcclxuICAgICAgJ0t1YnVudHUnLFxyXG4gICAgICAnTGludXggTWludCcsXHJcbiAgICAgICdPcGVuQlNEJyxcclxuICAgICAgJ1JlZCBIYXQnLFxyXG4gICAgICAnU3VTRScsXHJcbiAgICAgICdVYnVudHUnLFxyXG4gICAgICAnWHVidW50dScsXHJcbiAgICAgICdDeWd3aW4nLFxyXG4gICAgICAnU3ltYmlhbiBPUycsXHJcbiAgICAgICdocHdPUycsXHJcbiAgICAgICd3ZWJPUyAnLFxyXG4gICAgICAnd2ViT1MnLFxyXG4gICAgICAnVGFibGV0IE9TJyxcclxuICAgICAgJ0xpbnV4JyxcclxuICAgICAgJ01hYyBPUyBYJyxcclxuICAgICAgJ01hY2ludG9zaCcsXHJcbiAgICAgICdNYWMnLFxyXG4gICAgICAnV2luZG93cyA5ODsnLFxyXG4gICAgICAnV2luZG93cyAnXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgbGF5b3V0IGVuZ2luZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIGxheW91dCBlbmdpbmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldExheW91dChndWVzc2VzKSB7XHJcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUmVnRXhwKCdcXFxcYicgKyAoXHJcbiAgICAgICAgICBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpXHJcbiAgICAgICAgKSArICdcXFxcYicsICdpJykuZXhlYyh1YSkgJiYgKGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgbWFudWZhY3R1cmVyIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBvYmplY3Qgb2YgZ3Vlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIG1hbnVmYWN0dXJlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TWFudWZhY3R1cmVyKGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAvLyBMb29rdXAgdGhlIG1hbnVmYWN0dXJlciBieSBwcm9kdWN0IG9yIHNjYW4gdGhlIFVBIGZvciB0aGUgbWFudWZhY3R1cmVyLlxyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgKFxyXG4gICAgICAgICAgdmFsdWVbcHJvZHVjdF0gfHxcclxuICAgICAgICAgIHZhbHVlWy9eW2Etel0rKD86ICtbYS16XStcXGIpKi9pLmV4ZWMocHJvZHVjdCldIHx8XHJcbiAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHF1YWxpZnkoa2V5KSArICcoPzpcXFxcYnxcXFxcdypcXFxcZCknLCAnaScpLmV4ZWModWEpXHJcbiAgICAgICAgKSAmJiBrZXk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGlja3MgdGhlIGJyb3dzZXIgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIGJyb3dzZXIgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShndWVzc2VzKSB7XHJcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUmVnRXhwKCdcXFxcYicgKyAoXHJcbiAgICAgICAgICBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpXHJcbiAgICAgICAgKSArICdcXFxcYicsICdpJykuZXhlYyh1YSkgJiYgKGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgT1MgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIE9TIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE9TKGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxyXG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcoPzovW1xcXFxkLl0rfFsgXFxcXHcuXSopJywgJ2knKS5leGVjKHVhKVxyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBjbGVhbnVwT1MocmVzdWx0LCBwYXR0ZXJuLCBndWVzcy5sYWJlbCB8fCBndWVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGlja3MgdGhlIHByb2R1Y3QgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIHByb2R1Y3QgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0UHJvZHVjdChndWVzc2VzKSB7XHJcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xyXG4gICAgICAgIHZhciBwYXR0ZXJuID0gZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCAmJiAocmVzdWx0ID1cclxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnICpcXFxcZCtbLlxcXFx3X10qJywgJ2knKS5leGVjKHVhKSB8fFxyXG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcoPzo7ICooPzpbYS16XStbXy1dKT9bYS16XStcXFxcZCt8W14gKCk7LV0qKScsICdpJykuZXhlYyh1YSlcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgLy8gU3BsaXQgYnkgZm9yd2FyZCBzbGFzaCBhbmQgYXBwZW5kIHByb2R1Y3QgdmVyc2lvbiBpZiBuZWVkZWQuXHJcbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IFN0cmluZygoZ3Vlc3MubGFiZWwgJiYgIVJlZ0V4cChwYXR0ZXJuLCAnaScpLnRlc3QoZ3Vlc3MubGFiZWwpKSA/IGd1ZXNzLmxhYmVsIDogcmVzdWx0KS5zcGxpdCgnLycpKVsxXSAmJiAhL1tcXGQuXSsvLnRlc3QocmVzdWx0WzBdKSkge1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gKz0gJyAnICsgcmVzdWx0WzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQ29ycmVjdCBjaGFyYWN0ZXIgY2FzZSBhbmQgY2xlYW51cCBzdHJpbmcuXHJcbiAgICAgICAgICBndWVzcyA9IGd1ZXNzLmxhYmVsIHx8IGd1ZXNzO1xyXG4gICAgICAgICAgcmVzdWx0ID0gZm9ybWF0KHJlc3VsdFswXVxyXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAocGF0dGVybiwgJ2knKSwgZ3Vlc3MpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cCgnOyAqKD86JyArIGd1ZXNzICsgJ1tfLV0pPycsICdpJyksICcgJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCcoJyArIGd1ZXNzICsgJylbLV8uXT8oXFxcXHcpJywgJ2knKSwgJyQxICQyJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIHRoZSB2ZXJzaW9uIHVzaW5nIGFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBBbiBhcnJheSBvZiBVQSBwYXR0ZXJucy5cclxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFZlcnNpb24ocGF0dGVybnMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShwYXR0ZXJucywgZnVuY3Rpb24ocmVzdWx0LCBwYXR0ZXJuKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoUmVnRXhwKHBhdHRlcm4gK1xyXG4gICAgICAgICAgJyg/Oi1bXFxcXGQuXSsvfCg/OiBmb3IgW1xcXFx3LV0rKT9bIC8tXSkoW1xcXFxkLl0rW14gKCk7L18tXSopJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fCBudWxsO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCB3aGVuIHRoZSBwbGF0Zm9ybSBvYmplY3QgaXMgY29lcmNlZCB0byBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGBwbGF0Zm9ybS5kZXNjcmlwdGlvbmAgaWYgYXZhaWxhYmxlLCBlbHNlIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmdQbGF0Zm9ybSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb24gfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8vIENvbnZlcnQgbGF5b3V0IHRvIGFuIGFycmF5IHNvIHdlIGNhbiBhZGQgZXh0cmEgZGV0YWlscy5cclxuICAgIGxheW91dCAmJiAobGF5b3V0ID0gW2xheW91dF0pO1xyXG5cclxuICAgIC8vIERldGVjdCBwcm9kdWN0IG5hbWVzIHRoYXQgY29udGFpbiB0aGVpciBtYW51ZmFjdHVyZXIncyBuYW1lLlxyXG4gICAgaWYgKG1hbnVmYWN0dXJlciAmJiAhcHJvZHVjdCkge1xyXG4gICAgICBwcm9kdWN0ID0gZ2V0UHJvZHVjdChbbWFudWZhY3R1cmVyXSk7XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBHb29nbGUgVFYuXHJcbiAgICBpZiAoKGRhdGEgPSAvXFxiR29vZ2xlIFRWXFxiLy5leGVjKHByb2R1Y3QpKSkge1xyXG4gICAgICBwcm9kdWN0ID0gZGF0YVswXTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBzaW11bGF0b3JzLlxyXG4gICAgaWYgKC9cXGJTaW11bGF0b3JcXGIvaS50ZXN0KHVhKSkge1xyXG4gICAgICBwcm9kdWN0ID0gKHByb2R1Y3QgPyBwcm9kdWN0ICsgJyAnIDogJycpICsgJ1NpbXVsYXRvcic7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgT3BlcmEgTWluaSA4KyBydW5uaW5nIGluIFR1cmJvL1VuY29tcHJlc3NlZCBtb2RlIG9uIGlPUy5cclxuICAgIGlmIChuYW1lID09ICdPcGVyYSBNaW5pJyAmJiAvXFxiT1BpT1NcXGIvLnRlc3QodWEpKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ3J1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBJRSBNb2JpbGUgMTEuXHJcbiAgICBpZiAobmFtZSA9PSAnSUUnICYmIC9cXGJsaWtlIGlQaG9uZSBPU1xcYi8udGVzdCh1YSkpIHtcclxuICAgICAgZGF0YSA9IHBhcnNlKHVhLnJlcGxhY2UoL2xpa2UgaVBob25lIE9TLywgJycpKTtcclxuICAgICAgbWFudWZhY3R1cmVyID0gZGF0YS5tYW51ZmFjdHVyZXI7XHJcbiAgICAgIHByb2R1Y3QgPSBkYXRhLnByb2R1Y3Q7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgaU9TLlxyXG4gICAgZWxzZSBpZiAoL15pUC8udGVzdChwcm9kdWN0KSkge1xyXG4gICAgICBuYW1lIHx8IChuYW1lID0gJ1NhZmFyaScpO1xyXG4gICAgICBvcyA9ICdpT1MnICsgKChkYXRhID0gLyBPUyAoW1xcZF9dKykvaS5leGVjKHVhKSlcclxuICAgICAgICA/ICcgJyArIGRhdGFbMV0ucmVwbGFjZSgvXy9nLCAnLicpXHJcbiAgICAgICAgOiAnJyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgS3VidW50dS5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0tvbnF1ZXJvcicgJiYgIS9idW50dS9pLnRlc3Qob3MpKSB7XHJcbiAgICAgIG9zID0gJ0t1YnVudHUnO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IEFuZHJvaWQgYnJvd3NlcnMuXHJcbiAgICBlbHNlIGlmICgobWFudWZhY3R1cmVyICYmIG1hbnVmYWN0dXJlciAhPSAnR29vZ2xlJyAmJlxyXG4gICAgICAgICgoL0Nocm9tZS8udGVzdChuYW1lKSAmJiAhL1xcYk1vYmlsZSBTYWZhcmlcXGIvaS50ZXN0KHVhKSkgfHwgL1xcYlZpdGFcXGIvLnRlc3QocHJvZHVjdCkpKSB8fFxyXG4gICAgICAgICgvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgJiYgL15DaHJvbWUvLnRlc3QobmFtZSkgJiYgL1xcYlZlcnNpb25cXC8vaS50ZXN0KHVhKSkpIHtcclxuICAgICAgbmFtZSA9ICdBbmRyb2lkIEJyb3dzZXInO1xyXG4gICAgICBvcyA9IC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSA/IG9zIDogJ0FuZHJvaWQnO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFNpbGsgZGVza3RvcC9hY2NlbGVyYXRlZCBtb2Rlcy5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ1NpbGsnKSB7XHJcbiAgICAgIGlmICghL1xcYk1vYmkvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgIG9zID0gJ0FuZHJvaWQnO1xyXG4gICAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgvQWNjZWxlcmF0ZWQgKj0gKnRydWUvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2FjY2VsZXJhdGVkJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERldGVjdCBQYWxlTW9vbiBpZGVudGlmeWluZyBhcyBGaXJlZm94LlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnUGFsZU1vb24nICYmIChkYXRhID0gL1xcYkZpcmVmb3hcXC8oW1xcZC5dKylcXGIvLmV4ZWModWEpKSkge1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyBGaXJlZm94ICcgKyBkYXRhWzFdKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBGaXJlZm94IE9TIGFuZCBwcm9kdWN0cyBydW5uaW5nIEZpcmVmb3guXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdGaXJlZm94JyAmJiAoZGF0YSA9IC9cXGIoTW9iaWxlfFRhYmxldHxUVilcXGIvaS5leGVjKHVhKSkpIHtcclxuICAgICAgb3MgfHwgKG9zID0gJ0ZpcmVmb3ggT1MnKTtcclxuICAgICAgcHJvZHVjdCB8fCAocHJvZHVjdCA9IGRhdGFbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IGZhbHNlIHBvc2l0aXZlcyBmb3IgRmlyZWZveC9TYWZhcmkuXHJcbiAgICBlbHNlIGlmICghbmFtZSB8fCAoZGF0YSA9ICEvXFxiTWluZWZpZWxkXFxiL2kudGVzdCh1YSkgJiYgL1xcYig/OkZpcmVmb3h8U2FmYXJpKVxcYi8uZXhlYyhuYW1lKSkpIHtcclxuICAgICAgLy8gRXNjYXBlIHRoZSBgL2AgZm9yIEZpcmVmb3ggMS5cclxuICAgICAgaWYgKG5hbWUgJiYgIXByb2R1Y3QgJiYgL1tcXC8sXXxeW14oXSs/XFwpLy50ZXN0KHVhLnNsaWNlKHVhLmluZGV4T2YoZGF0YSArICcvJykgKyA4KSkpIHtcclxuICAgICAgICAvLyBDbGVhciBuYW1lIG9mIGZhbHNlIHBvc2l0aXZlcy5cclxuICAgICAgICBuYW1lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICAvLyBSZWFzc2lnbiBhIGdlbmVyaWMgbmFtZS5cclxuICAgICAgaWYgKChkYXRhID0gcHJvZHVjdCB8fCBtYW51ZmFjdHVyZXIgfHwgb3MpICYmXHJcbiAgICAgICAgICAocHJvZHVjdCB8fCBtYW51ZmFjdHVyZXIgfHwgL1xcYig/OkFuZHJvaWR8U3ltYmlhbiBPU3xUYWJsZXQgT1N8d2ViT1MpXFxiLy50ZXN0KG9zKSkpIHtcclxuICAgICAgICBuYW1lID0gL1thLXpdKyg/OiBIYXQpPy9pLmV4ZWMoL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiBkYXRhKSArICcgQnJvd3Nlcic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERldGVjdCBub24tT3BlcmEgKFByZXN0by1iYXNlZCkgdmVyc2lvbnMgKG9yZGVyIGlzIGltcG9ydGFudCkuXHJcbiAgICBpZiAoIXZlcnNpb24pIHtcclxuICAgICAgdmVyc2lvbiA9IGdldFZlcnNpb24oW1xyXG4gICAgICAgICcoPzpDbG91ZDl8Q3JpT1N8Q3JNb3xFZGdlfEZ4aU9TfElFTW9iaWxlfElyb258T3BlcmEgP01pbml8T1BpT1N8T1BSfFJhdmVufFNpbGsoPyEvW1xcXFxkLl0rJCkpJyxcclxuICAgICAgICAnVmVyc2lvbicsXHJcbiAgICAgICAgcXVhbGlmeShuYW1lKSxcclxuICAgICAgICAnKD86RmlyZWZveHxNaW5lZmllbGR8TmV0RnJvbnQpJ1xyXG4gICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBzdHViYm9ybiBsYXlvdXQgZW5naW5lcy5cclxuICAgIGlmICgoZGF0YSA9XHJcbiAgICAgICAgICBsYXlvdXQgPT0gJ2lDYWInICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPiAzICYmICdXZWJLaXQnIHx8XHJcbiAgICAgICAgICAvXFxiT3BlcmFcXGIvLnRlc3QobmFtZSkgJiYgKC9cXGJPUFJcXGIvLnRlc3QodWEpID8gJ0JsaW5rJyA6ICdQcmVzdG8nKSB8fFxyXG4gICAgICAgICAgL1xcYig/Ok1pZG9yaXxOb29rfFNhZmFyaSlcXGIvaS50ZXN0KHVhKSAmJiAhL14oPzpUcmlkZW50fEVkZ2VIVE1MKSQvLnRlc3QobGF5b3V0KSAmJiAnV2ViS2l0JyB8fFxyXG4gICAgICAgICAgIWxheW91dCAmJiAvXFxiTVNJRVxcYi9pLnRlc3QodWEpICYmIChvcyA9PSAnTWFjIE9TJyA/ICdUYXNtYW4nIDogJ1RyaWRlbnQnKSB8fFxyXG4gICAgICAgICAgbGF5b3V0ID09ICdXZWJLaXQnICYmIC9cXGJQbGF5U3RhdGlvblxcYig/ISBWaXRhXFxiKS9pLnRlc3QobmFtZSkgJiYgJ05ldEZyb250J1xyXG4gICAgICAgICkpIHtcclxuICAgICAgbGF5b3V0ID0gW2RhdGFdO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgNyBkZXNrdG9wIG1vZGUuXHJcbiAgICBpZiAobmFtZSA9PSAnSUUnICYmIChkYXRhID0gKC87ICooPzpYQkxXUHxadW5lV1ApKFxcZCspL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XHJcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xyXG4gICAgICBvcyA9ICdXaW5kb3dzIFBob25lICcgKyAoL1xcKyQvLnRlc3QoZGF0YSkgPyBkYXRhIDogZGF0YSArICcueCcpO1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBXaW5kb3dzIFBob25lIDgueCBkZXNrdG9wIG1vZGUuXHJcbiAgICBlbHNlIGlmICgvXFxiV1BEZXNrdG9wXFxiL2kudGVzdCh1YSkpIHtcclxuICAgICAgbmFtZSA9ICdJRSBNb2JpbGUnO1xyXG4gICAgICBvcyA9ICdXaW5kb3dzIFBob25lIDgueCc7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgICB2ZXJzaW9uIHx8ICh2ZXJzaW9uID0gKC9cXGJydjooW1xcZC5dKykvLmV4ZWModWEpIHx8IDApWzFdKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBJRSAxMS5cclxuICAgIGVsc2UgaWYgKG5hbWUgIT0gJ0lFJyAmJiBsYXlvdXQgPT0gJ1RyaWRlbnQnICYmIChkYXRhID0gL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkpKSB7XHJcbiAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnaWRlbnRpZnlpbmcgYXMgJyArIG5hbWUgKyAodmVyc2lvbiA/ICcgJyArIHZlcnNpb24gOiAnJykpO1xyXG4gICAgICB9XHJcbiAgICAgIG5hbWUgPSAnSUUnO1xyXG4gICAgICB2ZXJzaW9uID0gZGF0YVsxXTtcclxuICAgIH1cclxuICAgIC8vIExldmVyYWdlIGVudmlyb25tZW50IGZlYXR1cmVzLlxyXG4gICAgaWYgKHVzZUZlYXR1cmVzKSB7XHJcbiAgICAgIC8vIERldGVjdCBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudHMuXHJcbiAgICAgIC8vIFJoaW5vIGhhcyBhIGdsb2JhbCBmdW5jdGlvbiB3aGlsZSBvdGhlcnMgaGF2ZSBhIGdsb2JhbCBvYmplY3QuXHJcbiAgICAgIGlmIChpc0hvc3RUeXBlKGNvbnRleHQsICdnbG9iYWwnKSkge1xyXG4gICAgICAgIGlmIChqYXZhKSB7XHJcbiAgICAgICAgICBkYXRhID0gamF2YS5sYW5nLlN5c3RlbTtcclxuICAgICAgICAgIGFyY2ggPSBkYXRhLmdldFByb3BlcnR5KCdvcy5hcmNoJyk7XHJcbiAgICAgICAgICBvcyA9IG9zIHx8IGRhdGEuZ2V0UHJvcGVydHkoJ29zLm5hbWUnKSArICcgJyArIGRhdGEuZ2V0UHJvcGVydHkoJ29zLnZlcnNpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTW9kdWxlU2NvcGUgJiYgaXNIb3N0VHlwZShjb250ZXh0LCAnc3lzdGVtJykgJiYgKGRhdGEgPSBbY29udGV4dC5zeXN0ZW1dKVswXSkge1xyXG4gICAgICAgICAgb3MgfHwgKG9zID0gZGF0YVswXS5vcyB8fCBudWxsKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRhdGFbMV0gPSBjb250ZXh0LnJlcXVpcmUoJ3JpbmdvL2VuZ2luZScpLnZlcnNpb247XHJcbiAgICAgICAgICAgIHZlcnNpb24gPSBkYXRhWzFdLmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgbmFtZSA9ICdSaW5nb0pTJztcclxuICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVswXS5nbG9iYWwuc3lzdGVtID09IGNvbnRleHQuc3lzdGVtKSB7XHJcbiAgICAgICAgICAgICAgbmFtZSA9ICdOYXJ3aGFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgIHR5cGVvZiBjb250ZXh0LnByb2Nlc3MgPT0gJ29iamVjdCcgJiYgIWNvbnRleHQucHJvY2Vzcy5icm93c2VyICYmXHJcbiAgICAgICAgICAoZGF0YSA9IGNvbnRleHQucHJvY2VzcylcclxuICAgICAgICApIHtcclxuICAgICAgICAgIG5hbWUgPSAnTm9kZS5qcyc7XHJcbiAgICAgICAgICBhcmNoID0gZGF0YS5hcmNoO1xyXG4gICAgICAgICAgb3MgPSBkYXRhLnBsYXRmb3JtO1xyXG4gICAgICAgICAgdmVyc2lvbiA9IC9bXFxkLl0rLy5leGVjKGRhdGEudmVyc2lvbilbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJoaW5vKSB7XHJcbiAgICAgICAgICBuYW1lID0gJ1JoaW5vJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRGV0ZWN0IEFkb2JlIEFJUi5cclxuICAgICAgZWxzZSBpZiAoZ2V0Q2xhc3NPZigoZGF0YSA9IGNvbnRleHQucnVudGltZSkpID09IGFpclJ1bnRpbWVDbGFzcykge1xyXG4gICAgICAgIG5hbWUgPSAnQWRvYmUgQUlSJztcclxuICAgICAgICBvcyA9IGRhdGEuZmxhc2guc3lzdGVtLkNhcGFiaWxpdGllcy5vcztcclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgUGhhbnRvbUpTLlxyXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5waGFudG9tKSkgPT0gcGhhbnRvbUNsYXNzKSB7XHJcbiAgICAgICAgbmFtZSA9ICdQaGFudG9tSlMnO1xyXG4gICAgICAgIHZlcnNpb24gPSAoZGF0YSA9IGRhdGEudmVyc2lvbiB8fCBudWxsKSAmJiAoZGF0YS5tYWpvciArICcuJyArIGRhdGEubWlub3IgKyAnLicgKyBkYXRhLnBhdGNoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgSUUgY29tcGF0aWJpbGl0eSBtb2Rlcy5cclxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRvYy5kb2N1bWVudE1vZGUgPT0gJ251bWJlcicgJiYgKGRhdGEgPSAvXFxiVHJpZGVudFxcLyhcXGQrKS9pLmV4ZWModWEpKSkge1xyXG4gICAgICAgIC8vIFdlJ3JlIGluIGNvbXBhdGliaWxpdHkgbW9kZSB3aGVuIHRoZSBUcmlkZW50IHZlcnNpb24gKyA0IGRvZXNuJ3RcclxuICAgICAgICAvLyBlcXVhbCB0aGUgZG9jdW1lbnQgbW9kZS5cclxuICAgICAgICB2ZXJzaW9uID0gW3ZlcnNpb24sIGRvYy5kb2N1bWVudE1vZGVdO1xyXG4gICAgICAgIGlmICgoZGF0YSA9ICtkYXRhWzFdICsgNCkgIT0gdmVyc2lvblsxXSkge1xyXG4gICAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnSUUgJyArIHZlcnNpb25bMV0gKyAnIG1vZGUnKTtcclxuICAgICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJycpO1xyXG4gICAgICAgICAgdmVyc2lvblsxXSA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlcnNpb24gPSBuYW1lID09ICdJRScgPyBTdHJpbmcodmVyc2lvblsxXS50b0ZpeGVkKDEpKSA6IHZlcnNpb25bMF07XHJcbiAgICAgIH1cclxuICAgICAgb3MgPSBvcyAmJiBmb3JtYXQob3MpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHByZXJlbGVhc2UgcGhhc2VzLlxyXG4gICAgaWYgKHZlcnNpb24gJiYgKGRhdGEgPVxyXG4gICAgICAgICAgLyg/OlthYl18ZHB8cHJlfFthYl1cXGQrcHJlKSg/OlxcZCtcXCs/KT8kL2kuZXhlYyh2ZXJzaW9uKSB8fFxyXG4gICAgICAgICAgLyg/OmFscGhhfGJldGEpKD86ID9cXGQpPy9pLmV4ZWModWEgKyAnOycgKyAodXNlRmVhdHVyZXMgJiYgbmF2LmFwcE1pbm9yVmVyc2lvbikpIHx8XHJcbiAgICAgICAgICAvXFxiTWluZWZpZWxkXFxiL2kudGVzdCh1YSkgJiYgJ2EnXHJcbiAgICAgICAgKSkge1xyXG4gICAgICBwcmVyZWxlYXNlID0gL2IvaS50ZXN0KGRhdGEpID8gJ2JldGEnIDogJ2FscGhhJztcclxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24ucmVwbGFjZShSZWdFeHAoZGF0YSArICdcXFxcKz8kJyksICcnKSArXHJcbiAgICAgICAgKHByZXJlbGVhc2UgPT0gJ2JldGEnID8gYmV0YSA6IGFscGhhKSArICgvXFxkK1xcKz8vLmV4ZWMoZGF0YSkgfHwgJycpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggTW9iaWxlLlxyXG4gICAgaWYgKG5hbWUgPT0gJ0Zlbm5lYycgfHwgbmFtZSA9PSAnRmlyZWZveCcgJiYgL1xcYig/OkFuZHJvaWR8RmlyZWZveCBPUylcXGIvLnRlc3Qob3MpKSB7XHJcbiAgICAgIG5hbWUgPSAnRmlyZWZveCBNb2JpbGUnO1xyXG4gICAgfVxyXG4gICAgLy8gT2JzY3VyZSBNYXh0aG9uJ3MgdW5yZWxpYWJsZSB2ZXJzaW9uLlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnTWF4dGhvbicgJiYgdmVyc2lvbikge1xyXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKC9cXC5bXFxkLl0rLywgJy54Jyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgWGJveCAzNjAgYW5kIFhib3ggT25lLlxyXG4gICAgZWxzZSBpZiAoL1xcYlhib3hcXGIvaS50ZXN0KHByb2R1Y3QpKSB7XHJcbiAgICAgIG9zID0gbnVsbDtcclxuICAgICAgaWYgKHByb2R1Y3QgPT0gJ1hib3ggMzYwJyAmJiAvXFxiSUVNb2JpbGVcXGIvLnRlc3QodWEpKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnbW9iaWxlIG1vZGUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQWRkIG1vYmlsZSBwb3N0Zml4LlxyXG4gICAgZWxzZSBpZiAoKC9eKD86Q2hyb21lfElFfE9wZXJhKSQvLnRlc3QobmFtZSkgfHwgbmFtZSAmJiAhcHJvZHVjdCAmJiAhL0Jyb3dzZXJ8TW9iaS8udGVzdChuYW1lKSkgJiZcclxuICAgICAgICAob3MgPT0gJ1dpbmRvd3MgQ0UnIHx8IC9Nb2JpL2kudGVzdCh1YSkpKSB7XHJcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIHBsYXRmb3JtIHByZXZpZXcuXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdJRScgJiYgdXNlRmVhdHVyZXMgJiYgY29udGV4dC5leHRlcm5hbCA9PT0gbnVsbCkge1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdwbGF0Zm9ybSBwcmV2aWV3Jyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgQmxhY2tCZXJyeSBPUyB2ZXJzaW9uLlxyXG4gICAgLy8gaHR0cDovL2RvY3MuYmxhY2tiZXJyeS5jb20vZW4vZGV2ZWxvcGVycy9kZWxpdmVyYWJsZXMvMTgxNjkvSFRUUF9oZWFkZXJzX3NlbnRfYnlfQkJfQnJvd3Nlcl8xMjM0OTExXzExLmpzcFxyXG4gICAgZWxzZSBpZiAoKC9cXGJCbGFja0JlcnJ5XFxiLy50ZXN0KHByb2R1Y3QpIHx8IC9cXGJCQjEwXFxiLy50ZXN0KHVhKSkgJiYgKGRhdGEgPVxyXG4gICAgICAgICAgKFJlZ0V4cChwcm9kdWN0LnJlcGxhY2UoLyArL2csICcgKicpICsgJy8oWy5cXFxcZF0rKScsICdpJykuZXhlYyh1YSkgfHwgMClbMV0gfHxcclxuICAgICAgICAgIHZlcnNpb25cclxuICAgICAgICApKSB7XHJcbiAgICAgIGRhdGEgPSBbZGF0YSwgL0JCMTAvLnRlc3QodWEpXTtcclxuICAgICAgb3MgPSAoZGF0YVsxXSA/IChwcm9kdWN0ID0gbnVsbCwgbWFudWZhY3R1cmVyID0gJ0JsYWNrQmVycnknKSA6ICdEZXZpY2UgU29mdHdhcmUnKSArICcgJyArIGRhdGFbMF07XHJcbiAgICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IE9wZXJhIGlkZW50aWZ5aW5nL21hc2tpbmcgaXRzZWxmIGFzIGFub3RoZXIgYnJvd3Nlci5cclxuICAgIC8vIGh0dHA6Ly93d3cub3BlcmEuY29tL3N1cHBvcnQva2Ivdmlldy84NDMvXHJcbiAgICBlbHNlIGlmICh0aGlzICE9IGZvck93biAmJiBwcm9kdWN0ICE9ICdXaWknICYmIChcclxuICAgICAgICAgICh1c2VGZWF0dXJlcyAmJiBvcGVyYSkgfHxcclxuICAgICAgICAgICgvT3BlcmEvLnRlc3QobmFtZSkgJiYgL1xcYig/Ok1TSUV8RmlyZWZveClcXGIvaS50ZXN0KHVhKSkgfHxcclxuICAgICAgICAgIChuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiT1MgWCAoPzpcXGQrXFwuKXsyLH0vLnRlc3Qob3MpKSB8fFxyXG4gICAgICAgICAgKG5hbWUgPT0gJ0lFJyAmJiAoXHJcbiAgICAgICAgICAgIChvcyAmJiAhL15XaW4vLnRlc3Qob3MpICYmIHZlcnNpb24gPiA1LjUpIHx8XHJcbiAgICAgICAgICAgIC9cXGJXaW5kb3dzIFhQXFxiLy50ZXN0KG9zKSAmJiB2ZXJzaW9uID4gOCB8fFxyXG4gICAgICAgICAgICB2ZXJzaW9uID09IDggJiYgIS9cXGJUcmlkZW50XFxiLy50ZXN0KHVhKVxyXG4gICAgICAgICAgKSlcclxuICAgICAgICApICYmICFyZU9wZXJhLnRlc3QoKGRhdGEgPSBwYXJzZS5jYWxsKGZvck93biwgdWEucmVwbGFjZShyZU9wZXJhLCAnJykgKyAnOycpKSkgJiYgZGF0YS5uYW1lKSB7XHJcbiAgICAgIC8vIFdoZW4gXCJpZGVudGlmeWluZ1wiLCB0aGUgVUEgY29udGFpbnMgYm90aCBPcGVyYSBhbmQgdGhlIG90aGVyIGJyb3dzZXIncyBuYW1lLlxyXG4gICAgICBkYXRhID0gJ2luZyBhcyAnICsgZGF0YS5uYW1lICsgKChkYXRhID0gZGF0YS52ZXJzaW9uKSA/ICcgJyArIGRhdGEgOiAnJyk7XHJcbiAgICAgIGlmIChyZU9wZXJhLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpICYmIG9zID09ICdNYWMgT1MnKSB7XHJcbiAgICAgICAgICBvcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGEgPSAnaWRlbnRpZnknICsgZGF0YTtcclxuICAgICAgfVxyXG4gICAgICAvLyBXaGVuIFwibWFza2luZ1wiLCB0aGUgVUEgY29udGFpbnMgb25seSB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSAnbWFzaycgKyBkYXRhO1xyXG4gICAgICAgIGlmIChvcGVyYUNsYXNzKSB7XHJcbiAgICAgICAgICBuYW1lID0gZm9ybWF0KG9wZXJhQ2xhc3MucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxICQyJykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuYW1lID0gJ09wZXJhJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKC9cXGJJRVxcYi8udGVzdChkYXRhKSkge1xyXG4gICAgICAgICAgb3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXVzZUZlYXR1cmVzKSB7XHJcbiAgICAgICAgICB2ZXJzaW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGF5b3V0ID0gWydQcmVzdG8nXTtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaChkYXRhKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBXZWJLaXQgTmlnaHRseSBhbmQgYXBwcm94aW1hdGUgQ2hyb21lL1NhZmFyaSB2ZXJzaW9ucy5cclxuICAgIGlmICgoZGF0YSA9ICgvXFxiQXBwbGVXZWJLaXRcXC8oW1xcZC5dK1xcKz8pL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XHJcbiAgICAgIC8vIENvcnJlY3QgYnVpbGQgbnVtYmVyIGZvciBudW1lcmljIGNvbXBhcmlzb24uXHJcbiAgICAgIC8vIChlLmcuIFwiNTMyLjVcIiBiZWNvbWVzIFwiNTMyLjA1XCIpXHJcbiAgICAgIGRhdGEgPSBbcGFyc2VGbG9hdChkYXRhLnJlcGxhY2UoL1xcLihcXGQpJC8sICcuMCQxJykpLCBkYXRhXTtcclxuICAgICAgLy8gTmlnaHRseSBidWlsZHMgYXJlIHBvc3RmaXhlZCB3aXRoIGEgXCIrXCIuXHJcbiAgICAgIGlmIChuYW1lID09ICdTYWZhcmknICYmIGRhdGFbMV0uc2xpY2UoLTEpID09ICcrJykge1xyXG4gICAgICAgIG5hbWUgPSAnV2ViS2l0IE5pZ2h0bHknO1xyXG4gICAgICAgIHByZXJlbGVhc2UgPSAnYWxwaGEnO1xyXG4gICAgICAgIHZlcnNpb24gPSBkYXRhWzFdLnNsaWNlKDAsIC0xKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBDbGVhciBpbmNvcnJlY3QgYnJvd3NlciB2ZXJzaW9ucy5cclxuICAgICAgZWxzZSBpZiAodmVyc2lvbiA9PSBkYXRhWzFdIHx8XHJcbiAgICAgICAgICB2ZXJzaW9uID09IChkYXRhWzJdID0gKC9cXGJTYWZhcmlcXC8oW1xcZC5dK1xcKz8pL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XHJcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIHRoZSBmdWxsIENocm9tZSB2ZXJzaW9uIHdoZW4gYXZhaWxhYmxlLlxyXG4gICAgICBkYXRhWzFdID0gKC9cXGJDaHJvbWVcXC8oW1xcZC5dKykvaS5leGVjKHVhKSB8fCAwKVsxXTtcclxuICAgICAgLy8gRGV0ZWN0IEJsaW5rIGxheW91dCBlbmdpbmUuXHJcbiAgICAgIGlmIChkYXRhWzBdID09IDUzNy4zNiAmJiBkYXRhWzJdID09IDUzNy4zNiAmJiBwYXJzZUZsb2F0KGRhdGFbMV0pID49IDI4ICYmIGxheW91dCA9PSAnV2ViS2l0Jykge1xyXG4gICAgICAgIGxheW91dCA9IFsnQmxpbmsnXTtcclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgSmF2YVNjcmlwdENvcmUuXHJcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc2ODQ3NC9ob3ctY2FuLWktZGV0ZWN0LXdoaWNoLWphdmFzY3JpcHQtZW5naW5lLXY4LW9yLWpzYy1pcy11c2VkLWF0LXJ1bnRpbWUtaW4tYW5kcm9pXHJcbiAgICAgIGlmICghdXNlRmVhdHVyZXMgfHwgKCFsaWtlQ2hyb21lICYmICFkYXRhWzFdKSkge1xyXG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgU2FmYXJpJyk7XHJcbiAgICAgICAgZGF0YSA9IChkYXRhID0gZGF0YVswXSwgZGF0YSA8IDQwMCA/IDEgOiBkYXRhIDwgNTAwID8gMiA6IGRhdGEgPCA1MjYgPyAzIDogZGF0YSA8IDUzMyA/IDQgOiBkYXRhIDwgNTM0ID8gJzQrJyA6IGRhdGEgPCA1MzUgPyA1IDogZGF0YSA8IDUzNyA/IDYgOiBkYXRhIDwgNTM4ID8gNyA6IGRhdGEgPCA2MDEgPyA4IDogJzgnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSA9ICdsaWtlIENocm9tZScpO1xyXG4gICAgICAgIGRhdGEgPSBkYXRhWzFdIHx8IChkYXRhID0gZGF0YVswXSwgZGF0YSA8IDUzMCA/IDEgOiBkYXRhIDwgNTMyID8gMiA6IGRhdGEgPCA1MzIuMDUgPyAzIDogZGF0YSA8IDUzMyA/IDQgOiBkYXRhIDwgNTM0LjAzID8gNSA6IGRhdGEgPCA1MzQuMDcgPyA2IDogZGF0YSA8IDUzNC4xMCA/IDcgOiBkYXRhIDwgNTM0LjEzID8gOCA6IGRhdGEgPCA1MzQuMTYgPyA5IDogZGF0YSA8IDUzNC4yNCA/IDEwIDogZGF0YSA8IDUzNC4zMCA/IDExIDogZGF0YSA8IDUzNS4wMSA/IDEyIDogZGF0YSA8IDUzNS4wMiA/ICcxMysnIDogZGF0YSA8IDUzNS4wNyA/IDE1IDogZGF0YSA8IDUzNS4xMSA/IDE2IDogZGF0YSA8IDUzNS4xOSA/IDE3IDogZGF0YSA8IDUzNi4wNSA/IDE4IDogZGF0YSA8IDUzNi4xMCA/IDE5IDogZGF0YSA8IDUzNy4wMSA/IDIwIDogZGF0YSA8IDUzNy4xMSA/ICcyMSsnIDogZGF0YSA8IDUzNy4xMyA/IDIzIDogZGF0YSA8IDUzNy4xOCA/IDI0IDogZGF0YSA8IDUzNy4yNCA/IDI1IDogZGF0YSA8IDUzNy4zNiA/IDI2IDogbGF5b3V0ICE9ICdCbGluaycgPyAnMjcnIDogJzI4Jyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQWRkIHRoZSBwb3N0Zml4IG9mIFwiLnhcIiBvciBcIitcIiBmb3IgYXBwcm94aW1hdGUgdmVyc2lvbnMuXHJcbiAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdICs9ICcgJyArIChkYXRhICs9IHR5cGVvZiBkYXRhID09ICdudW1iZXInID8gJy54JyA6IC9bLitdLy50ZXN0KGRhdGEpID8gJycgOiAnKycpKTtcclxuICAgICAgLy8gT2JzY3VyZSB2ZXJzaW9uIGZvciBzb21lIFNhZmFyaSAxLTIgcmVsZWFzZXMuXHJcbiAgICAgIGlmIChuYW1lID09ICdTYWZhcmknICYmICghdmVyc2lvbiB8fCBwYXJzZUludCh2ZXJzaW9uKSA+IDQ1KSkge1xyXG4gICAgICAgIHZlcnNpb24gPSBkYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgT3BlcmEgZGVza3RvcCBtb2Rlcy5cclxuICAgIGlmIChuYW1lID09ICdPcGVyYScgJiYgIChkYXRhID0gL1xcYnpib3Z8enZhdiQvLmV4ZWMob3MpKSkge1xyXG4gICAgICBuYW1lICs9ICcgJztcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIGlmIChkYXRhID09ICd6dmF2Jykge1xyXG4gICAgICAgIG5hbWUgKz0gJ01pbmknO1xyXG4gICAgICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5hbWUgKz0gJ01vYmlsZSc7XHJcbiAgICAgIH1cclxuICAgICAgb3MgPSBvcy5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSArICckJyksICcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBDaHJvbWUgZGVza3RvcCBtb2RlLlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiAvXFxiQ2hyb21lXFxiLy5leGVjKGxheW91dCAmJiBsYXlvdXRbMV0pKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgICBuYW1lID0gJ0Nocm9tZSBNb2JpbGUnO1xyXG4gICAgICB2ZXJzaW9uID0gbnVsbDtcclxuXHJcbiAgICAgIGlmICgvXFxiT1MgWFxcYi8udGVzdChvcykpIHtcclxuICAgICAgICBtYW51ZmFjdHVyZXIgPSAnQXBwbGUnO1xyXG4gICAgICAgIG9zID0gJ2lPUyA0LjMrJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFN0cmlwIGluY29ycmVjdCBPUyB2ZXJzaW9ucy5cclxuICAgIGlmICh2ZXJzaW9uICYmIHZlcnNpb24uaW5kZXhPZigoZGF0YSA9IC9bXFxkLl0rJC8uZXhlYyhvcykpKSA9PSAwICYmXHJcbiAgICAgICAgdWEuaW5kZXhPZignLycgKyBkYXRhICsgJy0nKSA+IC0xKSB7XHJcbiAgICAgIG9zID0gdHJpbShvcy5yZXBsYWNlKGRhdGEsICcnKSk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbGF5b3V0IGVuZ2luZS5cclxuICAgIGlmIChsYXlvdXQgJiYgIS9cXGIoPzpBdmFudHxOb29rKVxcYi8udGVzdChuYW1lKSAmJiAoXHJcbiAgICAgICAgL0Jyb3dzZXJ8THVuYXNjYXBlfE1heHRob24vLnRlc3QobmFtZSkgfHxcclxuICAgICAgICBuYW1lICE9ICdTYWZhcmknICYmIC9eaU9TLy50ZXN0KG9zKSAmJiAvXFxiU2FmYXJpXFxiLy50ZXN0KGxheW91dFsxXSkgfHxcclxuICAgICAgICAvXig/OkFkb2JlfEFyb3JhfEJyZWFjaHxNaWRvcml8T3BlcmF8UGhhbnRvbXxSZWtvbnF8Um9ja3xTbGVpcG5pcnxXZWIpLy50ZXN0KG5hbWUpICYmIGxheW91dFsxXSkpIHtcclxuICAgICAgLy8gRG9uJ3QgYWRkIGxheW91dCBkZXRhaWxzIHRvIGRlc2NyaXB0aW9uIGlmIHRoZXkgYXJlIGZhbHNleS5cclxuICAgICAgKGRhdGEgPSBsYXlvdXRbbGF5b3V0Lmxlbmd0aCAtIDFdKSAmJiBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tYmluZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uLlxyXG4gICAgaWYgKGRlc2NyaXB0aW9uLmxlbmd0aCkge1xyXG4gICAgICBkZXNjcmlwdGlvbiA9IFsnKCcgKyBkZXNjcmlwdGlvbi5qb2luKCc7ICcpICsgJyknXTtcclxuICAgIH1cclxuICAgIC8vIEFwcGVuZCBtYW51ZmFjdHVyZXIgdG8gZGVzY3JpcHRpb24uXHJcbiAgICBpZiAobWFudWZhY3R1cmVyICYmIHByb2R1Y3QgJiYgcHJvZHVjdC5pbmRleE9mKG1hbnVmYWN0dXJlcikgPCAwKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ29uICcgKyBtYW51ZmFjdHVyZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gQXBwZW5kIHByb2R1Y3QgdG8gZGVzY3JpcHRpb24uXHJcbiAgICBpZiAocHJvZHVjdCkge1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCgvXm9uIC8udGVzdChkZXNjcmlwdGlvbltkZXNjcmlwdGlvbi5sZW5ndGggLSAxXSkgPyAnJyA6ICdvbiAnKSArIHByb2R1Y3QpO1xyXG4gICAgfVxyXG4gICAgLy8gUGFyc2UgdGhlIE9TIGludG8gYW4gb2JqZWN0LlxyXG4gICAgaWYgKG9zKSB7XHJcbiAgICAgIGRhdGEgPSAvIChbXFxkLitdKykkLy5leGVjKG9zKTtcclxuICAgICAgaXNTcGVjaWFsQ2FzZWRPUyA9IGRhdGEgJiYgb3MuY2hhckF0KG9zLmxlbmd0aCAtIGRhdGFbMF0ubGVuZ3RoIC0gMSkgPT0gJy8nO1xyXG4gICAgICBvcyA9IHtcclxuICAgICAgICAnYXJjaGl0ZWN0dXJlJzogMzIsXHJcbiAgICAgICAgJ2ZhbWlseSc6IChkYXRhICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/IG9zLnJlcGxhY2UoZGF0YVswXSwgJycpIDogb3MsXHJcbiAgICAgICAgJ3ZlcnNpb24nOiBkYXRhID8gZGF0YVsxXSA6IG51bGwsXHJcbiAgICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmZhbWlseSArICgodmVyc2lvbiAmJiAhaXNTcGVjaWFsQ2FzZWRPUykgPyAnICcgKyB2ZXJzaW9uIDogJycpICsgKHRoaXMuYXJjaGl0ZWN0dXJlID09IDY0ID8gJyA2NC1iaXQnIDogJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIEFkZCBicm93c2VyL09TIGFyY2hpdGVjdHVyZS5cclxuICAgIGlmICgoZGF0YSA9IC9cXGIoPzpBTUR8SUF8V2lufFdPV3x4ODZffHgpNjRcXGIvaS5leGVjKGFyY2gpKSAmJiAhL1xcYmk2ODZcXGIvaS50ZXN0KGFyY2gpKSB7XHJcbiAgICAgIGlmIChvcykge1xyXG4gICAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xyXG4gICAgICAgIG9zLmZhbWlseSA9IG9zLmZhbWlseS5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSksICcnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgICBuYW1lICYmICgvXFxiV09XNjRcXGIvaS50ZXN0KHVhKSB8fFxyXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIC9cXHcoPzo4NnwzMikkLy50ZXN0KG5hdi5jcHVDbGFzcyB8fCBuYXYucGxhdGZvcm0pICYmICEvXFxiV2luNjQ7IHg2NFxcYi9pLnRlc3QodWEpKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnMzItYml0Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENocm9tZSAzOSBhbmQgYWJvdmUgb24gT1MgWCBpcyBhbHdheXMgNjQtYml0LlxyXG4gICAgZWxzZSBpZiAoXHJcbiAgICAgICAgb3MgJiYgL15PUyBYLy50ZXN0KG9zLmZhbWlseSkgJiZcclxuICAgICAgICBuYW1lID09ICdDaHJvbWUnICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPj0gMzlcclxuICAgICkge1xyXG4gICAgICBvcy5hcmNoaXRlY3R1cmUgPSA2NDtcclxuICAgIH1cclxuXHJcbiAgICB1YSB8fCAodWEgPSBudWxsKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGxhdGZvcm0gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBPYmplY3RcclxuICAgICAqL1xyXG4gICAgdmFyIHBsYXRmb3JtID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGxhdGZvcm0gZGVzY3JpcHRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5kZXNjcmlwdGlvbiA9IHVhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIncyBsYXlvdXQgZW5naW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxyXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0ubGF5b3V0ID0gbGF5b3V0ICYmIGxheW91dFswXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0J3MgbWFudWZhY3R1cmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxyXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0ubWFudWZhY3R1cmVyID0gbWFudWZhY3R1cmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIvZW52aXJvbm1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYS9iZXRhIHJlbGVhc2UgaW5kaWNhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxyXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0ucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvZHVjdCBob3N0aW5nIHRoZSBicm93c2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxyXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0ucHJvZHVjdCA9IHByb2R1Y3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYnJvd3NlcidzIHVzZXIgYWdlbnQgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxyXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0udWEgPSB1YTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBicm93c2VyL2Vudmlyb25tZW50IHZlcnNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS52ZXJzaW9uID0gbmFtZSAmJiB2ZXJzaW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGluZyBzeXN0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBPYmplY3RcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm0ub3MgPSBvcyB8fCB7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIENQVSBhcmNoaXRlY3R1cmUgdGhlIE9TIGlzIGJ1aWx0IGZvci5cclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEB0eXBlIG51bWJlcnxudWxsXHJcbiAgICAgICAqL1xyXG4gICAgICAnYXJjaGl0ZWN0dXJlJzogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgZmFtaWx5IG9mIHRoZSBPUy5cclxuICAgICAgICpcclxuICAgICAgICogQ29tbW9uIHZhbHVlcyBpbmNsdWRlOlxyXG4gICAgICAgKiBcIldpbmRvd3NcIiwgXCJXaW5kb3dzIFNlcnZlciAyMDA4IFIyIC8gN1wiLCBcIldpbmRvd3MgU2VydmVyIDIwMDggLyBWaXN0YVwiLFxyXG4gICAgICAgKiBcIldpbmRvd3MgWFBcIiwgXCJPUyBYXCIsIFwiVWJ1bnR1XCIsIFwiRGViaWFuXCIsIFwiRmVkb3JhXCIsIFwiUmVkIEhhdFwiLCBcIlN1U0VcIixcclxuICAgICAgICogXCJBbmRyb2lkXCIsIFwiaU9TXCIgYW5kIFwiV2luZG93cyBQaG9uZVwiXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xyXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICAgKi9cclxuICAgICAgJ2ZhbWlseSc6IG51bGwsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIHZlcnNpb24gb2YgdGhlIE9TLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcclxuICAgICAgICogQHR5cGUgc3RyaW5nfG51bGxcclxuICAgICAgICovXHJcbiAgICAgICd2ZXJzaW9uJzogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIHRoZSBPUyBzdHJpbmcuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xyXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgT1Mgc3RyaW5nLlxyXG4gICAgICAgKi9cclxuICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7IHJldHVybiAnbnVsbCc7IH1cclxuICAgIH07XHJcblxyXG4gICAgcGxhdGZvcm0ucGFyc2UgPSBwYXJzZTtcclxuICAgIHBsYXRmb3JtLnRvU3RyaW5nID0gdG9TdHJpbmdQbGF0Zm9ybTtcclxuXHJcbiAgICBpZiAocGxhdGZvcm0udmVyc2lvbikge1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgaWYgKHBsYXRmb3JtLm5hbWUpIHtcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdChuYW1lKTtcclxuICAgIH1cclxuICAgIGlmIChvcyAmJiBuYW1lICYmICEob3MgPT0gU3RyaW5nKG9zKS5zcGxpdCgnICcpWzBdICYmIChvcyA9PSBuYW1lLnNwbGl0KCcgJylbMF0gfHwgcHJvZHVjdCkpKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2gocHJvZHVjdCA/ICcoJyArIG9zICsgJyknIDogJ29uICcgKyBvcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XHJcbiAgICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24uam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBsYXRmb3JtO1xyXG4gIH1cclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8vIEV4cG9ydCBwbGF0Zm9ybS5cclxuICB2YXIgcGxhdGZvcm0gPSBwYXJzZSgpO1xyXG5cclxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgLy8gRXhwb3NlIHBsYXRmb3JtIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gcGxhdGZvcm0gaXNcclxuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXHJcbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgcm9vdC5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG5cclxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvIHBsYXRmb3JtIGNhbiBiZSBhbGlhc2VkIHRocm91Z2ggcGF0aCBtYXBwaW5nLlxyXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcGxhdGZvcm07XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cclxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XHJcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXHJcbiAgICBmb3JPd24ocGxhdGZvcm0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgZnJlZUV4cG9ydHNba2V5XSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxyXG4gICAgcm9vdC5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG4gIH1cclxufS5jYWxsKHRoaXMpKTtcclxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXHJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxyXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcclxuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxyXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxyXG5cclxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XHJcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xyXG59XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xyXG4gICAgfVxyXG59ICgpKVxyXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xyXG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcclxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcclxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xyXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcclxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfSBjYXRjaChlKXtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XHJcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcclxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcclxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXHJcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcclxuICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXHJcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcclxudmFyIGN1cnJlbnRRdWV1ZTtcclxudmFyIHF1ZXVlSW5kZXggPSAtMTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcclxuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcclxuICAgIH1cclxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBkcmFpblF1ZXVlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XHJcbiAgICBpZiAoZHJhaW5pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcclxuICAgIGRyYWluaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUobGVuKSB7XHJcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgcXVldWUgPSBbXTtcclxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XHJcbn1cclxuXHJcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XHJcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcclxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xyXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcclxuICAgIHRoaXMuZnVuID0gZnVuO1xyXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xyXG59XHJcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xyXG59O1xyXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xyXG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xyXG5wcm9jZXNzLmVudiA9IHt9O1xyXG5wcm9jZXNzLmFyZ3YgPSBbXTtcclxucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXHJcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cclxucHJvY2Vzcy5vbiA9IG5vb3A7XHJcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLm9uY2UgPSBub29wO1xyXG5wcm9jZXNzLm9mZiA9IG5vb3A7XHJcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XHJcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XHJcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcclxuXHJcbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cclxuXHJcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbn07XHJcblxyXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xyXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxufTtcclxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcclxuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXHJcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XHJcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xyXG4gIHNlcCA9IHNlcCB8fCAnJic7XHJcbiAgZXEgPSBlcSB8fCAnPSc7XHJcbiAgdmFyIG9iaiA9IHt9O1xyXG5cclxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xyXG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcclxuXHJcbiAgdmFyIG1heEtleXMgPSAxMDAwO1xyXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XHJcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcclxuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcclxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xyXG4gICAgbGVuID0gbWF4S2V5cztcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcclxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxyXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XHJcblxyXG4gICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xyXG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrc3RyID0geDtcclxuICAgICAgdnN0ciA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XHJcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xyXG5cclxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xyXG4gICAgICBvYmpba10gPSB2O1xyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcclxuICAgICAgb2JqW2tdLnB1c2godik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xyXG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIHJldHVybiB2O1xyXG5cclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcblxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiAnJztcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xyXG4gIHNlcCA9IHNlcCB8fCAnJic7XHJcbiAgZXEgPSBlcSB8fCAnPSc7XHJcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgb2JqID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xyXG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xyXG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xyXG4gICAgICAgIH0pLmpvaW4oc2VwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xyXG4gICAgICB9XHJcbiAgICB9KS5qb2luKHNlcCk7XHJcblxyXG4gIH1cclxuXHJcbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XHJcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xyXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xyXG59O1xyXG5cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWFwICh4cywgZikge1xyXG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHJlcyA9IFtdO1xyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xyXG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGxsLXJlZmVyZW5jZSBkbGxfYTBlYTgxOTZlODY5YjliNDQyNWUgKi8gXCJkbGwtcmVmZXJlbmNlIGRsbF9hMGVhODE5NmU4NjliOWI0NDI1ZVwiKSkoXCIuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanNcIik7IiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXHJcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIChmdW5jdGlvbigpIHtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcclxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxyXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xyXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcclxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xyXG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XHJcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcclxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xyXG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3JhcnlcclxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XHJcblxyXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xyXG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcclxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XHJcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XHJcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XHJcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcclxudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xyXG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcclxudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXHJcbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcclxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XHJcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XHJcblxyXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcclxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxyXG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcclxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XHJcblxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcclxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcclxuXHJcbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XHJcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xyXG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xyXG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcclxudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcclxudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcclxudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XHJcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xyXG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XHJcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XHJcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcclxudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcclxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxyXG5cclxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XHJcbiAge1xyXG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xyXG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XHJcblxyXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XHJcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xyXG59XHJcbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcclxuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcclxufVxyXG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcclxufVxyXG5cclxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XHJcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcclxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XHJcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xyXG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xyXG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xyXG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XHJcbmV4cG9ydHMuTGF6eSA9IExhenk7XHJcbmV4cG9ydHMuTWVtbyA9IE1lbW87XHJcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xyXG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XHJcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XHJcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcclxuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xyXG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xyXG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XHJcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcclxuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XHJcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xyXG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xyXG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcclxuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XHJcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcclxuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcclxuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XHJcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XHJcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xyXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcclxuICB9KSgpO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xyXG59IGVsc2Uge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF9hMGVhODE5NmU4NjliOWI0NDI1ZSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlXCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzXCIpOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xyXG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcclxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cclxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xyXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XHJcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcclxuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xyXG5cclxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XHJcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cclxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xyXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcclxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xyXG5cclxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcclxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cclxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcclxuXHJcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xyXG4gIH1cclxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xyXG5cclxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cclxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcclxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcclxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXHJcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcclxuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxyXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxyXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcclxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXHJcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XHJcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XHJcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcclxuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG5cclxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXHJcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxyXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XHJcblxyXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxyXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxyXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXHJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cclxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxyXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cclxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XHJcblxyXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcclxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxyXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xyXG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcclxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XHJcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXHJcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxyXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XHJcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxyXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxyXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcclxuICB9XHJcblxyXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XHJcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XHJcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcclxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xyXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XHJcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcclxuXHJcbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcclxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxyXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcclxuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcclxuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcclxuICAgIHJldHVybiBjdG9yXHJcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcclxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXHJcbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxyXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxyXG4gICAgICA6IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xyXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xyXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XHJcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcclxuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XHJcbiAgICByZXR1cm4gZ2VuRnVuO1xyXG4gIH07XHJcblxyXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xyXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XHJcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xyXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXHJcbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XHJcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XHJcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xyXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXHJcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cclxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcclxuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cclxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xyXG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cclxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXHJcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXHJcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxyXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXHJcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cclxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XHJcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcclxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXHJcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXHJcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcclxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXHJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xyXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXHJcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cclxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XHJcbiAgfVxyXG5cclxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xyXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xyXG5cclxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXHJcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXHJcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXHJcbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xyXG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcclxuXHJcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxyXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcclxuICAgICAgUHJvbWlzZUltcGxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxyXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxyXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcclxuICAgICAgICB9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcclxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xyXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgICAgdGhyb3cgYXJnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcclxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXHJcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xyXG5cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xyXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xyXG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXHJcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xyXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcclxuXHJcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xyXG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxyXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcclxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxyXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XHJcblxyXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXHJcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xyXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxyXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cclxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xyXG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxyXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcclxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcclxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cclxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xyXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xyXG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxyXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cclxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcclxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cclxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcclxuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cclxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXHJcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XHJcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xyXG5cclxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xyXG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XHJcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xyXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XHJcblxyXG4gICAgaWYgKCEgaW5mbykge1xyXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcclxuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XHJcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xyXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5mby5kb25lKSB7XHJcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XHJcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXHJcbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xyXG5cclxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxyXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xyXG5cclxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXHJcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcclxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cclxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXHJcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXHJcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cclxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XHJcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cclxuICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcclxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXHJcbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcclxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcclxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXHJcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcclxuXHJcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcclxuXHJcbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcclxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxyXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXHJcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXHJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXHJcbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcclxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XHJcblxyXG4gICAgaWYgKDEgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKDIgaW4gbG9jcykge1xyXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcclxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcclxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xyXG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xyXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XHJcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xyXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXHJcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXHJcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXHJcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xyXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xyXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcclxuICB9XHJcblxyXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBrZXlzLnJldmVyc2UoKTtcclxuXHJcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxyXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cclxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcclxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcclxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXHJcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcbiAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcclxuICAgIGlmIChpdGVyYWJsZSkge1xyXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XHJcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xyXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XHJcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xyXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXHJcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XHJcbiAgfVxyXG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xyXG5cclxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xyXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xyXG4gICAgICB0aGlzLnByZXYgPSAwO1xyXG4gICAgICB0aGlzLm5leHQgPSAwO1xyXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xyXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xyXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xyXG5cclxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxyXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxyXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXHJcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XHJcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XHJcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xyXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcclxuICAgICAgICB0aHJvdyBleGNlcHRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcclxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XHJcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XHJcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcclxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XHJcblxyXG4gICAgICAgIGlmIChjYXVnaHQpIHtcclxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXHJcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxyXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcclxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXHJcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cclxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXHJcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcclxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xyXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xyXG5cclxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcclxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxyXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxyXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcclxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXHJcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcclxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXHJcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxyXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xyXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XHJcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XHJcblxyXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcclxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcclxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcclxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcclxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxyXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xyXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcclxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcclxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xyXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XHJcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcclxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xyXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XHJcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XHJcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcclxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XHJcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xyXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aHJvd247XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cclxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XHJcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XHJcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXHJcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcclxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XHJcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcclxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXHJcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcclxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcclxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcclxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxyXG4gIHJldHVybiBleHBvcnRzO1xyXG5cclxufShcclxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xyXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XHJcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxyXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXHJcbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cclxuKSk7XHJcblxyXG50cnkge1xyXG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XHJcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XHJcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcclxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcclxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcclxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcclxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcclxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxyXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXHJcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXHJcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXHJcbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcclxufVxyXG4iLCJ2YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc8dW5rbm93bj4nO1xyXG4vKipcclxuICogVGhpcyBwYXJzZXMgdGhlIGRpZmZlcmVudCBzdGFjayB0cmFjZXMgYW5kIHB1dHMgdGhlbSBpbnRvIG9uZSBmb3JtYXRcclxuICogVGhpcyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBUcmFjZUtpdCAoaHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvVHJhY2VLaXQpXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGFyc2Uoc3RhY2tTdHJpbmcpIHtcclxuICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdCgnXFxuJyk7XHJcbiAgcmV0dXJuIGxpbmVzLnJlZHVjZShmdW5jdGlvbiAoc3RhY2ssIGxpbmUpIHtcclxuICAgIHZhciBwYXJzZVJlc3VsdCA9IHBhcnNlQ2hyb21lKGxpbmUpIHx8IHBhcnNlV2luanMobGluZSkgfHwgcGFyc2VHZWNrbyhsaW5lKSB8fCBwYXJzZU5vZGUobGluZSkgfHwgcGFyc2VKU0MobGluZSk7XHJcblxyXG4gICAgaWYgKHBhcnNlUmVzdWx0KSB7XHJcbiAgICAgIHN0YWNrLnB1c2gocGFyc2VSZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGFjaztcclxuICB9LCBbXSk7XHJcbn1cclxudmFyIGNocm9tZVJlID0gL15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7XHJcbnZhciBjaHJvbWVFdmFsUmUgPSAvXFwoKFxcUyopKD86OihcXGQrKSkoPzo6KFxcZCspKVxcKS87XHJcblxyXG5mdW5jdGlvbiBwYXJzZUNocm9tZShsaW5lKSB7XHJcbiAgdmFyIHBhcnRzID0gY2hyb21lUmUuZXhlYyhsaW5lKTtcclxuXHJcbiAgaWYgKCFwYXJ0cykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgaXNOYXRpdmUgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCduYXRpdmUnKSA9PT0gMDsgLy8gc3RhcnQgb2YgbGluZVxyXG5cclxuICB2YXIgaXNFdmFsID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignZXZhbCcpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXHJcblxyXG4gIHZhciBzdWJtYXRjaCA9IGNocm9tZUV2YWxSZS5leGVjKHBhcnRzWzJdKTtcclxuXHJcbiAgaWYgKGlzRXZhbCAmJiBzdWJtYXRjaCAhPSBudWxsKSB7XHJcbiAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUvY29sdW1uIG51bWJlclxyXG4gICAgcGFydHNbMl0gPSBzdWJtYXRjaFsxXTsgLy8gdXJsXHJcblxyXG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsyXTsgLy8gbGluZVxyXG5cclxuICAgIHBhcnRzWzRdID0gc3VibWF0Y2hbM107IC8vIGNvbHVtblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGU6ICFpc05hdGl2ZSA/IHBhcnRzWzJdIDogbnVsbCxcclxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXHJcbiAgICBhcmd1bWVudHM6IGlzTmF0aXZlID8gW3BhcnRzWzJdXSA6IFtdLFxyXG4gICAgbGluZU51bWJlcjogcGFydHNbM10gPyArcGFydHNbM10gOiBudWxsLFxyXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcclxuICB9O1xyXG59XHJcblxyXG52YXIgd2luanNSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweHxodHRwcz98d2VicGFja3xibG9iKTouKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VXaW5qcyhsaW5lKSB7XHJcbiAgdmFyIHBhcnRzID0gd2luanNSZS5leGVjKGxpbmUpO1xyXG5cclxuICBpZiAoIXBhcnRzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWxlOiBwYXJ0c1syXSxcclxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXHJcbiAgICBhcmd1bWVudHM6IFtdLFxyXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxyXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcclxuICB9O1xyXG59XHJcblxyXG52YXIgZ2Vja29SZSA9IC9eXFxzKiguKj8pKD86XFwoKC4qPylcXCkpPyg/Ol58QCkoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWV8d2VicGFja3xyZXNvdXJjZXxcXFtuYXRpdmUpLio/fFteQF0qYnVuZGxlKSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xccyokL2k7XHJcbnZhciBnZWNrb0V2YWxSZSA9IC8oXFxTKykgbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbC9pO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VHZWNrbyhsaW5lKSB7XHJcbiAgdmFyIHBhcnRzID0gZ2Vja29SZS5leGVjKGxpbmUpO1xyXG5cclxuICBpZiAoIXBhcnRzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKCcgPiBldmFsJykgPiAtMTtcclxuICB2YXIgc3VibWF0Y2ggPSBnZWNrb0V2YWxSZS5leGVjKHBhcnRzWzNdKTtcclxuXHJcbiAgaWYgKGlzRXZhbCAmJiBzdWJtYXRjaCAhPSBudWxsKSB7XHJcbiAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUgbnVtYmVyXHJcbiAgICBwYXJ0c1szXSA9IHN1Ym1hdGNoWzFdO1xyXG4gICAgcGFydHNbNF0gPSBzdWJtYXRjaFsyXTtcclxuICAgIHBhcnRzWzVdID0gbnVsbDsgLy8gbm8gY29sdW1uIHdoZW4gZXZhbFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGU6IHBhcnRzWzNdLFxyXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcclxuICAgIGFyZ3VtZW50czogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnLCcpIDogW10sXHJcbiAgICBsaW5lTnVtYmVyOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGwsXHJcbiAgICBjb2x1bW46IHBhcnRzWzVdID8gK3BhcnRzWzVdIDogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBqYXZhU2NyaXB0Q29yZVJlID0gL15cXHMqKD86KFteQF0qKSg/OlxcKCguKj8pXFwpKT9AKT8oXFxTLio/KTooXFxkKykoPzo6KFxcZCspKT9cXHMqJC9pO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VKU0MobGluZSkge1xyXG4gIHZhciBwYXJ0cyA9IGphdmFTY3JpcHRDb3JlUmUuZXhlYyhsaW5lKTtcclxuXHJcbiAgaWYgKCFwYXJ0cykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZmlsZTogcGFydHNbM10sXHJcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxyXG4gICAgYXJndW1lbnRzOiBbXSxcclxuICAgIGxpbmVOdW1iZXI6ICtwYXJ0c1s0XSxcclxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxudmFyIG5vZGVSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlTm9kZShsaW5lKSB7XHJcbiAgdmFyIHBhcnRzID0gbm9kZVJlLmV4ZWMobGluZSk7XHJcblxyXG4gIGlmICghcGFydHMpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZpbGU6IHBhcnRzWzJdLFxyXG4gICAgbWV0aG9kTmFtZTogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcclxuICAgIGFyZ3VtZW50czogW10sXHJcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbM10sXHJcbiAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCB7IHBhcnNlIH07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuY29uc3QgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmcgPT4gdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgPyBzdHJpbmcucmVwbGFjZShhbnNpUmVnZXgoKSwgJycpIDogc3RyaW5nO1xyXG4iLCJ2YXIgdCxuLGU9ZnVuY3Rpb24oKXtyZXR1cm5cIlwiLmNvbmNhdChEYXRlLm5vdygpLFwiLVwiKS5jb25jYXQoTWF0aC5mbG9vcig4OTk5OTk5OTk5OTk5Kk1hdGgucmFuZG9tKCkpKzFlMTIpfSxpPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTotMTtyZXR1cm57bmFtZTp0LHZhbHVlOm4sZGVsdGE6MCxlbnRyaWVzOltdLGlkOmUoKSxpc0ZpbmFsOiExfX0sYT1mdW5jdGlvbih0LG4pe3RyeXtpZihQZXJmb3JtYW5jZU9ic2VydmVyLnN1cHBvcnRlZEVudHJ5VHlwZXMuaW5jbHVkZXModCkpe3ZhciBlPW5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRFbnRyaWVzKCkubWFwKG4pfSkpO3JldHVybiBlLm9ic2VydmUoe3R5cGU6dCxidWZmZXJlZDohMH0pLGV9fWNhdGNoKHQpe319LHI9ITEsbz0hMSxzPWZ1bmN0aW9uKHQpe3I9IXQucGVyc2lzdGVkfSx1PWZ1bmN0aW9uKCl7YWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIscyksYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLChmdW5jdGlvbigpe30pKX0sYz1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO298fCh1KCksbz0hMCksYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwoZnVuY3Rpb24obil7dmFyIGU9bi50aW1lU3RhbXA7XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSYmdCh7dGltZVN0YW1wOmUsaXNVbmxvYWRpbmc6cn0pfSkse2NhcHR1cmU6ITAsb25jZTpufSl9LGw9ZnVuY3Rpb24odCxuLGUsaSl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKCl7ZSYmbi5pc0ZpbmFsJiZlLmRpc2Nvbm5lY3QoKSxuLnZhbHVlPj0wJiYoaXx8bi5pc0ZpbmFsfHxcImhpZGRlblwiPT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKSYmKG4uZGVsdGE9bi52YWx1ZS0oYXx8MCksKG4uZGVsdGF8fG4uaXNGaW5hbHx8dm9pZCAwPT09YSkmJih0KG4pLGE9bi52YWx1ZSkpfX0scD1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLGU9aShcIkNMU1wiLDApLHI9ZnVuY3Rpb24odCl7dC5oYWRSZWNlbnRJbnB1dHx8KGUudmFsdWUrPXQudmFsdWUsZS5lbnRyaWVzLnB1c2godCkscygpKX0sbz1hKFwibGF5b3V0LXNoaWZ0XCIscikscz1sKHQsZSxvLG4pO2MoKGZ1bmN0aW9uKHQpe3ZhciBuPXQuaXNVbmxvYWRpbmc7byYmby50YWtlUmVjb3JkcygpLm1hcChyKSxuJiYoZS5pc0ZpbmFsPSEwKSxzKCl9KSl9LGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZT8wOjEvMCxjKChmdW5jdGlvbihuKXt2YXIgZT1uLnRpbWVTdGFtcDtyZXR1cm4gdD1lfSksITApKSx7Z2V0IHRpbWVTdGFtcCgpe3JldHVybiB0fX19LG09ZnVuY3Rpb24odCl7dmFyIG49aShcIkZDUFwiKSxlPWQoKSxyPWEoXCJwYWludFwiLChmdW5jdGlvbih0KXtcImZpcnN0LWNvbnRlbnRmdWwtcGFpbnRcIj09PXQubmFtZSYmdC5zdGFydFRpbWU8ZS50aW1lU3RhbXAmJihuLnZhbHVlPXQuc3RhcnRUaW1lLG4uaXNGaW5hbD0hMCxuLmVudHJpZXMucHVzaCh0KSxvKCkpfSkpLG89bCh0LG4scil9LHY9ZnVuY3Rpb24odCl7dmFyIG49aShcIkZJRFwiKSxlPWQoKSxyPWZ1bmN0aW9uKHQpe3Quc3RhcnRUaW1lPGUudGltZVN0YW1wJiYobi52YWx1ZT10LnByb2Nlc3NpbmdTdGFydC10LnN0YXJ0VGltZSxuLmVudHJpZXMucHVzaCh0KSxuLmlzRmluYWw9ITAscygpKX0sbz1hKFwiZmlyc3QtaW5wdXRcIixyKSxzPWwodCxuLG8pO2MoKGZ1bmN0aW9uKCl7byYmKG8udGFrZVJlY29yZHMoKS5tYXAociksby5kaXNjb25uZWN0KCkpfSksITApLG98fHdpbmRvdy5wZXJmTWV0cmljcyYmd2luZG93LnBlcmZNZXRyaWNzLm9uRmlyc3RJbnB1dERlbGF5JiZ3aW5kb3cucGVyZk1ldHJpY3Mub25GaXJzdElucHV0RGVsYXkoKGZ1bmN0aW9uKHQsaSl7aS50aW1lU3RhbXA8ZS50aW1lU3RhbXAmJihuLnZhbHVlPXQsbi5pc0ZpbmFsPSEwLG4uZW50cmllcz1be2VudHJ5VHlwZTpcImZpcnN0LWlucHV0XCIsbmFtZTppLnR5cGUsdGFyZ2V0OmkudGFyZ2V0LGNhbmNlbGFibGU6aS5jYW5jZWxhYmxlLHN0YXJ0VGltZTppLnRpbWVTdGFtcCxwcm9jZXNzaW5nU3RhcnQ6aS50aW1lU3RhbXArdH1dLHMoKSl9KSl9LGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnx8KG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybltcInNjcm9sbFwiLFwia2V5ZG93blwiLFwicG9pbnRlcmRvd25cIl0ubWFwKChmdW5jdGlvbihuKXthZGRFdmVudExpc3RlbmVyKG4sdCx7b25jZTohMCxwYXNzaXZlOiEwLGNhcHR1cmU6ITB9KX0pKX0pKSksbn0sZz1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLGU9aShcIkxDUFwiKSxyPWQoKSxvPWZ1bmN0aW9uKHQpe3ZhciBuPXQuc3RhcnRUaW1lO248ci50aW1lU3RhbXA/KGUudmFsdWU9bixlLmVudHJpZXMucHVzaCh0KSk6ZS5pc0ZpbmFsPSEwLHUoKX0scz1hKFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsbyksdT1sKHQsZSxzLG4pLHA9ZnVuY3Rpb24oKXtlLmlzRmluYWx8fChzJiZzLnRha2VSZWNvcmRzKCkubWFwKG8pLGUuaXNGaW5hbD0hMCx1KCkpfTtmKCkudGhlbihwKSxjKHAsITApfSxoPWZ1bmN0aW9uKHQpe3ZhciBuLGU9aShcIlRURkJcIik7bj1mdW5jdGlvbigpe3RyeXt2YXIgbj1wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKFwibmF2aWdhdGlvblwiKVswXXx8ZnVuY3Rpb24oKXt2YXIgdD1wZXJmb3JtYW5jZS50aW1pbmcsbj17ZW50cnlUeXBlOlwibmF2aWdhdGlvblwiLHN0YXJ0VGltZTowfTtmb3IodmFyIGUgaW4gdClcIm5hdmlnYXRpb25TdGFydFwiIT09ZSYmXCJ0b0pTT05cIiE9PWUmJihuW2VdPU1hdGgubWF4KHRbZV0tdC5uYXZpZ2F0aW9uU3RhcnQsMCkpO3JldHVybiBufSgpO2UudmFsdWU9ZS5kZWx0YT1uLnJlc3BvbnNlU3RhcnQsZS5lbnRyaWVzPVtuXSxlLmlzRmluYWw9ITAsdChlKX1jYXRjaCh0KXt9fSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP3NldFRpbWVvdXQobiwwKTphZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIixuKX07ZXhwb3J0e3AgYXMgZ2V0Q0xTLG0gYXMgZ2V0RkNQLHYgYXMgZ2V0RklELGcgYXMgZ2V0TENQLGggYXMgZ2V0VFRGQn07XHJcbiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZGxsX2EwZWE4MTk2ZTg2OWI5YjQ0MjVlOyJdLCJzb3VyY2VSb290IjoiIn0=